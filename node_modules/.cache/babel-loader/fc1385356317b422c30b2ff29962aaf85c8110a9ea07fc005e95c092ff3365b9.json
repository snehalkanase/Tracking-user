{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n/**\n * States for Batch.\n */\nvar BatchStates;\n(function (BatchStates) {\n  BatchStates[BatchStates[\"Good\"] = 0] = \"Good\";\n  BatchStates[BatchStates[\"Error\"] = 1] = \"Error\";\n})(BatchStates || (BatchStates = {}));\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\nexport class Batch {\n  /**\n   * Creates an instance of Batch.\n   * @param concurrency -\n   */\n  constructor() {\n    let concurrency = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n    /**\n     * Number of active operations under execution.\n     */\n    this.actives = 0;\n    /**\n     * Number of completed operations under execution.\n     */\n    this.completed = 0;\n    /**\n     * Offset of next operation to be executed.\n     */\n    this.offset = 0;\n    /**\n     * Operation array to be executed.\n     */\n    this.operations = [];\n    /**\n     * States of Batch. When an error happens, state will turn into error.\n     * Batch will stop execute left operations.\n     */\n    this.state = BatchStates.Good;\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n  /**\n   * Add a operation into queue.\n   *\n   * @param operation -\n   */\n  addOperation(operation) {\n    this.operations.push(async () => {\n      try {\n        this.actives++;\n        await operation();\n        this.actives--;\n        this.completed++;\n        this.parallelExecute();\n      } catch (error) {\n        this.emitter.emit(\"error\", error);\n      }\n    });\n  }\n  /**\n   * Start execute operations in the queue.\n   *\n   */\n  async do() {\n    if (this.operations.length === 0) {\n      return Promise.resolve();\n    }\n    this.parallelExecute();\n    return new Promise((resolve, reject) => {\n      this.emitter.on(\"finish\", resolve);\n      this.emitter.on(\"error\", error => {\n        this.state = BatchStates.Error;\n        reject(error);\n      });\n    });\n  }\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   */\n  nextOperation() {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n    return null;\n  }\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   */\n  parallelExecute() {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n    while (this.actives < this.concurrency) {\n      const operation = this.nextOperation();\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  }\n}","map":{"version":3,"names":["EventEmitter","BatchStates","Batch","constructor","concurrency","arguments","length","undefined","actives","completed","offset","operations","state","Good","RangeError","emitter","addOperation","operation","push","parallelExecute","error","emit","do","Promise","resolve","reject","on","Error","nextOperation"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\storage-blob\\src\\utils\\Batch.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n\n/**\n * Operation is an async function to be executed and managed by Batch.\n */\nexport declare type Operation = () => Promise<any>;\n\n/**\n * States for Batch.\n */\nenum BatchStates {\n  Good,\n  Error,\n}\n\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\nexport class Batch {\n  /**\n   * Concurrency. Must be lager than 0.\n   */\n  private concurrency: number;\n\n  /**\n   * Number of active operations under execution.\n   */\n  private actives: number = 0;\n\n  /**\n   * Number of completed operations under execution.\n   */\n  private completed: number = 0;\n\n  /**\n   * Offset of next operation to be executed.\n   */\n  private offset: number = 0;\n\n  /**\n   * Operation array to be executed.\n   */\n  private operations: Operation[] = [];\n\n  /**\n   * States of Batch. When an error happens, state will turn into error.\n   * Batch will stop execute left operations.\n   */\n  private state: BatchStates = BatchStates.Good;\n\n  /**\n   * A private emitter used to pass events inside this class.\n   */\n  private emitter: EventEmitter;\n\n  /**\n   * Creates an instance of Batch.\n   * @param concurrency -\n   */\n  public constructor(concurrency: number = 5) {\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n\n  /**\n   * Add a operation into queue.\n   *\n   * @param operation -\n   */\n  public addOperation(operation: Operation): void {\n    this.operations.push(async () => {\n      try {\n        this.actives++;\n        await operation();\n        this.actives--;\n        this.completed++;\n        this.parallelExecute();\n      } catch (error: any) {\n        this.emitter.emit(\"error\", error);\n      }\n    });\n  }\n\n  /**\n   * Start execute operations in the queue.\n   *\n   */\n  public async do(): Promise<void> {\n    if (this.operations.length === 0) {\n      return Promise.resolve();\n    }\n\n    this.parallelExecute();\n\n    return new Promise<void>((resolve, reject) => {\n      this.emitter.on(\"finish\", resolve);\n\n      this.emitter.on(\"error\", (error) => {\n        this.state = BatchStates.Error;\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   */\n  private nextOperation(): Operation | null {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n    return null;\n  }\n\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   */\n  private parallelExecute(): void {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n\n    while (this.actives < this.concurrency) {\n      const operation = this.nextOperation();\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AAEA;AACA;AACA,SAASA,YAAY,QAAQ,QAAQ;AAOrC;;;AAGA,IAAKC,WAGJ;AAHD,WAAKA,WAAW;EACdA,WAAA,CAAAA,WAAA,sBAAI;EACJA,WAAA,CAAAA,WAAA,wBAAK;AACP,CAAC,EAHIA,WAAW,KAAXA,WAAW;AAKhB;;;;;AAKA,OAAM,MAAOC,KAAK;EAqChB;;;;EAIAC,YAAA,EAA0C;IAAA,IAAvBC,WAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAsB,CAAC;IAnC1C;;;IAGQ,KAAAG,OAAO,GAAW,CAAC;IAE3B;;;IAGQ,KAAAC,SAAS,GAAW,CAAC;IAE7B;;;IAGQ,KAAAC,MAAM,GAAW,CAAC;IAE1B;;;IAGQ,KAAAC,UAAU,GAAgB,EAAE;IAEpC;;;;IAIQ,KAAAC,KAAK,GAAgBX,WAAW,CAACY,IAAI;IAY3C,IAAIT,WAAW,GAAG,CAAC,EAAE;MACnB,MAAM,IAAIU,UAAU,CAAC,mCAAmC,CAAC;;IAE3D,IAAI,CAACV,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACW,OAAO,GAAG,IAAIf,YAAY,EAAE;EACnC;EAEA;;;;;EAKOgB,YAAYA,CAACC,SAAoB;IACtC,IAAI,CAACN,UAAU,CAACO,IAAI,CAAC,YAAW;MAC9B,IAAI;QACF,IAAI,CAACV,OAAO,EAAE;QACd,MAAMS,SAAS,EAAE;QACjB,IAAI,CAACT,OAAO,EAAE;QACd,IAAI,CAACC,SAAS,EAAE;QAChB,IAAI,CAACU,eAAe,EAAE;OACvB,CAAC,OAAOC,KAAU,EAAE;QACnB,IAAI,CAACL,OAAO,CAACM,IAAI,CAAC,OAAO,EAAED,KAAK,CAAC;;IAErC,CAAC,CAAC;EACJ;EAEA;;;;EAIO,MAAME,EAAEA,CAAA;IACb,IAAI,IAAI,CAACX,UAAU,CAACL,MAAM,KAAK,CAAC,EAAE;MAChC,OAAOiB,OAAO,CAACC,OAAO,EAAE;;IAG1B,IAAI,CAACL,eAAe,EAAE;IAEtB,OAAO,IAAII,OAAO,CAAO,CAACC,OAAO,EAAEC,MAAM,KAAI;MAC3C,IAAI,CAACV,OAAO,CAACW,EAAE,CAAC,QAAQ,EAAEF,OAAO,CAAC;MAElC,IAAI,CAACT,OAAO,CAACW,EAAE,CAAC,OAAO,EAAGN,KAAK,IAAI;QACjC,IAAI,CAACR,KAAK,GAAGX,WAAW,CAAC0B,KAAK;QAC9BF,MAAM,CAACL,KAAK,CAAC;MACf,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA;;;;EAIQQ,aAAaA,CAAA;IACnB,IAAI,IAAI,CAAClB,MAAM,GAAG,IAAI,CAACC,UAAU,CAACL,MAAM,EAAE;MACxC,OAAO,IAAI,CAACK,UAAU,CAAC,IAAI,CAACD,MAAM,EAAE,CAAC;;IAEvC,OAAO,IAAI;EACb;EAEA;;;;;EAKQS,eAAeA,CAAA;IACrB,IAAI,IAAI,CAACP,KAAK,KAAKX,WAAW,CAAC0B,KAAK,EAAE;MACpC;;IAGF,IAAI,IAAI,CAAClB,SAAS,IAAI,IAAI,CAACE,UAAU,CAACL,MAAM,EAAE;MAC5C,IAAI,CAACS,OAAO,CAACM,IAAI,CAAC,QAAQ,CAAC;MAC3B;;IAGF,OAAO,IAAI,CAACb,OAAO,GAAG,IAAI,CAACJ,WAAW,EAAE;MACtC,MAAMa,SAAS,GAAG,IAAI,CAACW,aAAa,EAAE;MACtC,IAAIX,SAAS,EAAE;QACbA,SAAS,EAAE;OACZ,MAAM;QACL;;;EAGN"},"metadata":{},"sourceType":"module","externalDependencies":[]}