{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy, deserializationPolicy, generateUuid, HttpHeaders, WebResource, isTokenCredential, bearerTokenAuthenticationPolicy, isNode } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { BlobClient } from \"./Clients\";\nimport { Mutex } from \"./utils/Mutex\";\nimport { Pipeline } from \"./Pipeline\";\nimport { attachCredential, getURLPath, getURLPathAndQuery, iEqual } from \"./utils/utils.common\";\nimport { HeaderConstants, BATCH_MAX_REQUEST, HTTP_VERSION_1_1, HTTP_LINE_ENDING, StorageOAuthScopes } from \"./utils/constants\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { createSpan } from \"./utils/tracing\";\n/**\n * A BlobBatch represents an aggregated set of operations on blobs.\n * Currently, only `delete` and `setAccessTier` are supported.\n */\nexport class BlobBatch {\n  constructor() {\n    this.batch = \"batch\";\n    this.batchRequest = new InnerBatchRequest();\n  }\n  /**\n   * Get the value of Content-Type for a batch request.\n   * The value must be multipart/mixed with a batch boundary.\n   * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252\n   */\n  getMultiPartContentType() {\n    return this.batchRequest.getMultipartContentType();\n  }\n  /**\n   * Get assembled HTTP request body for sub requests.\n   */\n  getHttpRequestBody() {\n    return this.batchRequest.getHttpRequestBody();\n  }\n  /**\n   * Get sub requests that are added into the batch request.\n   */\n  getSubRequests() {\n    return this.batchRequest.getSubRequests();\n  }\n  async addSubRequestInternal(subRequest, assembleSubRequestFunc) {\n    await Mutex.lock(this.batch);\n    try {\n      this.batchRequest.preAddSubRequest(subRequest);\n      await assembleSubRequestFunc();\n      this.batchRequest.postAddSubRequest(subRequest);\n    } finally {\n      await Mutex.unlock(this.batch);\n    }\n  }\n  setBatchType(batchType) {\n    if (!this.batchType) {\n      this.batchType = batchType;\n    }\n    if (this.batchType !== batchType) {\n      throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);\n    }\n  }\n  async deleteBlob(urlOrBlobClient, credentialOrOptions, options) {\n    let url;\n    let credential;\n    if (typeof urlOrBlobClient === \"string\" && (isNode && credentialOrOptions instanceof StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential || isTokenCredential(credentialOrOptions))) {\n      // First overload\n      url = urlOrBlobClient;\n      credential = credentialOrOptions;\n    } else if (urlOrBlobClient instanceof BlobClient) {\n      // Second overload\n      url = urlOrBlobClient.url;\n      credential = urlOrBlobClient.credential;\n      options = credentialOrOptions;\n    } else {\n      throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n    }\n    if (!options) {\n      options = {};\n    }\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BatchDeleteRequest-addSubRequest\", options);\n    try {\n      this.setBatchType(\"delete\");\n      await this.addSubRequestInternal({\n        url: url,\n        credential: credential\n      }, async () => {\n        await new BlobClient(url, this.batchRequest.createPipeline(credential)).delete(updatedOptions);\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {\n    let url;\n    let credential;\n    let tier;\n    if (typeof urlOrBlobClient === \"string\" && (isNode && credentialOrTier instanceof StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential || isTokenCredential(credentialOrTier))) {\n      // First overload\n      url = urlOrBlobClient;\n      credential = credentialOrTier;\n      tier = tierOrOptions;\n    } else if (urlOrBlobClient instanceof BlobClient) {\n      // Second overload\n      url = urlOrBlobClient.url;\n      credential = urlOrBlobClient.credential;\n      tier = credentialOrTier;\n      options = tierOrOptions;\n    } else {\n      throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n    }\n    if (!options) {\n      options = {};\n    }\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BatchSetTierRequest-addSubRequest\", options);\n    try {\n      this.setBatchType(\"setAccessTier\");\n      await this.addSubRequestInternal({\n        url: url,\n        credential: credential\n      }, async () => {\n        await new BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n/**\n * Inner batch request class which is responsible for assembling and serializing sub requests.\n * See https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#request-body for how requests are assembled.\n */\nclass InnerBatchRequest {\n  constructor() {\n    this.operationCount = 0;\n    this.body = \"\";\n    const tempGuid = generateUuid();\n    // batch_{batchid}\n    this.boundary = `batch_${tempGuid}`;\n    // --batch_{batchid}\n    // Content-Type: application/http\n    // Content-Transfer-Encoding: binary\n    this.subRequestPrefix = `--${this.boundary}${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TYPE}: application/http${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;\n    // multipart/mixed; boundary=batch_{batchid}\n    this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;\n    // --batch_{batchid}--\n    this.batchRequestEnding = `--${this.boundary}--`;\n    this.subRequests = new Map();\n  }\n  /**\n   * Create pipeline to assemble sub requests. The idea here is to use existing\n   * credential and serialization/deserialization components, with additional policies to\n   * filter unnecessary headers, assemble sub requests into request's body\n   * and intercept request from going to wire.\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n  createPipeline(credential) {\n    const isAnonymousCreds = credential instanceof AnonymousCredential;\n    const policyFactoryLength = 3 + (isAnonymousCreds ? 0 : 1); // [deserializationPolicy, BatchHeaderFilterPolicyFactory, (Optional)Credential, BatchRequestAssemblePolicyFactory]\n    const factories = new Array(policyFactoryLength);\n    factories[0] = deserializationPolicy(); // Default deserializationPolicy is provided by protocol layer\n    factories[1] = new BatchHeaderFilterPolicyFactory(); // Use batch header filter policy to exclude unnecessary headers\n    if (!isAnonymousCreds) {\n      factories[2] = isTokenCredential(credential) ? attachCredential(bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes), credential) : credential;\n    }\n    factories[policyFactoryLength - 1] = new BatchRequestAssemblePolicyFactory(this); // Use batch assemble policy to assemble request and intercept request from going to wire\n    return new Pipeline(factories, {});\n  }\n  appendSubRequestToBody(request) {\n    // Start to assemble sub request\n    this.body += [this.subRequestPrefix, `${HeaderConstants.CONTENT_ID}: ${this.operationCount}`, \"\", `${request.method.toString()} ${getURLPathAndQuery(request.url)} ${HTTP_VERSION_1_1}${HTTP_LINE_ENDING}` // sub request start line with method\n    ].join(HTTP_LINE_ENDING);\n    for (const header of request.headers.headersArray()) {\n      this.body += `${header.name}: ${header.value}${HTTP_LINE_ENDING}`;\n    }\n    this.body += HTTP_LINE_ENDING; // sub request's headers need be ending with an empty line\n    // No body to assemble for current batch request support\n    // End to assemble sub request\n  }\n\n  preAddSubRequest(subRequest) {\n    if (this.operationCount >= BATCH_MAX_REQUEST) {\n      throw new RangeError(`Cannot exceed ${BATCH_MAX_REQUEST} sub requests in a single batch`);\n    }\n    // Fast fail if url for sub request is invalid\n    const path = getURLPath(subRequest.url);\n    if (!path || path === \"\") {\n      throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);\n    }\n  }\n  postAddSubRequest(subRequest) {\n    this.subRequests.set(this.operationCount, subRequest);\n    this.operationCount++;\n  }\n  // Return the http request body with assembling the ending line to the sub request body.\n  getHttpRequestBody() {\n    return `${this.body}${this.batchRequestEnding}${HTTP_LINE_ENDING}`;\n  }\n  getMultipartContentType() {\n    return this.multipartContentType;\n  }\n  getSubRequests() {\n    return this.subRequests;\n  }\n}\nclass BatchRequestAssemblePolicy extends BaseRequestPolicy {\n  constructor(batchRequest, nextPolicy, options) {\n    super(nextPolicy, options);\n    this.dummyResponse = {\n      request: new WebResource(),\n      status: 200,\n      headers: new HttpHeaders()\n    };\n    this.batchRequest = batchRequest;\n  }\n  async sendRequest(request) {\n    await this.batchRequest.appendSubRequestToBody(request);\n    return this.dummyResponse; // Intercept request from going to wire\n  }\n}\n\nclass BatchRequestAssemblePolicyFactory {\n  constructor(batchRequest) {\n    this.batchRequest = batchRequest;\n  }\n  create(nextPolicy, options) {\n    return new BatchRequestAssemblePolicy(this.batchRequest, nextPolicy, options);\n  }\n}\nclass BatchHeaderFilterPolicy extends BaseRequestPolicy {\n  // The base class has a protected constructor. Adding a public one to enable constructing of this class.\n  /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/\n  constructor(nextPolicy, options) {\n    super(nextPolicy, options);\n  }\n  async sendRequest(request) {\n    let xMsHeaderName = \"\";\n    for (const header of request.headers.headersArray()) {\n      if (iEqual(header.name, HeaderConstants.X_MS_VERSION)) {\n        xMsHeaderName = header.name;\n      }\n    }\n    if (xMsHeaderName !== \"\") {\n      request.headers.remove(xMsHeaderName); // The subrequests should not have the x-ms-version header.\n    }\n\n    return this._nextPolicy.sendRequest(request);\n  }\n}\nclass BatchHeaderFilterPolicyFactory {\n  create(nextPolicy, options) {\n    return new BatchHeaderFilterPolicy(nextPolicy, options);\n  }\n}","map":{"version":3,"names":["BaseRequestPolicy","deserializationPolicy","generateUuid","HttpHeaders","WebResource","isTokenCredential","bearerTokenAuthenticationPolicy","isNode","SpanStatusCode","AnonymousCredential","BlobClient","Mutex","Pipeline","attachCredential","getURLPath","getURLPathAndQuery","iEqual","HeaderConstants","BATCH_MAX_REQUEST","HTTP_VERSION_1_1","HTTP_LINE_ENDING","StorageOAuthScopes","StorageSharedKeyCredential","createSpan","BlobBatch","constructor","batch","batchRequest","InnerBatchRequest","getMultiPartContentType","getMultipartContentType","getHttpRequestBody","getSubRequests","addSubRequestInternal","subRequest","assembleSubRequestFunc","lock","preAddSubRequest","postAddSubRequest","unlock","setBatchType","batchType","RangeError","deleteBlob","urlOrBlobClient","credentialOrOptions","options","url","credential","span","updatedOptions","createPipeline","delete","e","setStatus","code","ERROR","message","end","setBlobAccessTier","credentialOrTier","tierOrOptions","tier","setAccessTier","operationCount","body","tempGuid","boundary","subRequestPrefix","CONTENT_TYPE","CONTENT_TRANSFER_ENCODING","multipartContentType","batchRequestEnding","subRequests","Map","isAnonymousCreds","policyFactoryLength","factories","Array","BatchHeaderFilterPolicyFactory","BatchRequestAssemblePolicyFactory","appendSubRequestToBody","request","CONTENT_ID","method","toString","join","header","headers","headersArray","name","value","path","set","BatchRequestAssemblePolicy","nextPolicy","dummyResponse","status","sendRequest","create","BatchHeaderFilterPolicy","xMsHeaderName","X_MS_VERSION","remove","_nextPolicy"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\storage-blob\\src\\BlobBatch.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  deserializationPolicy,\n  generateUuid,\n  HttpHeaders,\n  HttpOperationResponse,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n  WebResource,\n  TokenCredential,\n  isTokenCredential,\n  bearerTokenAuthenticationPolicy,\n  isNode,\n} from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { BlobClient, BlobDeleteOptions, BlobSetTierOptions } from \"./Clients\";\nimport { AccessTier } from \"./generatedModels\";\nimport { Mutex } from \"./utils/Mutex\";\nimport { Pipeline } from \"./Pipeline\";\nimport { attachCredential, getURLPath, getURLPathAndQuery, iEqual } from \"./utils/utils.common\";\nimport {\n  HeaderConstants,\n  BATCH_MAX_REQUEST,\n  HTTP_VERSION_1_1,\n  HTTP_LINE_ENDING,\n  StorageOAuthScopes,\n} from \"./utils/constants\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { createSpan } from \"./utils/tracing\";\n\n/**\n * A request associated with a batch operation.\n */\nexport interface BatchSubRequest {\n  /**\n   * The URL of the resource to request operation.\n   */\n  url: string;\n\n  /**\n   * The credential used for sub request.\n   * Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service.\n   * You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n  credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;\n}\n\n/**\n * A BlobBatch represents an aggregated set of operations on blobs.\n * Currently, only `delete` and `setAccessTier` are supported.\n */\nexport class BlobBatch {\n  private batchRequest: InnerBatchRequest;\n  private readonly batch: string = \"batch\";\n  private batchType: \"delete\" | \"setAccessTier\" | undefined;\n\n  constructor() {\n    this.batchRequest = new InnerBatchRequest();\n  }\n\n  /**\n   * Get the value of Content-Type for a batch request.\n   * The value must be multipart/mixed with a batch boundary.\n   * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252\n   */\n  public getMultiPartContentType(): string {\n    return this.batchRequest.getMultipartContentType();\n  }\n\n  /**\n   * Get assembled HTTP request body for sub requests.\n   */\n  public getHttpRequestBody(): string {\n    return this.batchRequest.getHttpRequestBody();\n  }\n\n  /**\n   * Get sub requests that are added into the batch request.\n   */\n  public getSubRequests(): Map<number, BatchSubRequest> {\n    return this.batchRequest.getSubRequests();\n  }\n\n  private async addSubRequestInternal(\n    subRequest: BatchSubRequest,\n    assembleSubRequestFunc: () => Promise<void>\n  ): Promise<void> {\n    await Mutex.lock(this.batch);\n\n    try {\n      this.batchRequest.preAddSubRequest(subRequest);\n      await assembleSubRequestFunc();\n      this.batchRequest.postAddSubRequest(subRequest);\n    } finally {\n      await Mutex.unlock(this.batch);\n    }\n  }\n\n  private setBatchType(batchType: \"delete\" | \"setAccessTier\"): void {\n    if (!this.batchType) {\n      this.batchType = batchType;\n    }\n    if (this.batchType !== batchType) {\n      throw new RangeError(\n        `BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`\n      );\n    }\n  }\n\n  /**\n   * The deleteBlob operation marks the specified blob or snapshot for deletion.\n   * The blob is later deleted during garbage collection.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * Note that in order to delete a blob, you must delete all of its snapshots.\n   * You can delete both at the same time. See [delete operation details](https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob).\n   * The operation will be authenticated and authorized with specified credential.\n   * See [blob batch authorization details](https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param url - The url of the blob resource to delete.\n   * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options -\n   */\n  public async deleteBlob(\n    url: string,\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    options?: BlobDeleteOptions\n  ): Promise<void>;\n\n  /**\n   * The deleteBlob operation marks the specified blob or snapshot for deletion.\n   * The blob is later deleted during garbage collection.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * Note that in order to delete a blob, you must delete all of its snapshots.\n   * You can delete both at the same time. See [delete operation details](https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob).\n   * The operation will be authenticated and authorized with specified credential.\n   * See [blob batch authorization details](https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param blobClient - The BlobClient.\n   * @param options -\n   */\n  public async deleteBlob(blobClient: BlobClient, options?: BlobDeleteOptions): Promise<void>;\n\n  public async deleteBlob(\n    urlOrBlobClient: string | BlobClient,\n    credentialOrOptions:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | BlobDeleteOptions\n      | undefined,\n    options?: BlobDeleteOptions\n  ): Promise<void> {\n    let url: string;\n    let credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;\n\n    if (\n      typeof urlOrBlobClient === \"string\" &&\n      ((isNode && credentialOrOptions instanceof StorageSharedKeyCredential) ||\n        credentialOrOptions instanceof AnonymousCredential ||\n        isTokenCredential(credentialOrOptions))\n    ) {\n      // First overload\n      url = urlOrBlobClient;\n      credential = credentialOrOptions;\n    } else if (urlOrBlobClient instanceof BlobClient) {\n      // Second overload\n      url = urlOrBlobClient.url;\n      credential = urlOrBlobClient.credential;\n      options = credentialOrOptions as BlobDeleteOptions;\n    } else {\n      throw new RangeError(\n        \"Invalid arguments. Either url and credential, or BlobClient need be provided.\"\n      );\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"BatchDeleteRequest-addSubRequest\", options);\n\n    try {\n      this.setBatchType(\"delete\");\n      await this.addSubRequestInternal(\n        {\n          url: url,\n          credential: credential,\n        },\n        async () => {\n          await new BlobClient(url, this.batchRequest.createPipeline(credential)).delete(\n            updatedOptions\n          );\n        }\n      );\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * The setBlobAccessTier operation sets the tier on a blob.\n   * The operation is allowed on block blobs in a blob storage or general purpose v2 account.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * A block blob's tier determines Hot/Cool/Archive storage type.\n   * This operation does not update the blob's ETag.\n   * For detailed information about block blob level tiering\n   * see [hot, cool, and archive access tiers](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers).\n   * The operation will be authenticated and authorized\n   * with specified credential. See [blob batch authorization details](https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param url - The url of the blob resource to delete.\n   * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param tier -\n   * @param options -\n   */\n  public async setBlobAccessTier(\n    url: string,\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    tier: AccessTier,\n    options?: BlobSetTierOptions\n  ): Promise<void>;\n\n  /**\n   * The setBlobAccessTier operation sets the tier on a blob.\n   * The operation is allowed on block blobs in a blob storage or general purpose v2 account.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * A block blob's tier determines Hot/Cool/Archive storage type.\n   * This operation does not update the blob's ETag.\n   * For detailed information about block blob level tiering\n   * see [hot, cool, and archive access tiers](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers).\n   * The operation will be authenticated and authorized\n   * with specified credential. See [blob batch authorization details](https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param blobClient - The BlobClient.\n   * @param tier -\n   * @param options -\n   */\n  public async setBlobAccessTier(\n    blobClient: BlobClient,\n    tier: AccessTier,\n    options?: BlobSetTierOptions\n  ): Promise<void>;\n\n  public async setBlobAccessTier(\n    urlOrBlobClient: string | BlobClient,\n    credentialOrTier:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | AccessTier,\n    tierOrOptions?: AccessTier | BlobSetTierOptions,\n    options?: BlobSetTierOptions\n  ): Promise<void> {\n    let url: string;\n    let credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;\n    let tier: AccessTier;\n\n    if (\n      typeof urlOrBlobClient === \"string\" &&\n      ((isNode && credentialOrTier instanceof StorageSharedKeyCredential) ||\n        credentialOrTier instanceof AnonymousCredential ||\n        isTokenCredential(credentialOrTier))\n    ) {\n      // First overload\n      url = urlOrBlobClient;\n      credential = credentialOrTier as\n        | StorageSharedKeyCredential\n        | AnonymousCredential\n        | TokenCredential;\n      tier = tierOrOptions as AccessTier;\n    } else if (urlOrBlobClient instanceof BlobClient) {\n      // Second overload\n      url = urlOrBlobClient.url;\n      credential = urlOrBlobClient.credential;\n      tier = credentialOrTier as AccessTier;\n      options = tierOrOptions as BlobSetTierOptions;\n    } else {\n      throw new RangeError(\n        \"Invalid arguments. Either url and credential, or BlobClient need be provided.\"\n      );\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"BatchSetTierRequest-addSubRequest\", options);\n\n    try {\n      this.setBatchType(\"setAccessTier\");\n      await this.addSubRequestInternal(\n        {\n          url: url,\n          credential: credential,\n        },\n        async () => {\n          await new BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(\n            tier,\n            updatedOptions\n          );\n        }\n      );\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n\n/**\n * Inner batch request class which is responsible for assembling and serializing sub requests.\n * See https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#request-body for how requests are assembled.\n */\nclass InnerBatchRequest {\n  private operationCount: number;\n  private body: string;\n  private subRequests: Map<number, BatchSubRequest>;\n  private readonly boundary: string;\n  private readonly subRequestPrefix: string;\n  private readonly multipartContentType: string;\n  private readonly batchRequestEnding: string;\n\n  constructor() {\n    this.operationCount = 0;\n    this.body = \"\";\n\n    const tempGuid = generateUuid();\n\n    // batch_{batchid}\n    this.boundary = `batch_${tempGuid}`;\n    // --batch_{batchid}\n    // Content-Type: application/http\n    // Content-Transfer-Encoding: binary\n    this.subRequestPrefix = `--${this.boundary}${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TYPE}: application/http${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;\n    // multipart/mixed; boundary=batch_{batchid}\n    this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;\n    // --batch_{batchid}--\n    this.batchRequestEnding = `--${this.boundary}--`;\n\n    this.subRequests = new Map();\n  }\n\n  /**\n   * Create pipeline to assemble sub requests. The idea here is to use existing\n   * credential and serialization/deserialization components, with additional policies to\n   * filter unnecessary headers, assemble sub requests into request's body\n   * and intercept request from going to wire.\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n  public createPipeline(\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential\n  ): Pipeline {\n    const isAnonymousCreds = credential instanceof AnonymousCredential;\n    const policyFactoryLength = 3 + (isAnonymousCreds ? 0 : 1); // [deserializationPolicy, BatchHeaderFilterPolicyFactory, (Optional)Credential, BatchRequestAssemblePolicyFactory]\n    const factories: RequestPolicyFactory[] = new Array(policyFactoryLength);\n\n    factories[0] = deserializationPolicy(); // Default deserializationPolicy is provided by protocol layer\n    factories[1] = new BatchHeaderFilterPolicyFactory(); // Use batch header filter policy to exclude unnecessary headers\n    if (!isAnonymousCreds) {\n      factories[2] = isTokenCredential(credential)\n        ? attachCredential(\n            bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes),\n            credential\n          )\n        : credential;\n    }\n    factories[policyFactoryLength - 1] = new BatchRequestAssemblePolicyFactory(this); // Use batch assemble policy to assemble request and intercept request from going to wire\n\n    return new Pipeline(factories, {});\n  }\n\n  public appendSubRequestToBody(request: WebResource) {\n    // Start to assemble sub request\n    this.body += [\n      this.subRequestPrefix, // sub request constant prefix\n      `${HeaderConstants.CONTENT_ID}: ${this.operationCount}`, // sub request's content ID\n      \"\", // empty line after sub request's content ID\n      `${request.method.toString()} ${getURLPathAndQuery(\n        request.url\n      )} ${HTTP_VERSION_1_1}${HTTP_LINE_ENDING}`, // sub request start line with method\n    ].join(HTTP_LINE_ENDING);\n\n    for (const header of request.headers.headersArray()) {\n      this.body += `${header.name}: ${header.value}${HTTP_LINE_ENDING}`;\n    }\n\n    this.body += HTTP_LINE_ENDING; // sub request's headers need be ending with an empty line\n    // No body to assemble for current batch request support\n    // End to assemble sub request\n  }\n\n  public preAddSubRequest(subRequest: BatchSubRequest) {\n    if (this.operationCount >= BATCH_MAX_REQUEST) {\n      throw new RangeError(`Cannot exceed ${BATCH_MAX_REQUEST} sub requests in a single batch`);\n    }\n\n    // Fast fail if url for sub request is invalid\n    const path = getURLPath(subRequest.url);\n    if (!path || path === \"\") {\n      throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);\n    }\n  }\n\n  public postAddSubRequest(subRequest: BatchSubRequest) {\n    this.subRequests.set(this.operationCount, subRequest);\n    this.operationCount++;\n  }\n\n  // Return the http request body with assembling the ending line to the sub request body.\n  public getHttpRequestBody(): string {\n    return `${this.body}${this.batchRequestEnding}${HTTP_LINE_ENDING}`;\n  }\n\n  public getMultipartContentType(): string {\n    return this.multipartContentType;\n  }\n\n  public getSubRequests(): Map<number, BatchSubRequest> {\n    return this.subRequests;\n  }\n}\n\nclass BatchRequestAssemblePolicy extends BaseRequestPolicy {\n  private batchRequest: InnerBatchRequest;\n  private readonly dummyResponse: HttpOperationResponse = {\n    request: new WebResource(),\n    status: 200,\n    headers: new HttpHeaders(),\n  };\n\n  constructor(\n    batchRequest: InnerBatchRequest,\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions\n  ) {\n    super(nextPolicy, options);\n\n    this.batchRequest = batchRequest;\n  }\n\n  public async sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    await this.batchRequest.appendSubRequestToBody(request);\n\n    return this.dummyResponse; // Intercept request from going to wire\n  }\n}\n\nclass BatchRequestAssemblePolicyFactory implements RequestPolicyFactory {\n  private batchRequest: InnerBatchRequest;\n\n  constructor(batchRequest: InnerBatchRequest) {\n    this.batchRequest = batchRequest;\n  }\n\n  public create(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions\n  ): BatchRequestAssemblePolicy {\n    return new BatchRequestAssemblePolicy(this.batchRequest, nextPolicy, options);\n  }\n}\n\nclass BatchHeaderFilterPolicy extends BaseRequestPolicy {\n  // The base class has a protected constructor. Adding a public one to enable constructing of this class.\n  /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/\n  constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n    super(nextPolicy, options);\n  }\n\n  public async sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    let xMsHeaderName = \"\";\n\n    for (const header of request.headers.headersArray()) {\n      if (iEqual(header.name, HeaderConstants.X_MS_VERSION)) {\n        xMsHeaderName = header.name;\n      }\n    }\n\n    if (xMsHeaderName !== \"\") {\n      request.headers.remove(xMsHeaderName); // The subrequests should not have the x-ms-version header.\n    }\n\n    return this._nextPolicy.sendRequest(request);\n  }\n}\n\nclass BatchHeaderFilterPolicyFactory implements RequestPolicyFactory {\n  public create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): BatchHeaderFilterPolicy {\n    return new BatchHeaderFilterPolicy(nextPolicy, options);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}