{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { logger } from \"../logger\";\nimport { terminalStates } from \"./constants\";\n/**\n * Deserializes the state\n */\nexport function deserializeState(serializedState) {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(`Unable to deserialize input state: ${serializedState}`);\n  }\n}\nfunction setStateError(inputs) {\n  const {\n    state,\n    stateProxy,\n    isOperationError\n  } = inputs;\n  return error => {\n    if (isOperationError(error)) {\n      stateProxy.setError(state, error);\n      stateProxy.setFailed(state);\n    }\n    throw error;\n  };\n}\nfunction appendReadableErrorMessage(currentMessage, innerMessage) {\n  let message = currentMessage;\n  if (message.slice(-1) !== \".\") {\n    message = message + \".\";\n  }\n  return message + \" \" + innerMessage;\n}\nfunction simplifyError(err) {\n  let message = err.message;\n  let code = err.code;\n  let curErr = err;\n  while (curErr.innererror) {\n    curErr = curErr.innererror;\n    code = curErr.code;\n    message = appendReadableErrorMessage(message, curErr.message);\n  }\n  return {\n    code,\n    message\n  };\n}\nfunction processOperationStatus(result) {\n  const {\n    state,\n    stateProxy,\n    status,\n    isDone,\n    processResult,\n    getError,\n    response,\n    setErrorAsResult\n  } = result;\n  switch (status) {\n    case \"succeeded\":\n      {\n        stateProxy.setSucceeded(state);\n        break;\n      }\n    case \"failed\":\n      {\n        const err = getError === null || getError === void 0 ? void 0 : getError(response);\n        let postfix = \"\";\n        if (err) {\n          const {\n            code,\n            message\n          } = simplifyError(err);\n          postfix = `. ${code}. ${message}`;\n        }\n        const errStr = `The long-running operation has failed${postfix}`;\n        stateProxy.setError(state, new Error(errStr));\n        stateProxy.setFailed(state);\n        logger.warning(errStr);\n        break;\n      }\n    case \"canceled\":\n      {\n        stateProxy.setCanceled(state);\n        break;\n      }\n  }\n  if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) || isDone === undefined && [\"succeeded\", \"canceled\"].concat(setErrorAsResult ? [] : [\"failed\"]).includes(status)) {\n    stateProxy.setResult(state, buildResult({\n      response,\n      state,\n      processResult\n    }));\n  }\n}\nfunction buildResult(inputs) {\n  const {\n    processResult,\n    response,\n    state\n  } = inputs;\n  return processResult ? processResult(response, state) : response;\n}\n/**\n * Initiates the long-running operation.\n */\nexport async function initOperation(inputs) {\n  const {\n    init,\n    stateProxy,\n    processResult,\n    getOperationStatus,\n    withOperationLocation,\n    setErrorAsResult\n  } = inputs;\n  const {\n    operationLocation,\n    resourceLocation,\n    metadata,\n    response\n  } = await init();\n  if (operationLocation) withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n  const config = {\n    metadata,\n    operationLocation,\n    resourceLocation\n  };\n  logger.verbose(`LRO: Operation description:`, config);\n  const state = stateProxy.initState(config);\n  const status = getOperationStatus({\n    response,\n    state,\n    operationLocation\n  });\n  processOperationStatus({\n    state,\n    status,\n    stateProxy,\n    response,\n    setErrorAsResult,\n    processResult\n  });\n  return state;\n}\nasync function pollOperationHelper(inputs) {\n  const {\n    poll,\n    state,\n    stateProxy,\n    operationLocation,\n    getOperationStatus,\n    getResourceLocation,\n    isOperationError,\n    options\n  } = inputs;\n  const response = await poll(operationLocation, options).catch(setStateError({\n    state,\n    stateProxy,\n    isOperationError\n  }));\n  const status = getOperationStatus(response, state);\n  logger.verbose(`LRO: Status:\\n\\tPolling from: ${state.config.operationLocation}\\n\\tOperation status: ${status}\\n\\tPolling status: ${terminalStates.includes(status) ? \"Stopped\" : \"Running\"}`);\n  if (status === \"succeeded\") {\n    const resourceLocation = getResourceLocation(response, state);\n    if (resourceLocation !== undefined) {\n      return {\n        response: await poll(resourceLocation).catch(setStateError({\n          state,\n          stateProxy,\n          isOperationError\n        })),\n        status\n      };\n    }\n  }\n  return {\n    response,\n    status\n  };\n}\n/** Polls the long-running operation. */\nexport async function pollOperation(inputs) {\n  const {\n    poll,\n    state,\n    stateProxy,\n    options,\n    getOperationStatus,\n    getResourceLocation,\n    getOperationLocation,\n    isOperationError,\n    withOperationLocation,\n    getPollingInterval,\n    processResult,\n    getError,\n    updateState,\n    setDelay,\n    isDone,\n    setErrorAsResult\n  } = inputs;\n  const {\n    operationLocation\n  } = state.config;\n  if (operationLocation !== undefined) {\n    const {\n      response,\n      status\n    } = await pollOperationHelper({\n      poll,\n      getOperationStatus,\n      state,\n      stateProxy,\n      operationLocation,\n      getResourceLocation,\n      isOperationError,\n      options\n    });\n    processOperationStatus({\n      status,\n      response,\n      state,\n      stateProxy,\n      isDone,\n      processResult,\n      getError,\n      setErrorAsResult\n    });\n    if (!terminalStates.includes(status)) {\n      const intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);\n      if (intervalInMs) setDelay(intervalInMs);\n      const location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response, state);\n      if (location !== undefined) {\n        const isUpdated = operationLocation !== location;\n        state.config.operationLocation = location;\n        withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(location, isUpdated);\n      } else withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n    }\n    updateState === null || updateState === void 0 ? void 0 : updateState(state, response);\n  }\n}","map":{"version":3,"names":["logger","terminalStates","deserializeState","serializedState","JSON","parse","state","e","Error","setStateError","inputs","stateProxy","isOperationError","error","setError","setFailed","appendReadableErrorMessage","currentMessage","innerMessage","message","slice","simplifyError","err","code","curErr","innererror","processOperationStatus","result","status","isDone","processResult","getError","response","setErrorAsResult","setSucceeded","postfix","errStr","warning","setCanceled","undefined","concat","includes","setResult","buildResult","initOperation","init","getOperationStatus","withOperationLocation","operationLocation","resourceLocation","metadata","config","verbose","initState","pollOperationHelper","poll","getResourceLocation","options","catch","pollOperation","getOperationLocation","getPollingInterval","updateState","setDelay","intervalInMs","location","isUpdated"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\core-lro\\src\\poller\\operation.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  LroError,\n  InnerError,\n  Operation,\n  OperationStatus,\n  RestorableOperationState,\n  StateProxy,\n} from \"./models\";\nimport { logger } from \"../logger\";\nimport { terminalStates } from \"./constants\";\n\n/**\n * Deserializes the state\n */\nexport function deserializeState<TState>(\n  serializedState: string\n): RestorableOperationState<TState> {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(`Unable to deserialize input state: ${serializedState}`);\n  }\n}\n\nfunction setStateError<TState, TResult>(inputs: {\n  state: TState;\n  stateProxy: StateProxy<TState, TResult>;\n  isOperationError: (error: Error) => boolean;\n}): (error: Error) => never {\n  const { state, stateProxy, isOperationError } = inputs;\n  return (error: Error) => {\n    if (isOperationError(error)) {\n      stateProxy.setError(state, error);\n      stateProxy.setFailed(state);\n    }\n    throw error;\n  };\n}\n\nfunction appendReadableErrorMessage(currentMessage: string, innerMessage: string): string {\n  let message = currentMessage;\n  if (message.slice(-1) !== \".\") {\n    message = message + \".\";\n  }\n  return message + \" \" + innerMessage;\n}\n\nfunction simplifyError(err: LroError): {\n  code: string;\n  message: string;\n} {\n  let message = err.message;\n  let code = err.code;\n  let curErr = err as InnerError;\n  while (curErr.innererror) {\n    curErr = curErr.innererror;\n    code = curErr.code;\n    message = appendReadableErrorMessage(message, curErr.message);\n  }\n  return {\n    code,\n    message,\n  };\n}\n\nfunction processOperationStatus<TState, TResult, TResponse>(result: {\n  status: OperationStatus;\n  response: TResponse;\n  state: RestorableOperationState<TState>;\n  stateProxy: StateProxy<TState, TResult>;\n  processResult?: (result: TResponse, state: TState) => TResult;\n  getError?: (response: TResponse) => LroError | undefined;\n  isDone?: (lastResponse: TResponse, state: TState) => boolean;\n  setErrorAsResult: boolean;\n}): void {\n  const { state, stateProxy, status, isDone, processResult, getError, response, setErrorAsResult } =\n    result;\n  switch (status) {\n    case \"succeeded\": {\n      stateProxy.setSucceeded(state);\n      break;\n    }\n    case \"failed\": {\n      const err = getError?.(response);\n      let postfix = \"\";\n      if (err) {\n        const { code, message } = simplifyError(err);\n        postfix = `. ${code}. ${message}`;\n      }\n      const errStr = `The long-running operation has failed${postfix}`;\n      stateProxy.setError(state, new Error(errStr));\n      stateProxy.setFailed(state);\n      logger.warning(errStr);\n      break;\n    }\n    case \"canceled\": {\n      stateProxy.setCanceled(state);\n      break;\n    }\n  }\n  if (\n    isDone?.(response, state) ||\n    (isDone === undefined &&\n      [\"succeeded\", \"canceled\"].concat(setErrorAsResult ? [] : [\"failed\"]).includes(status))\n  ) {\n    stateProxy.setResult(\n      state,\n      buildResult({\n        response,\n        state,\n        processResult,\n      })\n    );\n  }\n}\n\nfunction buildResult<TResponse, TResult, TState>(inputs: {\n  response: TResponse;\n  state: TState;\n  processResult?: (result: TResponse, state: TState) => TResult;\n}): TResult {\n  const { processResult, response, state } = inputs;\n  return processResult ? processResult(response, state) : (response as unknown as TResult);\n}\n\n/**\n * Initiates the long-running operation.\n */\nexport async function initOperation<TResponse, TResult, TState>(inputs: {\n  init: Operation<TResponse, unknown>[\"init\"];\n  stateProxy: StateProxy<TState, TResult>;\n  getOperationStatus: (inputs: {\n    response: TResponse;\n    state: RestorableOperationState<TState>;\n    operationLocation?: string;\n  }) => OperationStatus;\n  processResult?: (result: TResponse, state: TState) => TResult;\n  withOperationLocation?: (operationLocation: string, isUpdated: boolean) => void;\n  setErrorAsResult: boolean;\n}): Promise<RestorableOperationState<TState>> {\n  const {\n    init,\n    stateProxy,\n    processResult,\n    getOperationStatus,\n    withOperationLocation,\n    setErrorAsResult,\n  } = inputs;\n  const { operationLocation, resourceLocation, metadata, response } = await init();\n  if (operationLocation) withOperationLocation?.(operationLocation, false);\n  const config = {\n    metadata,\n    operationLocation,\n    resourceLocation,\n  };\n  logger.verbose(`LRO: Operation description:`, config);\n  const state = stateProxy.initState(config);\n  const status = getOperationStatus({ response, state, operationLocation });\n  processOperationStatus({ state, status, stateProxy, response, setErrorAsResult, processResult });\n  return state;\n}\n\nasync function pollOperationHelper<TResponse, TState, TResult, TOptions>(inputs: {\n  poll: Operation<TResponse, TOptions>[\"poll\"];\n  stateProxy: StateProxy<TState, TResult>;\n  state: RestorableOperationState<TState>;\n  operationLocation: string;\n  getOperationStatus: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => OperationStatus;\n  getResourceLocation: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => string | undefined;\n  isOperationError: (error: Error) => boolean;\n  options?: TOptions;\n}): Promise<{\n  status: OperationStatus;\n  response: TResponse;\n}> {\n  const {\n    poll,\n    state,\n    stateProxy,\n    operationLocation,\n    getOperationStatus,\n    getResourceLocation,\n    isOperationError,\n    options,\n  } = inputs;\n  const response = await poll(operationLocation, options).catch(\n    setStateError({\n      state,\n      stateProxy,\n      isOperationError,\n    })\n  );\n  const status = getOperationStatus(response, state);\n  logger.verbose(\n    `LRO: Status:\\n\\tPolling from: ${\n      state.config.operationLocation\n    }\\n\\tOperation status: ${status}\\n\\tPolling status: ${\n      terminalStates.includes(status) ? \"Stopped\" : \"Running\"\n    }`\n  );\n  if (status === \"succeeded\") {\n    const resourceLocation = getResourceLocation(response, state);\n    if (resourceLocation !== undefined) {\n      return {\n        response: await poll(resourceLocation).catch(\n          setStateError({ state, stateProxy, isOperationError })\n        ),\n        status,\n      };\n    }\n  }\n  return { response, status };\n}\n\n/** Polls the long-running operation. */\nexport async function pollOperation<TResponse, TState, TResult, TOptions>(inputs: {\n  poll: Operation<TResponse, TOptions>[\"poll\"];\n  stateProxy: StateProxy<TState, TResult>;\n  state: RestorableOperationState<TState>;\n  getOperationStatus: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => OperationStatus;\n  getResourceLocation: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => string | undefined;\n  isOperationError: (error: Error) => boolean;\n  getPollingInterval?: (response: TResponse) => number | undefined;\n  setDelay: (intervalInMs: number) => void;\n  getOperationLocation?: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => string | undefined;\n  withOperationLocation?: (operationLocation: string, isUpdated: boolean) => void;\n  processResult?: (result: TResponse, state: TState) => TResult;\n  getError?: (response: TResponse) => LroError | undefined;\n  updateState?: (state: TState, lastResponse: TResponse) => void;\n  isDone?: (lastResponse: TResponse, state: TState) => boolean;\n  setErrorAsResult: boolean;\n  options?: TOptions;\n}): Promise<void> {\n  const {\n    poll,\n    state,\n    stateProxy,\n    options,\n    getOperationStatus,\n    getResourceLocation,\n    getOperationLocation,\n    isOperationError,\n    withOperationLocation,\n    getPollingInterval,\n    processResult,\n    getError,\n    updateState,\n    setDelay,\n    isDone,\n    setErrorAsResult,\n  } = inputs;\n  const { operationLocation } = state.config;\n  if (operationLocation !== undefined) {\n    const { response, status } = await pollOperationHelper({\n      poll,\n      getOperationStatus,\n      state,\n      stateProxy,\n      operationLocation,\n      getResourceLocation,\n      isOperationError,\n      options,\n    });\n    processOperationStatus({\n      status,\n      response,\n      state,\n      stateProxy,\n      isDone,\n      processResult,\n      getError,\n      setErrorAsResult,\n    });\n\n    if (!terminalStates.includes(status)) {\n      const intervalInMs = getPollingInterval?.(response);\n      if (intervalInMs) setDelay(intervalInMs);\n      const location = getOperationLocation?.(response, state);\n      if (location !== undefined) {\n        const isUpdated = operationLocation !== location;\n        state.config.operationLocation = location;\n        withOperationLocation?.(location, isUpdated);\n      } else withOperationLocation?.(operationLocation, false);\n    }\n    updateState?.(state, response);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}