{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { SpanKind, SpanStatusCode, createSpanFunction, getTraceParentHeader, isSpanContextValid } from \"@azure/core-tracing\";\nimport { logger } from \"../log\";\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\"\n});\n/**\n * Creates a policy that wraps outgoing requests with a tracing span.\n * @param tracingOptions - Tracing options.\n * @returns An instance of the {@link TracingPolicy} class.\n */\nexport function tracingPolicy() {\n  let tracingOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    create(nextPolicy, options) {\n      return new TracingPolicy(nextPolicy, options, tracingOptions);\n    }\n  };\n}\n/**\n * A policy that wraps outgoing requests with a tracing span.\n */\nexport class TracingPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, options, tracingOptions) {\n    super(nextPolicy, options);\n    this.userAgent = tracingOptions.userAgent;\n  }\n  async sendRequest(request) {\n    if (!request.tracingContext) {\n      return this._nextPolicy.sendRequest(request);\n    }\n    const span = this.tryCreateSpan(request);\n    if (!span) {\n      return this._nextPolicy.sendRequest(request);\n    }\n    try {\n      const response = await this._nextPolicy.sendRequest(request);\n      this.tryProcessResponse(span, response);\n      return response;\n    } catch (err) {\n      this.tryProcessError(span, err);\n      throw err;\n    }\n  }\n  tryCreateSpan(request) {\n    var _a;\n    try {\n      // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n      // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n      const {\n        span\n      } = createSpan(`HTTP ${request.method}`, {\n        tracingOptions: {\n          spanOptions: Object.assign(Object.assign({}, request.spanOptions), {\n            kind: SpanKind.CLIENT\n          }),\n          tracingContext: request.tracingContext\n        }\n      });\n      // If the span is not recording, don't do any more work.\n      if (!span.isRecording()) {\n        span.end();\n        return undefined;\n      }\n      const namespaceFromContext = (_a = request.tracingContext) === null || _a === void 0 ? void 0 : _a.getValue(Symbol.for(\"az.namespace\"));\n      if (typeof namespaceFromContext === \"string\") {\n        span.setAttribute(\"az.namespace\", namespaceFromContext);\n      }\n      span.setAttributes({\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId\n      });\n      if (this.userAgent) {\n        span.setAttribute(\"http.user_agent\", this.userAgent);\n      }\n      // set headers\n      const spanContext = span.spanContext();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n      if (traceParentHeader && isSpanContextValid(spanContext)) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize();\n        // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n      return span;\n    } catch (error) {\n      logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n      return undefined;\n    }\n  }\n  tryProcessError(span, err) {\n    try {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message\n      });\n      if (err.statusCode) {\n        span.setAttribute(\"http.status_code\", err.statusCode);\n      }\n      span.end();\n    } catch (error) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n  tryProcessResponse(span, response) {\n    try {\n      span.setAttribute(\"http.status_code\", response.status);\n      const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n      if (serviceRequestId) {\n        span.setAttribute(\"serviceRequestId\", serviceRequestId);\n      }\n      span.setStatus({\n        code: SpanStatusCode.OK\n      });\n      span.end();\n    } catch (error) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n}","map":{"version":3,"names":["BaseRequestPolicy","SpanKind","SpanStatusCode","createSpanFunction","getTraceParentHeader","isSpanContextValid","logger","createSpan","packagePrefix","namespace","tracingPolicy","tracingOptions","arguments","length","undefined","create","nextPolicy","options","TracingPolicy","constructor","userAgent","sendRequest","request","tracingContext","_nextPolicy","span","tryCreateSpan","response","tryProcessResponse","err","tryProcessError","method","spanOptions","Object","assign","kind","CLIENT","isRecording","end","namespaceFromContext","_a","getValue","Symbol","for","setAttribute","setAttributes","url","requestId","spanContext","traceParentHeader","headers","set","traceState","serialize","error","warning","message","setStatus","code","ERROR","statusCode","status","serviceRequestId","get","OK"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\core-http\\src\\policies\\tracingPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./requestPolicy\";\nimport {\n  Span,\n  SpanKind,\n  SpanStatusCode,\n  createSpanFunction,\n  getTraceParentHeader,\n  isSpanContextValid,\n} from \"@azure/core-tracing\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResourceLike } from \"../webResource\";\nimport { logger } from \"../log\";\n\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\",\n});\n\n/**\n * Options to customize the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * User agent used to better identify the outgoing requests traced by the tracing policy.\n   */\n  userAgent?: string;\n}\n\n/**\n * Creates a policy that wraps outgoing requests with a tracing span.\n * @param tracingOptions - Tracing options.\n * @returns An instance of the {@link TracingPolicy} class.\n */\nexport function tracingPolicy(tracingOptions: TracingPolicyOptions = {}): RequestPolicyFactory {\n  return {\n    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n      return new TracingPolicy(nextPolicy, options, tracingOptions);\n    },\n  };\n}\n\n/**\n * A policy that wraps outgoing requests with a tracing span.\n */\nexport class TracingPolicy extends BaseRequestPolicy {\n  private userAgent?: string;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    tracingOptions: TracingPolicyOptions\n  ) {\n    super(nextPolicy, options);\n    this.userAgent = tracingOptions.userAgent;\n  }\n\n  public async sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!request.tracingContext) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    const span = this.tryCreateSpan(request);\n\n    if (!span) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    try {\n      const response = await this._nextPolicy.sendRequest(request);\n      this.tryProcessResponse(span, response);\n      return response;\n    } catch (err: any) {\n      this.tryProcessError(span, err);\n      throw err;\n    }\n  }\n\n  tryCreateSpan(request: WebResourceLike): Span | undefined {\n    try {\n      // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n      // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n      const { span } = createSpan(`HTTP ${request.method}`, {\n        tracingOptions: {\n          spanOptions: {\n            ...(request as any).spanOptions,\n            kind: SpanKind.CLIENT,\n          },\n          tracingContext: request.tracingContext,\n        },\n      });\n\n      // If the span is not recording, don't do any more work.\n      if (!span.isRecording()) {\n        span.end();\n        return undefined;\n      }\n\n      const namespaceFromContext = request.tracingContext?.getValue(Symbol.for(\"az.namespace\"));\n\n      if (typeof namespaceFromContext === \"string\") {\n        span.setAttribute(\"az.namespace\", namespaceFromContext);\n      }\n\n      span.setAttributes({\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId,\n      });\n\n      if (this.userAgent) {\n        span.setAttribute(\"http.user_agent\", this.userAgent);\n      }\n\n      // set headers\n      const spanContext = span.spanContext();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n      if (traceParentHeader && isSpanContextValid(spanContext)) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize();\n        // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n      return span;\n    } catch (error: any) {\n      logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n      return undefined;\n    }\n  }\n\n  private tryProcessError(span: Span, err: any): void {\n    try {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message,\n      });\n\n      if (err.statusCode) {\n        span.setAttribute(\"http.status_code\", err.statusCode);\n      }\n      span.end();\n    } catch (error: any) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n\n  private tryProcessResponse(span: Span, response: HttpOperationResponse): void {\n    try {\n      span.setAttribute(\"http.status_code\", response.status);\n      const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n      if (serviceRequestId) {\n        span.setAttribute(\"serviceRequestId\", serviceRequestId);\n      }\n      span.setStatus({\n        code: SpanStatusCode.OK,\n      });\n      span.end();\n    } catch (error: any) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AAEA,SACEA,iBAAiB,QAIZ,iBAAiB;AACxB,SAEEC,QAAQ,EACRC,cAAc,EACdC,kBAAkB,EAClBC,oBAAoB,EACpBC,kBAAkB,QACb,qBAAqB;AAG5B,SAASC,MAAM,QAAQ,QAAQ;AAE/B,MAAMC,UAAU,GAAGJ,kBAAkB,CAAC;EACpCK,aAAa,EAAE,EAAE;EACjBC,SAAS,EAAE;CACZ,CAAC;AAYF;;;;;AAKA,OAAM,SAAUC,aAAaA,CAAA,EAA0C;EAAA,IAAzCC,cAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAuC,EAAE;EACrE,OAAO;IACLG,MAAMA,CAACC,UAAyB,EAAEC,OAA6B;MAC7D,OAAO,IAAIC,aAAa,CAACF,UAAU,EAAEC,OAAO,EAAEN,cAAc,CAAC;IAC/D;GACD;AACH;AAEA;;;AAGA,OAAM,MAAOO,aAAc,SAAQlB,iBAAiB;EAGlDmB,YACEH,UAAyB,EACzBC,OAA6B,EAC7BN,cAAoC;IAEpC,KAAK,CAACK,UAAU,EAAEC,OAAO,CAAC;IAC1B,IAAI,CAACG,SAAS,GAAGT,cAAc,CAACS,SAAS;EAC3C;EAEO,MAAMC,WAAWA,CAACC,OAAwB;IAC/C,IAAI,CAACA,OAAO,CAACC,cAAc,EAAE;MAC3B,OAAO,IAAI,CAACC,WAAW,CAACH,WAAW,CAACC,OAAO,CAAC;;IAG9C,MAAMG,IAAI,GAAG,IAAI,CAACC,aAAa,CAACJ,OAAO,CAAC;IAExC,IAAI,CAACG,IAAI,EAAE;MACT,OAAO,IAAI,CAACD,WAAW,CAACH,WAAW,CAACC,OAAO,CAAC;;IAG9C,IAAI;MACF,MAAMK,QAAQ,GAAG,MAAM,IAAI,CAACH,WAAW,CAACH,WAAW,CAACC,OAAO,CAAC;MAC5D,IAAI,CAACM,kBAAkB,CAACH,IAAI,EAAEE,QAAQ,CAAC;MACvC,OAAOA,QAAQ;KAChB,CAAC,OAAOE,GAAQ,EAAE;MACjB,IAAI,CAACC,eAAe,CAACL,IAAI,EAAEI,GAAG,CAAC;MAC/B,MAAMA,GAAG;;EAEb;EAEAH,aAAaA,CAACJ,OAAwB;;IACpC,IAAI;MACF;MACA;MACA,MAAM;QAAEG;MAAI,CAAE,GAAGlB,UAAU,CAAC,QAAQe,OAAO,CAACS,MAAM,EAAE,EAAE;QACpDpB,cAAc,EAAE;UACdqB,WAAW,EAAAC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACLZ,OAAe,CAACU,WAAW;YAC/BG,IAAI,EAAElC,QAAQ,CAACmC;UAAM,EACtB;UACDb,cAAc,EAAED,OAAO,CAACC;;OAE3B,CAAC;MAEF;MACA,IAAI,CAACE,IAAI,CAACY,WAAW,EAAE,EAAE;QACvBZ,IAAI,CAACa,GAAG,EAAE;QACV,OAAOxB,SAAS;;MAGlB,MAAMyB,oBAAoB,GAAG,CAAAC,EAAA,GAAAlB,OAAO,CAACC,cAAc,cAAAiB,EAAA,uBAAAA,EAAA,CAAEC,QAAQ,CAACC,MAAM,CAACC,GAAG,CAAC,cAAc,CAAC,CAAC;MAEzF,IAAI,OAAOJ,oBAAoB,KAAK,QAAQ,EAAE;QAC5Cd,IAAI,CAACmB,YAAY,CAAC,cAAc,EAAEL,oBAAoB,CAAC;;MAGzDd,IAAI,CAACoB,aAAa,CAAC;QACjB,aAAa,EAAEvB,OAAO,CAACS,MAAM;QAC7B,UAAU,EAAET,OAAO,CAACwB,GAAG;QACvBC,SAAS,EAAEzB,OAAO,CAACyB;OACpB,CAAC;MAEF,IAAI,IAAI,CAAC3B,SAAS,EAAE;QAClBK,IAAI,CAACmB,YAAY,CAAC,iBAAiB,EAAE,IAAI,CAACxB,SAAS,CAAC;;MAGtD;MACA,MAAM4B,WAAW,GAAGvB,IAAI,CAACuB,WAAW,EAAE;MACtC,MAAMC,iBAAiB,GAAG7C,oBAAoB,CAAC4C,WAAW,CAAC;MAC3D,IAAIC,iBAAiB,IAAI5C,kBAAkB,CAAC2C,WAAW,CAAC,EAAE;QACxD1B,OAAO,CAAC4B,OAAO,CAACC,GAAG,CAAC,aAAa,EAAEF,iBAAiB,CAAC;QACrD,MAAMG,UAAU,GAAGJ,WAAW,CAACI,UAAU,IAAIJ,WAAW,CAACI,UAAU,CAACC,SAAS,EAAE;QAC/E;QACA,IAAID,UAAU,EAAE;UACd9B,OAAO,CAAC4B,OAAO,CAACC,GAAG,CAAC,YAAY,EAAEC,UAAU,CAAC;;;MAGjD,OAAO3B,IAAI;KACZ,CAAC,OAAO6B,KAAU,EAAE;MACnBhD,MAAM,CAACiD,OAAO,CAAC,qDAAqDD,KAAK,CAACE,OAAO,EAAE,CAAC;MACpF,OAAO1C,SAAS;;EAEpB;EAEQgB,eAAeA,CAACL,IAAU,EAAEI,GAAQ;IAC1C,IAAI;MACFJ,IAAI,CAACgC,SAAS,CAAC;QACbC,IAAI,EAAExD,cAAc,CAACyD,KAAK;QAC1BH,OAAO,EAAE3B,GAAG,CAAC2B;OACd,CAAC;MAEF,IAAI3B,GAAG,CAAC+B,UAAU,EAAE;QAClBnC,IAAI,CAACmB,YAAY,CAAC,kBAAkB,EAAEf,GAAG,CAAC+B,UAAU,CAAC;;MAEvDnC,IAAI,CAACa,GAAG,EAAE;KACX,CAAC,OAAOgB,KAAU,EAAE;MACnBhD,MAAM,CAACiD,OAAO,CAAC,qDAAqDD,KAAK,CAACE,OAAO,EAAE,CAAC;;EAExF;EAEQ5B,kBAAkBA,CAACH,IAAU,EAAEE,QAA+B;IACpE,IAAI;MACFF,IAAI,CAACmB,YAAY,CAAC,kBAAkB,EAAEjB,QAAQ,CAACkC,MAAM,CAAC;MACtD,MAAMC,gBAAgB,GAAGnC,QAAQ,CAACuB,OAAO,CAACa,GAAG,CAAC,iBAAiB,CAAC;MAChE,IAAID,gBAAgB,EAAE;QACpBrC,IAAI,CAACmB,YAAY,CAAC,kBAAkB,EAAEkB,gBAAgB,CAAC;;MAEzDrC,IAAI,CAACgC,SAAS,CAAC;QACbC,IAAI,EAAExD,cAAc,CAAC8D;OACtB,CAAC;MACFvC,IAAI,CAACa,GAAG,EAAE;KACX,CAAC,OAAOgB,KAAU,EAAE;MACnBhD,MAAM,CAACiD,OAAO,CAAC,qDAAqDD,KAAK,CAACE,OAAO,EAAE,CAAC;;EAExF"},"metadata":{},"sourceType":"module","externalDependencies":[]}