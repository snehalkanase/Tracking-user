{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, isNumber, shouldRetry, updateRetryData } from \"../util/exponentialBackoffStrategy\";\nimport { Constants } from \"../util/constants\";\nimport { RestError } from \"../restError\";\nimport { delay } from \"@azure/core-util\";\nimport { logger } from \"../log\";\n/**\n * Policy that retries the request as many times as configured for as long as the max retry time interval specified, each retry waiting longer to begin than the last time.\n * @param retryCount - Maximum number of retries.\n * @param retryInterval - Base time between retries.\n * @param maxRetryInterval - Maximum time to wait between retries.\n */\nexport function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {\n  return {\n    create: (nextPolicy, options) => {\n      return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);\n    }\n  };\n}\n/**\n * Describes the Retry Mode type. Currently supporting only Exponential.\n */\nexport var RetryMode;\n(function (RetryMode) {\n  /**\n   * Currently supported retry mode.\n   * Each time a retry happens, it will take exponentially more time than the last time.\n   */\n  RetryMode[RetryMode[\"Exponential\"] = 0] = \"Exponential\";\n})(RetryMode || (RetryMode = {}));\nexport const DefaultRetryOptions = {\n  maxRetries: DEFAULT_CLIENT_RETRY_COUNT,\n  retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,\n  maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL\n};\n/**\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\nexport class ExponentialRetryPolicy extends BaseRequestPolicy {\n  /**\n   * @param nextPolicy - The next RequestPolicy in the pipeline chain.\n   * @param options - The options for this RequestPolicy.\n   * @param retryCount - The client retry count.\n   * @param retryInterval - The client retry interval, in milliseconds.\n   * @param minRetryInterval - The minimum retry interval, in milliseconds.\n   * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n   */\n  constructor(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {\n    super(nextPolicy, options);\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n  sendRequest(request) {\n    return this._nextPolicy.sendRequest(request.clone()).then(response => retry(this, request, response)).catch(error => retry(this, request, error.response, undefined, error));\n  }\n}\nasync function retry(policy, request, response, retryData, requestError) {\n  function shouldPolicyRetry(responseParam) {\n    const statusCode = responseParam === null || responseParam === void 0 ? void 0 : responseParam.status;\n    if (statusCode === 503 && (response === null || response === void 0 ? void 0 : response.headers.get(Constants.HeaderConstants.RETRY_AFTER))) {\n      return false;\n    }\n    if (statusCode === undefined || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505) {\n      return false;\n    }\n    return true;\n  }\n  retryData = updateRetryData({\n    retryInterval: policy.retryInterval,\n    minRetryInterval: 0,\n    maxRetryInterval: policy.maxRetryInterval\n  }, retryData, requestError);\n  const isAborted = request.abortSignal && request.abortSignal.aborted;\n  if (!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)) {\n    logger.info(`Retrying request in ${retryData.retryInterval}`);\n    try {\n      await delay(retryData.retryInterval);\n      const res = await policy._nextPolicy.sendRequest(request.clone());\n      return retry(policy, request, res, retryData);\n    } catch (err) {\n      return retry(policy, request, response, retryData, err);\n    }\n  } else if (isAborted || requestError || !response) {\n    // If the operation failed in the end, return all errors instead of just the last one\n    const err = retryData.error || new RestError(\"Failed to send the request.\", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);\n    throw err;\n  } else {\n    return response;\n  }\n}","map":{"version":3,"names":["BaseRequestPolicy","DEFAULT_CLIENT_MAX_RETRY_INTERVAL","DEFAULT_CLIENT_RETRY_COUNT","DEFAULT_CLIENT_RETRY_INTERVAL","isNumber","shouldRetry","updateRetryData","Constants","RestError","delay","logger","exponentialRetryPolicy","retryCount","retryInterval","maxRetryInterval","create","nextPolicy","options","ExponentialRetryPolicy","RetryMode","DefaultRetryOptions","maxRetries","retryDelayInMs","maxRetryDelayInMs","constructor","sendRequest","request","_nextPolicy","clone","then","response","retry","catch","error","undefined","policy","retryData","requestError","shouldPolicyRetry","responseParam","statusCode","status","headers","get","HeaderConstants","RETRY_AFTER","minRetryInterval","isAborted","abortSignal","aborted","info","res","err","REQUEST_SEND_ERROR"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\core-http\\src\\policies\\exponentialRetryPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./requestPolicy\";\nimport {\n  DEFAULT_CLIENT_MAX_RETRY_INTERVAL,\n  DEFAULT_CLIENT_RETRY_COUNT,\n  DEFAULT_CLIENT_RETRY_INTERVAL,\n  RetryData,\n  RetryError,\n  isNumber,\n  shouldRetry,\n  updateRetryData,\n} from \"../util/exponentialBackoffStrategy\";\nimport { Constants } from \"../util/constants\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { RestError } from \"../restError\";\nimport { WebResourceLike } from \"../webResource\";\nimport { delay } from \"@azure/core-util\";\nimport { logger } from \"../log\";\n\n/**\n * Policy that retries the request as many times as configured for as long as the max retry time interval specified, each retry waiting longer to begin than the last time.\n * @param retryCount - Maximum number of retries.\n * @param retryInterval - Base time between retries.\n * @param maxRetryInterval - Maximum time to wait between retries.\n */\nexport function exponentialRetryPolicy(\n  retryCount?: number,\n  retryInterval?: number,\n  maxRetryInterval?: number\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ExponentialRetryPolicy(\n        nextPolicy,\n        options,\n        retryCount,\n        retryInterval,\n        maxRetryInterval\n      );\n    },\n  };\n}\n\n/**\n * Describes the Retry Mode type. Currently supporting only Exponential.\n */\nexport enum RetryMode {\n  /**\n   * Currently supported retry mode.\n   * Each time a retry happens, it will take exponentially more time than the last time.\n   */\n  Exponential,\n}\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface RetryOptions {\n  /**\n   * The maximum number of retry attempts.  Defaults to 3.\n   */\n  maxRetries?: number;\n\n  /**\n   * The amount of delay in milliseconds between retry attempts. Defaults to 30000\n   * (30 seconds). The delay increases exponentially with each retry up to a maximum\n   * specified by maxRetryDelayInMs.\n   */\n  retryDelayInMs?: number;\n\n  /**\n   * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n   * to 90000 (90 seconds).\n   */\n  maxRetryDelayInMs?: number;\n\n  /**\n   * Currently supporting only Exponential mode.\n   */\n  mode?: RetryMode;\n}\n\nexport const DefaultRetryOptions: RetryOptions = {\n  maxRetries: DEFAULT_CLIENT_RETRY_COUNT,\n  retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,\n  maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL,\n};\n\n/**\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\nexport class ExponentialRetryPolicy extends BaseRequestPolicy {\n  /**\n   * The client retry count.\n   */\n  retryCount: number;\n  /**\n   * The client retry interval in milliseconds.\n   */\n  retryInterval: number;\n  /**\n   * The maximum retry interval in milliseconds.\n   */\n  maxRetryInterval: number;\n\n  /**\n   * @param nextPolicy - The next RequestPolicy in the pipeline chain.\n   * @param options - The options for this RequestPolicy.\n   * @param retryCount - The client retry count.\n   * @param retryInterval - The client retry interval, in milliseconds.\n   * @param minRetryInterval - The minimum retry interval, in milliseconds.\n   * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    retryCount?: number,\n    retryInterval?: number,\n    maxRetryInterval?: number\n  ) {\n    super(nextPolicy, options);\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval)\n      ? maxRetryInterval\n      : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  public sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request.clone())\n      .then((response) => retry(this, request, response))\n      .catch((error) => retry(this, request, error.response, undefined, error));\n  }\n}\n\nasync function retry(\n  policy: ExponentialRetryPolicy,\n  request: WebResourceLike,\n  response?: HttpOperationResponse,\n  retryData?: RetryData,\n  requestError?: RetryError\n): Promise<HttpOperationResponse> {\n  function shouldPolicyRetry(responseParam?: HttpOperationResponse): boolean {\n    const statusCode = responseParam?.status;\n    if (statusCode === 503 && response?.headers.get(Constants.HeaderConstants.RETRY_AFTER)) {\n      return false;\n    }\n\n    if (\n      statusCode === undefined ||\n      (statusCode < 500 && statusCode !== 408) ||\n      statusCode === 501 ||\n      statusCode === 505\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  retryData = updateRetryData(\n    {\n      retryInterval: policy.retryInterval,\n      minRetryInterval: 0,\n      maxRetryInterval: policy.maxRetryInterval,\n    },\n    retryData,\n    requestError\n  );\n\n  const isAborted: boolean | undefined = request.abortSignal && request.abortSignal.aborted;\n  if (!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)) {\n    logger.info(`Retrying request in ${retryData.retryInterval}`);\n    try {\n      await delay(retryData.retryInterval);\n      const res = await policy._nextPolicy.sendRequest(request.clone());\n      return retry(policy, request, res, retryData);\n    } catch (err: any) {\n      return retry(policy, request, response, retryData, err);\n    }\n  } else if (isAborted || requestError || !response) {\n    // If the operation failed in the end, return all errors instead of just the last one\n    const err =\n      retryData.error ||\n      new RestError(\n        \"Failed to send the request.\",\n        RestError.REQUEST_SEND_ERROR,\n        response && response.status,\n        response && response.request,\n        response\n      );\n    throw err;\n  } else {\n    return response;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}