{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy, deserializationPolicy, disableResponseDecompressionPolicy, HttpHeaders, RequestPolicyOptions, WebResource, proxyPolicy, isNode, isTokenCredential, tracingPolicy, logPolicy, keepAlivePolicy, generateClientRequestIdPolicy } from \"@azure/core-http\";\nimport { logger } from \"./log\";\nimport { StorageBrowserPolicyFactory } from \"./StorageBrowserPolicyFactory\";\nimport { StorageRetryPolicyFactory } from \"./StorageRetryPolicyFactory\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageOAuthScopes, StorageBlobLoggingAllowedHeaderNames, StorageBlobLoggingAllowedQueryParameters } from \"./utils/constants\";\nimport { TelemetryPolicyFactory } from \"./TelemetryPolicyFactory\";\nimport { getCachedDefaultHttpClient } from \"./utils/cache\";\nimport { attachCredential } from \"./utils/utils.common\";\nimport { storageBearerTokenChallengeAuthenticationPolicy } from \"./policies/StorageBearerTokenChallengeAuthenticationPolicy\";\n// Export following interfaces and types for customers who want to implement their\n// own RequestPolicy or HTTPClient\nexport { BaseRequestPolicy, StorageOAuthScopes, deserializationPolicy, HttpHeaders, WebResource, RequestPolicyOptions };\n/**\n * A helper to decide if a given argument satisfies the Pipeline contract\n * @param pipeline - An argument that may be a Pipeline\n * @returns true when the argument satisfies the Pipeline contract\n */\nexport function isPipelineLike(pipeline) {\n  if (!pipeline || typeof pipeline !== \"object\") {\n    return false;\n  }\n  const castPipeline = pipeline;\n  return Array.isArray(castPipeline.factories) && typeof castPipeline.options === \"object\" && typeof castPipeline.toServiceClientOptions === \"function\";\n}\n/**\n * A Pipeline class containing HTTP request policies.\n * You can create a default Pipeline by calling {@link newPipeline}.\n * Or you can create a Pipeline with your own policies by the constructor of Pipeline.\n *\n * Refer to {@link newPipeline} and provided policies before implementing your\n * customized Pipeline.\n */\nexport class Pipeline {\n  /**\n   * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.\n   *\n   * @param factories -\n   * @param options -\n   */\n  constructor(factories) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.factories = factories;\n    // when options.httpClient is not specified, passing in a DefaultHttpClient instance to\n    // avoid each client creating its own http client.\n    this.options = Object.assign(Object.assign({}, options), {\n      httpClient: options.httpClient || getCachedDefaultHttpClient()\n    });\n  }\n  /**\n   * Transfer Pipeline object to ServiceClientOptions object which is required by\n   * ServiceClient constructor.\n   *\n   * @returns The ServiceClientOptions object from this Pipeline.\n   */\n  toServiceClientOptions() {\n    return {\n      httpClient: this.options.httpClient,\n      requestPolicyFactories: this.factories\n    };\n  }\n}\n/**\n * Creates a new Pipeline object with Credential provided.\n *\n * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n * @param pipelineOptions - Optional. Options.\n * @returns A new Pipeline object.\n */\nexport function newPipeline(credential) {\n  let pipelineOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a;\n  if (credential === undefined) {\n    credential = new AnonymousCredential();\n  }\n  // Order is important. Closer to the API at the top & closer to the network at the bottom.\n  // The credential's policy factory must appear close to the wire so it can sign any\n  // changes made by other factories (like UniqueRequestIDPolicyFactory)\n  const telemetryPolicy = new TelemetryPolicyFactory(pipelineOptions.userAgentOptions);\n  const factories = [tracingPolicy({\n    userAgent: telemetryPolicy.telemetryString\n  }), keepAlivePolicy(pipelineOptions.keepAliveOptions), telemetryPolicy, generateClientRequestIdPolicy(), new StorageBrowserPolicyFactory(), new StorageRetryPolicyFactory(pipelineOptions.retryOptions),\n  // Default deserializationPolicy is provided by protocol layer\n  // Use customized XML char key of \"#\" so we could deserialize metadata\n  // with \"_\" key\n  deserializationPolicy(undefined, {\n    xmlCharKey: \"#\"\n  }), logPolicy({\n    logger: logger.info,\n    allowedHeaderNames: StorageBlobLoggingAllowedHeaderNames,\n    allowedQueryParameters: StorageBlobLoggingAllowedQueryParameters\n  })];\n  if (isNode) {\n    // policies only available in Node.js runtime, not in browsers\n    factories.push(proxyPolicy(pipelineOptions.proxyOptions));\n    factories.push(disableResponseDecompressionPolicy());\n  }\n  factories.push(isTokenCredential(credential) ? attachCredential(storageBearerTokenChallengeAuthenticationPolicy(credential, (_a = pipelineOptions.audience) !== null && _a !== void 0 ? _a : StorageOAuthScopes), credential) : credential);\n  return new Pipeline(factories, pipelineOptions);\n}","map":{"version":3,"names":["BaseRequestPolicy","deserializationPolicy","disableResponseDecompressionPolicy","HttpHeaders","RequestPolicyOptions","WebResource","proxyPolicy","isNode","isTokenCredential","tracingPolicy","logPolicy","keepAlivePolicy","generateClientRequestIdPolicy","logger","StorageBrowserPolicyFactory","StorageRetryPolicyFactory","AnonymousCredential","StorageOAuthScopes","StorageBlobLoggingAllowedHeaderNames","StorageBlobLoggingAllowedQueryParameters","TelemetryPolicyFactory","getCachedDefaultHttpClient","attachCredential","storageBearerTokenChallengeAuthenticationPolicy","isPipelineLike","pipeline","castPipeline","Array","isArray","factories","options","toServiceClientOptions","Pipeline","constructor","arguments","length","undefined","Object","assign","httpClient","requestPolicyFactories","newPipeline","credential","pipelineOptions","telemetryPolicy","userAgentOptions","userAgent","telemetryString","keepAliveOptions","retryOptions","xmlCharKey","info","allowedHeaderNames","allowedQueryParameters","push","proxyOptions","_a","audience"],"sources":["../../../src/Pipeline.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  deserializationPolicy,\n  disableResponseDecompressionPolicy,\n  HttpClient as IHttpClient,\n  HttpHeaders,\n  HttpOperationResponse,\n  HttpRequestBody,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n  ServiceClientOptions,\n  WebResource,\n  proxyPolicy,\n  isNode,\n  TokenCredential,\n  isTokenCredential,\n  tracingPolicy,\n  logPolicy,\n  ProxyOptions,\n  keepAlivePolicy,\n  KeepAliveOptions,\n  generateClientRequestIdPolicy,\n  UserAgentOptions,\n} from \"@azure/core-http\";\n\nimport { logger } from \"./log\";\nimport { StorageBrowserPolicyFactory } from \"./StorageBrowserPolicyFactory\";\nimport { StorageRetryOptions, StorageRetryPolicyFactory } from \"./StorageRetryPolicyFactory\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport {\n  StorageOAuthScopes,\n  StorageBlobLoggingAllowedHeaderNames,\n  StorageBlobLoggingAllowedQueryParameters,\n} from \"./utils/constants\";\nimport { TelemetryPolicyFactory } from \"./TelemetryPolicyFactory\";\nimport { getCachedDefaultHttpClient } from \"./utils/cache\";\nimport { attachCredential } from \"./utils/utils.common\";\nimport { storageBearerTokenChallengeAuthenticationPolicy } from \"./policies/StorageBearerTokenChallengeAuthenticationPolicy\";\n\n// Export following interfaces and types for customers who want to implement their\n// own RequestPolicy or HTTPClient\nexport {\n  BaseRequestPolicy,\n  StorageOAuthScopes,\n  deserializationPolicy,\n  IHttpClient,\n  HttpHeaders,\n  HttpRequestBody,\n  HttpOperationResponse,\n  WebResource,\n  RequestPolicyFactory,\n  RequestPolicy,\n  RequestPolicyOptions,\n};\n\n/**\n * Option interface for Pipeline constructor.\n */\nexport interface PipelineOptions {\n  /**\n   * Optional. Configures the HTTP client to send requests and receive responses.\n   */\n  httpClient?: IHttpClient;\n}\n\n/**\n * An interface for the {@link Pipeline} class containing HTTP request policies.\n * You can create a default Pipeline by calling {@link newPipeline}.\n * Or you can create a Pipeline with your own policies by the constructor of Pipeline.\n *\n * Refer to {@link newPipeline} and provided policies before implementing your\n * customized Pipeline.\n */\nexport interface PipelineLike {\n  /**\n   * A list of chained request policy factories.\n   */\n  readonly factories: RequestPolicyFactory[];\n  /**\n   * Configures pipeline logger and HTTP client.\n   */\n  readonly options: PipelineOptions;\n  /**\n   * Transfer Pipeline object to ServiceClientOptions object which is required by\n   * ServiceClient constructor.\n   *\n   * @returns The ServiceClientOptions object from this Pipeline.\n   */\n  toServiceClientOptions(): ServiceClientOptions;\n}\n\n/**\n * A helper to decide if a given argument satisfies the Pipeline contract\n * @param pipeline - An argument that may be a Pipeline\n * @returns true when the argument satisfies the Pipeline contract\n */\nexport function isPipelineLike(pipeline: unknown): pipeline is PipelineLike {\n  if (!pipeline || typeof pipeline !== \"object\") {\n    return false;\n  }\n\n  const castPipeline = pipeline as PipelineLike;\n\n  return (\n    Array.isArray(castPipeline.factories) &&\n    typeof castPipeline.options === \"object\" &&\n    typeof castPipeline.toServiceClientOptions === \"function\"\n  );\n}\n\n/**\n * A Pipeline class containing HTTP request policies.\n * You can create a default Pipeline by calling {@link newPipeline}.\n * Or you can create a Pipeline with your own policies by the constructor of Pipeline.\n *\n * Refer to {@link newPipeline} and provided policies before implementing your\n * customized Pipeline.\n */\nexport class Pipeline implements PipelineLike {\n  /**\n   * A list of chained request policy factories.\n   */\n  public readonly factories: RequestPolicyFactory[];\n  /**\n   * Configures pipeline logger and HTTP client.\n   */\n  public readonly options: PipelineOptions;\n\n  /**\n   * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.\n   *\n   * @param factories -\n   * @param options -\n   */\n  constructor(factories: RequestPolicyFactory[], options: PipelineOptions = {}) {\n    this.factories = factories;\n    // when options.httpClient is not specified, passing in a DefaultHttpClient instance to\n    // avoid each client creating its own http client.\n    this.options = {\n      ...options,\n      httpClient: options.httpClient || getCachedDefaultHttpClient(),\n    };\n  }\n\n  /**\n   * Transfer Pipeline object to ServiceClientOptions object which is required by\n   * ServiceClient constructor.\n   *\n   * @returns The ServiceClientOptions object from this Pipeline.\n   */\n  public toServiceClientOptions(): ServiceClientOptions {\n    return {\n      httpClient: this.options.httpClient,\n      requestPolicyFactories: this.factories,\n    };\n  }\n}\n\n/**\n * Options interface for the {@link newPipeline} function.\n */\nexport interface StoragePipelineOptions {\n  /**\n   * Options to configure a proxy for outgoing requests.\n   */\n  proxyOptions?: ProxyOptions;\n  /**\n   * Options for adding user agent details to outgoing requests.\n   */\n  userAgentOptions?: UserAgentOptions;\n  /**\n   * Configures the built-in retry policy behavior.\n   */\n  retryOptions?: StorageRetryOptions;\n  /**\n   * Keep alive configurations. Default keep-alive is enabled.\n   */\n  keepAliveOptions?: KeepAliveOptions;\n  /**\n   * Configures the HTTP client to send requests and receive responses.\n   */\n  httpClient?: IHttpClient;\n  /**\n   * The audience used to retrieve an AAD token.\n   */\n  audience?: string | string[];\n}\n\n/**\n * Creates a new Pipeline object with Credential provided.\n *\n * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n * @param pipelineOptions - Optional. Options.\n * @returns A new Pipeline object.\n */\nexport function newPipeline(\n  credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n  pipelineOptions: StoragePipelineOptions = {}\n): Pipeline {\n  if (credential === undefined) {\n    credential = new AnonymousCredential();\n  }\n\n  // Order is important. Closer to the API at the top & closer to the network at the bottom.\n  // The credential's policy factory must appear close to the wire so it can sign any\n  // changes made by other factories (like UniqueRequestIDPolicyFactory)\n\n  const telemetryPolicy = new TelemetryPolicyFactory(pipelineOptions.userAgentOptions);\n  const factories: RequestPolicyFactory[] = [\n    tracingPolicy({ userAgent: telemetryPolicy.telemetryString }),\n    keepAlivePolicy(pipelineOptions.keepAliveOptions),\n    telemetryPolicy,\n    generateClientRequestIdPolicy(),\n    new StorageBrowserPolicyFactory(),\n    new StorageRetryPolicyFactory(pipelineOptions.retryOptions), // Retry policy should be above any policy that throws retryable errors\n    // Default deserializationPolicy is provided by protocol layer\n    // Use customized XML char key of \"#\" so we could deserialize metadata\n    // with \"_\" key\n    deserializationPolicy(undefined, { xmlCharKey: \"#\" }),\n    logPolicy({\n      logger: logger.info,\n      allowedHeaderNames: StorageBlobLoggingAllowedHeaderNames,\n      allowedQueryParameters: StorageBlobLoggingAllowedQueryParameters,\n    }),\n  ];\n\n  if (isNode) {\n    // policies only available in Node.js runtime, not in browsers\n    factories.push(proxyPolicy(pipelineOptions.proxyOptions));\n    factories.push(disableResponseDecompressionPolicy());\n  }\n  factories.push(\n    isTokenCredential(credential)\n      ? attachCredential(\n          storageBearerTokenChallengeAuthenticationPolicy(\n            credential,\n            pipelineOptions.audience ?? StorageOAuthScopes\n          ),\n          credential\n        )\n      : credential\n  );\n\n  return new Pipeline(factories, pipelineOptions);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}