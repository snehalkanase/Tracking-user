{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders } from \"./httpHeaders\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError\";\n/**\n * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.\n */\nexport class XhrHttpClient {\n  sendRequest(request) {\n    var _a;\n    const xhr = new XMLHttpRequest();\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n    const abortSignal = request.abortSignal;\n    if (abortSignal) {\n      if (abortSignal.aborted) {\n        return Promise.reject(new AbortError(\"The operation was aborted.\"));\n      }\n      const listener = () => {\n        xhr.abort();\n      };\n      abortSignal.addEventListener(\"abort\", listener);\n      xhr.addEventListener(\"readystatechange\", () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          abortSignal.removeEventListener(\"abort\", listener);\n        }\n      });\n    }\n    addProgressListener(xhr.upload, request.onUploadProgress);\n    addProgressListener(xhr, request.onDownloadProgress);\n    if (request.formData) {\n      const formData = request.formData;\n      const requestForm = new FormData();\n      const appendFormValue = (key, value) => {\n        if (value && Object.prototype.hasOwnProperty.call(value, \"value\") && Object.prototype.hasOwnProperty.call(value, \"options\")) {\n          requestForm.append(key, value.value, value.options);\n        } else {\n          requestForm.append(key, value);\n        }\n      };\n      for (const formKey of Object.keys(formData)) {\n        const formValue = formData[formKey];\n        if (Array.isArray(formValue)) {\n          for (let j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j]);\n          }\n        } else {\n          appendFormValue(formKey, formValue);\n        }\n      }\n      request.body = requestForm;\n      request.formData = undefined;\n      const contentType = request.headers.get(\"Content-Type\");\n      if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n        // browser will automatically apply a suitable content-type header\n        request.headers.remove(\"Content-Type\");\n      }\n    }\n    xhr.open(request.method, request.url);\n    xhr.timeout = request.timeout;\n    xhr.withCredentials = request.withCredentials;\n    for (const header of request.headers.headersArray()) {\n      xhr.setRequestHeader(header.name, header.value);\n    }\n    xhr.responseType = ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.size) || request.streamResponseBody ? \"blob\" : \"text\";\n    // tslint:disable-next-line:no-null-keyword\n    xhr.send(request.body === undefined ? null : request.body);\n    if (xhr.responseType === \"blob\") {\n      return new Promise((resolve, reject) => {\n        handleBlobResponse(xhr, request, resolve, reject);\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    } else {\n      return new Promise(function (resolve, reject) {\n        xhr.addEventListener(\"load\", () => resolve({\n          request,\n          status: xhr.status,\n          headers: parseHeaders(xhr),\n          bodyAsText: xhr.responseText\n        }));\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    }\n  }\n}\nfunction handleBlobResponse(xhr, request, res, rej) {\n  xhr.addEventListener(\"readystatechange\", () => {\n    var _a;\n    // Resolve as soon as headers are loaded\n    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n      if (request.streamResponseBody || ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(xhr.status))) {\n        const blobBody = new Promise((resolve, reject) => {\n          xhr.addEventListener(\"load\", () => {\n            resolve(xhr.response);\n          });\n          rejectOnTerminalEvent(request, xhr, reject);\n        });\n        res({\n          request,\n          status: xhr.status,\n          headers: parseHeaders(xhr),\n          blobBody\n        });\n      } else {\n        xhr.addEventListener(\"load\", () => {\n          // xhr.response is of Blob type if the request is sent with xhr.responseType === \"blob\"\n          // but the status code is not one of the stream response status codes,\n          // so treat it as text and convert from Blob to text\n          if (xhr.response) {\n            // Blob.text() is not supported in IE so using FileReader instead\n            const reader = new FileReader();\n            reader.onload = function (e) {\n              var _a;\n              const text = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;\n              res({\n                request,\n                status: xhr.status,\n                headers: parseHeaders(xhr),\n                bodyAsText: text\n              });\n            };\n            reader.onerror = function (_e) {\n              rej(reader.error);\n            };\n            reader.readAsText(xhr.response, \"UTF-8\");\n          } else {\n            res({\n              request,\n              status: xhr.status,\n              headers: parseHeaders(xhr)\n            });\n          }\n        });\n      }\n    }\n  });\n}\nfunction addProgressListener(xhr, listener) {\n  if (listener) {\n    xhr.addEventListener(\"progress\", rawEvent => listener({\n      loadedBytes: rawEvent.loaded\n    }));\n  }\n}\n// exported locally for testing\nexport function parseHeaders(xhr) {\n  const responseHeaders = new HttpHeaders();\n  const headerLines = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n  for (const line of headerLines) {\n    const index = line.indexOf(\":\");\n    const headerName = line.slice(0, index);\n    const headerValue = line.slice(index + 2);\n    responseHeaders.set(headerName, headerValue);\n  }\n  return responseHeaders;\n}\nfunction rejectOnTerminalEvent(request, xhr, reject) {\n  xhr.addEventListener(\"error\", () => reject(new RestError(`Failed to send request to ${request.url}`, RestError.REQUEST_SEND_ERROR, undefined, request)));\n  const abortError = new AbortError(\"The operation was aborted.\");\n  xhr.addEventListener(\"abort\", () => reject(abortError));\n  xhr.addEventListener(\"timeout\", () => reject(abortError));\n}","map":{"version":3,"names":["HttpHeaders","AbortError","RestError","XhrHttpClient","sendRequest","request","xhr","XMLHttpRequest","proxySettings","Error","abortSignal","aborted","Promise","reject","listener","abort","addEventListener","readyState","DONE","removeEventListener","addProgressListener","upload","onUploadProgress","onDownloadProgress","formData","requestForm","FormData","appendFormValue","key","value","Object","prototype","hasOwnProperty","call","append","options","formKey","keys","formValue","Array","isArray","j","length","body","undefined","contentType","headers","get","indexOf","remove","open","method","url","timeout","withCredentials","header","headersArray","setRequestHeader","name","responseType","_a","streamResponseStatusCodes","size","streamResponseBody","send","resolve","handleBlobResponse","rejectOnTerminalEvent","status","parseHeaders","bodyAsText","responseText","res","rej","HEADERS_RECEIVED","has","blobBody","response","reader","FileReader","onload","e","text","target","result","onerror","_e","error","readAsText","rawEvent","loadedBytes","loaded","responseHeaders","headerLines","getAllResponseHeaders","trim","split","line","index","headerName","slice","headerValue","set","REQUEST_SEND_ERROR","abortError"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\core-http\\src\\xhrHttpClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpHeaders, HttpHeadersLike } from \"./httpHeaders\";\nimport { TransferProgressEvent, WebResourceLike } from \"./webResource\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpOperationResponse } from \"./httpOperationResponse\";\nimport { RestError } from \"./restError\";\n\n/**\n * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.\n */\nexport class XhrHttpClient implements HttpClient {\n  public sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    const xhr = new XMLHttpRequest();\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    const abortSignal = request.abortSignal;\n    if (abortSignal) {\n      if (abortSignal.aborted) {\n        return Promise.reject(new AbortError(\"The operation was aborted.\"));\n      }\n\n      const listener = (): void => {\n        xhr.abort();\n      };\n      abortSignal.addEventListener(\"abort\", listener);\n      xhr.addEventListener(\"readystatechange\", () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          abortSignal.removeEventListener(\"abort\", listener);\n        }\n      });\n    }\n\n    addProgressListener(xhr.upload, request.onUploadProgress);\n    addProgressListener(xhr, request.onDownloadProgress);\n\n    if (request.formData) {\n      const formData = request.formData;\n      const requestForm = new FormData();\n      const appendFormValue = (key: string, value: any): void => {\n        if (\n          value &&\n          Object.prototype.hasOwnProperty.call(value, \"value\") &&\n          Object.prototype.hasOwnProperty.call(value, \"options\")\n        ) {\n          requestForm.append(key, value.value, value.options);\n        } else {\n          requestForm.append(key, value);\n        }\n      };\n      for (const formKey of Object.keys(formData)) {\n        const formValue = formData[formKey];\n        if (Array.isArray(formValue)) {\n          for (let j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j]);\n          }\n        } else {\n          appendFormValue(formKey, formValue);\n        }\n      }\n\n      request.body = requestForm;\n      request.formData = undefined;\n      const contentType = request.headers.get(\"Content-Type\");\n      if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n        // browser will automatically apply a suitable content-type header\n        request.headers.remove(\"Content-Type\");\n      }\n    }\n\n    xhr.open(request.method, request.url);\n    xhr.timeout = request.timeout;\n    xhr.withCredentials = request.withCredentials;\n    for (const header of request.headers.headersArray()) {\n      xhr.setRequestHeader(header.name, header.value);\n    }\n\n    xhr.responseType =\n      request.streamResponseStatusCodes?.size || request.streamResponseBody ? \"blob\" : \"text\";\n\n    // tslint:disable-next-line:no-null-keyword\n    xhr.send(request.body === undefined ? null : request.body);\n\n    if (xhr.responseType === \"blob\") {\n      return new Promise((resolve, reject) => {\n        handleBlobResponse(xhr, request, resolve, reject);\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    } else {\n      return new Promise(function (resolve, reject) {\n        xhr.addEventListener(\"load\", () =>\n          resolve({\n            request,\n            status: xhr.status,\n            headers: parseHeaders(xhr),\n            bodyAsText: xhr.responseText,\n          })\n        );\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    }\n  }\n}\n\nfunction handleBlobResponse(\n  xhr: XMLHttpRequest,\n  request: WebResourceLike,\n  res: (value: HttpOperationResponse | PromiseLike<HttpOperationResponse>) => void,\n  rej: (reason?: any) => void\n): void {\n  xhr.addEventListener(\"readystatechange\", () => {\n    // Resolve as soon as headers are loaded\n    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n      if (request.streamResponseBody || request.streamResponseStatusCodes?.has(xhr.status)) {\n        const blobBody = new Promise<Blob>((resolve, reject) => {\n          xhr.addEventListener(\"load\", () => {\n            resolve(xhr.response);\n          });\n          rejectOnTerminalEvent(request, xhr, reject);\n        });\n        res({\n          request,\n          status: xhr.status,\n          headers: parseHeaders(xhr),\n          blobBody,\n        });\n      } else {\n        xhr.addEventListener(\"load\", () => {\n          // xhr.response is of Blob type if the request is sent with xhr.responseType === \"blob\"\n          // but the status code is not one of the stream response status codes,\n          // so treat it as text and convert from Blob to text\n          if (xhr.response) {\n            // Blob.text() is not supported in IE so using FileReader instead\n            const reader = new FileReader();\n            reader.onload = function (e) {\n              const text = e.target?.result as string;\n              res({\n                request,\n                status: xhr.status,\n                headers: parseHeaders(xhr),\n                bodyAsText: text,\n              });\n            };\n            reader.onerror = function (_e) {\n              rej(reader.error);\n            };\n            reader.readAsText(xhr.response, \"UTF-8\");\n          } else {\n            res({\n              request,\n              status: xhr.status,\n              headers: parseHeaders(xhr),\n            });\n          }\n        });\n      }\n    }\n  });\n}\n\nfunction addProgressListener(\n  xhr: XMLHttpRequestEventTarget,\n  listener?: (progress: TransferProgressEvent) => void\n): void {\n  if (listener) {\n    xhr.addEventListener(\"progress\", (rawEvent) =>\n      listener({\n        loadedBytes: rawEvent.loaded,\n      })\n    );\n  }\n}\n\n// exported locally for testing\nexport function parseHeaders(xhr: XMLHttpRequest): HttpHeadersLike {\n  const responseHeaders = new HttpHeaders();\n  const headerLines = xhr\n    .getAllResponseHeaders()\n    .trim()\n    .split(/[\\r\\n]+/);\n  for (const line of headerLines) {\n    const index = line.indexOf(\":\");\n    const headerName = line.slice(0, index);\n    const headerValue = line.slice(index + 2);\n    responseHeaders.set(headerName, headerValue);\n  }\n  return responseHeaders;\n}\n\nfunction rejectOnTerminalEvent(\n  request: WebResourceLike,\n  xhr: XMLHttpRequest,\n  reject: (err: any) => void\n): void {\n  xhr.addEventListener(\"error\", () =>\n    reject(\n      new RestError(\n        `Failed to send request to ${request.url}`,\n        RestError.REQUEST_SEND_ERROR,\n        undefined,\n        request\n      )\n    )\n  );\n  const abortError = new AbortError(\"The operation was aborted.\");\n  xhr.addEventListener(\"abort\", () => reject(abortError));\n  xhr.addEventListener(\"timeout\", () => reject(abortError));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}