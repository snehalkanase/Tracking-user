{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nvar MutexLockStatus;\n(function (MutexLockStatus) {\n  MutexLockStatus[MutexLockStatus[\"LOCKED\"] = 0] = \"LOCKED\";\n  MutexLockStatus[MutexLockStatus[\"UNLOCKED\"] = 1] = \"UNLOCKED\";\n})(MutexLockStatus || (MutexLockStatus = {}));\n/**\n * An async mutex lock.\n */\nexport class Mutex {\n  /**\n   * Lock for a specific key. If the lock has been acquired by another customer, then\n   * will wait until getting the lock.\n   *\n   * @param key - lock key\n   */\n  static async lock(key) {\n    return new Promise(resolve => {\n      if (this.keys[key] === undefined || this.keys[key] === MutexLockStatus.UNLOCKED) {\n        this.keys[key] = MutexLockStatus.LOCKED;\n        resolve();\n      } else {\n        this.onUnlockEvent(key, () => {\n          this.keys[key] = MutexLockStatus.LOCKED;\n          resolve();\n        });\n      }\n    });\n  }\n  /**\n   * Unlock a key.\n   *\n   * @param key -\n   */\n  static async unlock(key) {\n    return new Promise(resolve => {\n      if (this.keys[key] === MutexLockStatus.LOCKED) {\n        this.emitUnlockEvent(key);\n      }\n      delete this.keys[key];\n      resolve();\n    });\n  }\n  static onUnlockEvent(key, handler) {\n    if (this.listeners[key] === undefined) {\n      this.listeners[key] = [handler];\n    } else {\n      this.listeners[key].push(handler);\n    }\n  }\n  static emitUnlockEvent(key) {\n    if (this.listeners[key] !== undefined && this.listeners[key].length > 0) {\n      const handler = this.listeners[key].shift();\n      setImmediate(() => {\n        handler.call(this);\n      });\n    }\n  }\n}\nMutex.keys = {};\nMutex.listeners = {};","map":{"version":3,"names":["MutexLockStatus","Mutex","lock","key","Promise","resolve","keys","undefined","UNLOCKED","LOCKED","onUnlockEvent","unlock","emitUnlockEvent","handler","listeners","push","length","shift","setImmediate","call"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\storage-blob\\src\\utils\\Mutex.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nenum MutexLockStatus {\n  LOCKED,\n  UNLOCKED,\n}\n\ntype Callback = (...args: any[]) => any;\n\n/**\n * An async mutex lock.\n */\nexport class Mutex {\n  /**\n   * Lock for a specific key. If the lock has been acquired by another customer, then\n   * will wait until getting the lock.\n   *\n   * @param key - lock key\n   */\n  public static async lock(key: string): Promise<void> {\n    return new Promise<void>((resolve) => {\n      if (this.keys[key] === undefined || this.keys[key] === MutexLockStatus.UNLOCKED) {\n        this.keys[key] = MutexLockStatus.LOCKED;\n        resolve();\n      } else {\n        this.onUnlockEvent(key, () => {\n          this.keys[key] = MutexLockStatus.LOCKED;\n          resolve();\n        });\n      }\n    });\n  }\n\n  /**\n   * Unlock a key.\n   *\n   * @param key -\n   */\n  public static async unlock(key: string): Promise<void> {\n    return new Promise<void>((resolve) => {\n      if (this.keys[key] === MutexLockStatus.LOCKED) {\n        this.emitUnlockEvent(key);\n      }\n      delete this.keys[key];\n      resolve();\n    });\n  }\n\n  private static keys: { [key: string]: MutexLockStatus } = {};\n  private static listeners: { [key: string]: Callback[] } = {};\n\n  private static onUnlockEvent(key: string, handler: Callback) {\n    if (this.listeners[key] === undefined) {\n      this.listeners[key] = [handler];\n    } else {\n      this.listeners[key].push(handler);\n    }\n  }\n\n  private static emitUnlockEvent(key: string) {\n    if (this.listeners[key] !== undefined && this.listeners[key].length > 0) {\n      const handler = this.listeners[key].shift();\n      setImmediate(() => {\n        handler!.call(this);\n      });\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AAEA,IAAKA,eAGJ;AAHD,WAAKA,eAAe;EAClBA,eAAA,CAAAA,eAAA,0BAAM;EACNA,eAAA,CAAAA,eAAA,8BAAQ;AACV,CAAC,EAHIA,eAAe,KAAfA,eAAe;AAOpB;;;AAGA,OAAM,MAAOC,KAAK;EAChB;;;;;;EAMO,aAAaC,IAAIA,CAACC,GAAW;IAClC,OAAO,IAAIC,OAAO,CAAQC,OAAO,IAAI;MACnC,IAAI,IAAI,CAACC,IAAI,CAACH,GAAG,CAAC,KAAKI,SAAS,IAAI,IAAI,CAACD,IAAI,CAACH,GAAG,CAAC,KAAKH,eAAe,CAACQ,QAAQ,EAAE;QAC/E,IAAI,CAACF,IAAI,CAACH,GAAG,CAAC,GAAGH,eAAe,CAACS,MAAM;QACvCJ,OAAO,EAAE;OACV,MAAM;QACL,IAAI,CAACK,aAAa,CAACP,GAAG,EAAE,MAAK;UAC3B,IAAI,CAACG,IAAI,CAACH,GAAG,CAAC,GAAGH,eAAe,CAACS,MAAM;UACvCJ,OAAO,EAAE;QACX,CAAC,CAAC;;IAEN,CAAC,CAAC;EACJ;EAEA;;;;;EAKO,aAAaM,MAAMA,CAACR,GAAW;IACpC,OAAO,IAAIC,OAAO,CAAQC,OAAO,IAAI;MACnC,IAAI,IAAI,CAACC,IAAI,CAACH,GAAG,CAAC,KAAKH,eAAe,CAACS,MAAM,EAAE;QAC7C,IAAI,CAACG,eAAe,CAACT,GAAG,CAAC;;MAE3B,OAAO,IAAI,CAACG,IAAI,CAACH,GAAG,CAAC;MACrBE,OAAO,EAAE;IACX,CAAC,CAAC;EACJ;EAKQ,OAAOK,aAAaA,CAACP,GAAW,EAAEU,OAAiB;IACzD,IAAI,IAAI,CAACC,SAAS,CAACX,GAAG,CAAC,KAAKI,SAAS,EAAE;MACrC,IAAI,CAACO,SAAS,CAACX,GAAG,CAAC,GAAG,CAACU,OAAO,CAAC;KAChC,MAAM;MACL,IAAI,CAACC,SAAS,CAACX,GAAG,CAAC,CAACY,IAAI,CAACF,OAAO,CAAC;;EAErC;EAEQ,OAAOD,eAAeA,CAACT,GAAW;IACxC,IAAI,IAAI,CAACW,SAAS,CAACX,GAAG,CAAC,KAAKI,SAAS,IAAI,IAAI,CAACO,SAAS,CAACX,GAAG,CAAC,CAACa,MAAM,GAAG,CAAC,EAAE;MACvE,MAAMH,OAAO,GAAG,IAAI,CAACC,SAAS,CAACX,GAAG,CAAC,CAACc,KAAK,EAAE;MAC3CC,YAAY,CAAC,MAAK;QAChBL,OAAQ,CAACM,IAAI,CAAC,IAAI,CAAC;MACrB,CAAC,CAAC;;EAEN;;AAlBelB,KAAA,CAAAK,IAAI,GAAuC,EAAE;AAC7CL,KAAA,CAAAa,SAAS,GAAkC,EAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}