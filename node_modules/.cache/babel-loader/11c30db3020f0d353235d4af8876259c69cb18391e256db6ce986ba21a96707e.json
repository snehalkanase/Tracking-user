{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _defineProperty from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\n/**\n * returns an async iterator that iterates over results. It also has a `byPage`\n * method that returns pages of items at once.\n *\n * @param pagedResult - an object that specifies how to get pages.\n * @returns a paged async iterator that iterates over results.\n */\nexport function getPagedAsyncIterator(pagedResult) {\n  var _ref2;\n  var _a;\n  var iter = getItemAsyncIterator(pagedResult);\n  return _ref2 = {\n    next: function next() {\n      return iter.next();\n    }\n  }, _defineProperty(_ref2, Symbol.asyncIterator, function () {\n    return this;\n  }), _defineProperty(_ref2, \"byPage\", (_a = pagedResult === null || pagedResult === void 0 ? void 0 : pagedResult.byPage) !== null && _a !== void 0 ? _a : function (settings) {\n    var _ref = settings !== null && settings !== void 0 ? settings : {},\n      continuationToken = _ref.continuationToken,\n      maxPageSize = _ref.maxPageSize;\n    return getPageAsyncIterator(pagedResult, {\n      pageLink: continuationToken,\n      maxPageSize: maxPageSize\n    });\n  }), _ref2;\n}\nfunction getItemAsyncIterator(pagedResult) {\n  return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function getItemAsyncIterator_1() {\n    var e_1, _a, e_2, _b, pages, firstVal, toElements, pages_1, pages_1_1, page, pages_2, pages_2_1, _page;\n    return _regeneratorRuntime().wrap(function getItemAsyncIterator_1$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          pages = getPageAsyncIterator(pagedResult);\n          _context.next = 3;\n          return __await(pages.next());\n        case 3:\n          firstVal = _context.sent;\n          if (Array.isArray(firstVal.value)) {\n            _context.next = 54;\n            break;\n          }\n          // can extract elements from this page\n          toElements = pagedResult.toElements;\n          if (!toElements) {\n            _context.next = 43;\n            break;\n          }\n          _context.t0 = __await;\n          return _context.delegateYield(__asyncDelegator(__asyncValues(toElements(firstVal.value))), \"t1\", 9);\n        case 9:\n          _context.t2 = _context.t1;\n          _context.next = 12;\n          return (0, _context.t0)(_context.t2);\n        case 12:\n          _context.prev = 12;\n          pages_1 = __asyncValues(pages);\n        case 14:\n          _context.next = 16;\n          return __await(pages_1.next());\n        case 16:\n          pages_1_1 = _context.sent;\n          if (pages_1_1.done) {\n            _context.next = 26;\n            break;\n          }\n          page = pages_1_1.value;\n          _context.t3 = __await;\n          return _context.delegateYield(__asyncDelegator(__asyncValues(toElements(page))), \"t4\", 21);\n        case 21:\n          _context.t5 = _context.t4;\n          _context.next = 24;\n          return (0, _context.t3)(_context.t5);\n        case 24:\n          _context.next = 14;\n          break;\n        case 26:\n          _context.next = 31;\n          break;\n        case 28:\n          _context.prev = 28;\n          _context.t6 = _context[\"catch\"](12);\n          e_1 = {\n            error: _context.t6\n          };\n        case 31:\n          _context.prev = 31;\n          _context.prev = 32;\n          if (!(pages_1_1 && !pages_1_1.done && (_a = pages_1.return))) {\n            _context.next = 36;\n            break;\n          }\n          _context.next = 36;\n          return __await(_a.call(pages_1));\n        case 36:\n          _context.prev = 36;\n          if (!e_1) {\n            _context.next = 39;\n            break;\n          }\n          throw e_1.error;\n        case 39:\n          return _context.finish(36);\n        case 40:\n          return _context.finish(31);\n        case 41:\n          _context.next = 52;\n          break;\n        case 43:\n          _context.next = 45;\n          return __await(firstVal.value);\n        case 45:\n          _context.next = 47;\n          return _context.sent;\n        case 47:\n          _context.t7 = __await;\n          return _context.delegateYield(__asyncDelegator(__asyncValues(pages)), \"t8\", 49);\n        case 49:\n          _context.t9 = _context.t8;\n          _context.next = 52;\n          return (0, _context.t7)(_context.t9);\n        case 52:\n          _context.next = 88;\n          break;\n        case 54:\n          _context.t10 = __await;\n          return _context.delegateYield(__asyncDelegator(__asyncValues(firstVal.value)), \"t11\", 56);\n        case 56:\n          _context.t12 = _context.t11;\n          _context.next = 59;\n          return (0, _context.t10)(_context.t12);\n        case 59:\n          _context.prev = 59;\n          pages_2 = __asyncValues(pages);\n        case 61:\n          _context.next = 63;\n          return __await(pages_2.next());\n        case 63:\n          pages_2_1 = _context.sent;\n          if (pages_2_1.done) {\n            _context.next = 73;\n            break;\n          }\n          _page = pages_2_1.value; // pages is of type `AsyncIterableIterator<TPage>` so `page` is of type `TPage`. In this branch,\n          // it must be the case that `TPage = TElement[]`\n          _context.t13 = __await;\n          return _context.delegateYield(__asyncDelegator(__asyncValues(_page)), \"t14\", 68);\n        case 68:\n          _context.t15 = _context.t14;\n          _context.next = 71;\n          return (0, _context.t13)(_context.t15);\n        case 71:\n          _context.next = 61;\n          break;\n        case 73:\n          _context.next = 78;\n          break;\n        case 75:\n          _context.prev = 75;\n          _context.t16 = _context[\"catch\"](59);\n          e_2 = {\n            error: _context.t16\n          };\n        case 78:\n          _context.prev = 78;\n          _context.prev = 79;\n          if (!(pages_2_1 && !pages_2_1.done && (_b = pages_2.return))) {\n            _context.next = 83;\n            break;\n          }\n          _context.next = 83;\n          return __await(_b.call(pages_2));\n        case 83:\n          _context.prev = 83;\n          if (!e_2) {\n            _context.next = 86;\n            break;\n          }\n          throw e_2.error;\n        case 86:\n          return _context.finish(83);\n        case 87:\n          return _context.finish(78);\n        case 88:\n        case \"end\":\n          return _context.stop();\n      }\n    }, getItemAsyncIterator_1, null, [[12, 28, 31, 41], [32,, 36, 40], [59, 75, 78, 88], [79,, 83, 87]]);\n  }));\n}\nfunction getPageAsyncIterator(pagedResult) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function getPageAsyncIterator_1() {\n    var pageLink, maxPageSize, response;\n    return _regeneratorRuntime().wrap(function getPageAsyncIterator_1$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          pageLink = options.pageLink, maxPageSize = options.maxPageSize;\n          _context2.next = 3;\n          return __await(pagedResult.getPage(pageLink !== null && pageLink !== void 0 ? pageLink : pagedResult.firstPageLink, maxPageSize));\n        case 3:\n          response = _context2.sent;\n          if (response) {\n            _context2.next = 8;\n            break;\n          }\n          _context2.next = 7;\n          return __await(void 0);\n        case 7:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 8:\n          _context2.next = 10;\n          return __await(response.page);\n        case 10:\n          _context2.next = 12;\n          return _context2.sent;\n        case 12:\n          if (!response.nextPageLink) {\n            _context2.next = 26;\n            break;\n          }\n          _context2.next = 15;\n          return __await(pagedResult.getPage(response.nextPageLink, maxPageSize));\n        case 15:\n          response = _context2.sent;\n          if (response) {\n            _context2.next = 20;\n            break;\n          }\n          _context2.next = 19;\n          return __await(void 0);\n        case 19:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 20:\n          _context2.next = 22;\n          return __await(response.page);\n        case 22:\n          _context2.next = 24;\n          return _context2.sent;\n        case 24:\n          _context2.next = 12;\n          break;\n        case 26:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, getPageAsyncIterator_1);\n  }));\n}","map":{"version":3,"names":["getPagedAsyncIterator","pagedResult","_ref2","iter","getItemAsyncIterator","next","_defineProperty","Symbol","asyncIterator","_a","byPage","settings","_ref","continuationToken","maxPageSize","getPageAsyncIterator","pageLink","pages","_context","__await","firstVal","sent","Array","isArray","value","toElements","t0","delegateYield","__asyncDelegator","__asyncValues","t2","t1","prev","pages_1","pages_1_1","done","page","t3","t5","t4","t6","t7","t9","t8","t10","t12","t11","pages_2","pages_2_1","t13","t15","t14","t16","options","arguments","length","undefined","_context2","getPage","firstPageLink","response","abrupt","nextPageLink","stop"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\core-paging\\src\\getPagedAsyncIterator.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PageSettings, PagedAsyncIterableIterator, PagedResult } from \"./models\";\n\n/**\n * returns an async iterator that iterates over results. It also has a `byPage`\n * method that returns pages of items at once.\n *\n * @param pagedResult - an object that specifies how to get pages.\n * @returns a paged async iterator that iterates over results.\n */\n\nexport function getPagedAsyncIterator<\n  TElement,\n  TPage = TElement[],\n  TPageSettings = PageSettings,\n  TLink = string\n>(\n  pagedResult: PagedResult<TPage, TPageSettings, TLink>\n): PagedAsyncIterableIterator<TElement, TPage, TPageSettings> {\n  const iter = getItemAsyncIterator<TElement, TPage, TLink, TPageSettings>(pagedResult);\n  return {\n    next() {\n      return iter.next();\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n    byPage:\n      pagedResult?.byPage ??\n      (((settings?: PageSettings) => {\n        const { continuationToken, maxPageSize } = settings ?? {};\n        return getPageAsyncIterator(pagedResult, {\n          pageLink: continuationToken as unknown as TLink | undefined,\n          maxPageSize,\n        });\n      }) as unknown as (settings?: TPageSettings) => AsyncIterableIterator<TPage>),\n  };\n}\n\nasync function* getItemAsyncIterator<TElement, TPage, TLink, TPageSettings>(\n  pagedResult: PagedResult<TPage, TPageSettings, TLink>\n): AsyncIterableIterator<TElement> {\n  const pages = getPageAsyncIterator(pagedResult);\n  const firstVal = await pages.next();\n  // if the result does not have an array shape, i.e. TPage = TElement, then we return it as is\n  if (!Array.isArray(firstVal.value)) {\n    // can extract elements from this page\n    const { toElements } = pagedResult;\n    if (toElements) {\n      yield* toElements(firstVal.value) as TElement[];\n      for await (const page of pages) {\n        yield* toElements(page) as TElement[];\n      }\n    } else {\n      yield firstVal.value;\n      // `pages` is of type `AsyncIterableIterator<TPage>` but TPage = TElement in this case\n      yield* pages as unknown as AsyncIterableIterator<TElement>;\n    }\n  } else {\n    yield* firstVal.value;\n    for await (const page of pages) {\n      // pages is of type `AsyncIterableIterator<TPage>` so `page` is of type `TPage`. In this branch,\n      // it must be the case that `TPage = TElement[]`\n      yield* page as unknown as TElement[];\n    }\n  }\n}\n\nasync function* getPageAsyncIterator<TPage, TLink, TPageSettings>(\n  pagedResult: PagedResult<TPage, TPageSettings, TLink>,\n  options: {\n    maxPageSize?: number;\n    pageLink?: TLink;\n  } = {}\n): AsyncIterableIterator<TPage> {\n  const { pageLink, maxPageSize } = options;\n  let response = await pagedResult.getPage(pageLink ?? pagedResult.firstPageLink, maxPageSize);\n  if (!response) {\n    return;\n  }\n  yield response.page;\n  while (response.nextPageLink) {\n    response = await pagedResult.getPage(response.nextPageLink, maxPageSize);\n    if (!response) {\n      return;\n    }\n    yield response.page;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}