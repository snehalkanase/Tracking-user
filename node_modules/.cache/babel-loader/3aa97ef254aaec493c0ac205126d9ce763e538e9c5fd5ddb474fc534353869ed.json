{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as utils from \"./util/utils\";\nimport { MapperType } from \"./serializer\";\nimport { DefaultDeserializationOptions, deserializationPolicy } from \"./policies/deserializationPolicy\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { DefaultRedirectOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport { DefaultRetryOptions, exponentialRetryPolicy } from \"./policies/exponentialRetryPolicy\";\nimport { logPolicy } from \"./policies/logPolicy\";\nimport { getPathStringFromParameter, getPathStringFromParameterPath } from \"./operationParameter\";\nimport { getStreamResponseStatusCodes } from \"./operationSpec\";\nimport { WebResource, isWebResourceLike } from \"./webResource\";\nimport { RequestPolicyOptions } from \"./policies/requestPolicy\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nimport { isNode } from \"@azure/core-util\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { getDefaultUserAgentHeaderName, getDefaultUserAgentValue, userAgentPolicy } from \"./policies/userAgentPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { URLBuilder } from \"./url\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { logger } from \"./log\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { stringifyXML } from \"./util/xml\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\n/**\n * ServiceClient sends service requests and receives responses.\n */\nexport class ServiceClient {\n  /**\n   * The ServiceClient constructor\n   * @param credentials - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(credentials, /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n  options) {\n    if (!options) {\n      options = {};\n    }\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n    let requestPolicyFactories;\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      let authPolicyFactory = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\"ServiceClient: creating bearer token authentication policy from provided credentials\");\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        const wrappedPolicyFactory = () => {\n          let bearerTokenPolicyFactory = undefined;\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const serviceClient = this;\n          const serviceClientOptions = options;\n          return {\n            create(nextPolicy, createOptions) {\n              const credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);\n              if (!credentialScopes) {\n                throw new Error(`When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`);\n              }\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, credentialScopes);\n              }\n              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n            }\n          };\n        };\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        const newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n  sendRequest(options) {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n    let httpRequest;\n    try {\n      if (isWebResourceLike(options)) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error) {\n      return Promise.reject(error);\n    }\n    let httpPipeline = this._httpClient;\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);\n      }\n    }\n    return httpPipeline.sendRequest(httpRequest);\n  }\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   * @param callback - The callback to call when the response is received.\n   */\n  async sendOperationRequest(operationArguments, operationSpec, callback) {\n    var _a;\n    if (typeof operationArguments.options === \"function\") {\n      callback = operationArguments.options;\n      operationArguments.options = undefined;\n    }\n    const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n    const httpRequest = new WebResource();\n    let result;\n    try {\n      const baseUri = operationSpec.baseUrl || this.baseUri;\n      if (!baseUri) {\n        throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n      }\n      httpRequest.method = operationSpec.httpMethod;\n      httpRequest.operationSpec = operationSpec;\n      const requestUrl = URLBuilder.parse(baseUri);\n      if (operationSpec.path) {\n        requestUrl.appendPath(operationSpec.path);\n      }\n      if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n        for (const urlParameter of operationSpec.urlParameters) {\n          let urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);\n          urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions);\n          if (!urlParameter.skipEncoding) {\n            urlParameterValue = encodeURIComponent(urlParameterValue);\n          }\n          requestUrl.replaceAll(`{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`, urlParameterValue);\n        }\n      }\n      if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n        for (const queryParameter of operationSpec.queryParameters) {\n          let queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);\n          if (queryParameterValue !== undefined && queryParameterValue !== null) {\n            queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions);\n            if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null) {\n              if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                if (queryParameterValue.length === 0) {\n                  // The collection is empty, no need to try serializing the current queryParam\n                  continue;\n                } else {\n                  for (const index in queryParameterValue) {\n                    const item = queryParameterValue[index];\n                    queryParameterValue[index] = item === undefined || item === null ? \"\" : item.toString();\n                  }\n                }\n              } else if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv || queryParameter.collectionFormat === QueryCollectionFormat.Tsv) {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n            }\n            if (!queryParameter.skipEncoding) {\n              if (Array.isArray(queryParameterValue)) {\n                for (const index in queryParameterValue) {\n                  if (queryParameterValue[index] !== undefined && queryParameterValue[index] !== null) {\n                    queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                  }\n                }\n              } else {\n                queryParameterValue = encodeURIComponent(queryParameterValue);\n              }\n            }\n            if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== QueryCollectionFormat.Multi && queryParameter.collectionFormat !== QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) {\n              queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n            }\n            requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n          }\n        }\n      }\n      httpRequest.url = requestUrl.toString();\n      const contentType = operationSpec.contentType || this.requestContentType;\n      if (contentType && operationSpec.requestBody) {\n        httpRequest.headers.set(\"Content-Type\", contentType);\n      }\n      if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n          let headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);\n          if (headerValue !== undefined && headerValue !== null) {\n            headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions);\n            const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n            if (headerCollectionPrefix) {\n              for (const key of Object.keys(headerValue)) {\n                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n              }\n            } else {\n              httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n            }\n          }\n        }\n      }\n      const options = operationArguments.options;\n      if (options) {\n        if (options.customHeaders) {\n          for (const customHeaderName in options.customHeaders) {\n            httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n          }\n        }\n        if (options.abortSignal) {\n          httpRequest.abortSignal = options.abortSignal;\n        }\n        if (options.timeout) {\n          httpRequest.timeout = options.timeout;\n        }\n        if (options.onUploadProgress) {\n          httpRequest.onUploadProgress = options.onUploadProgress;\n        }\n        if (options.onDownloadProgress) {\n          httpRequest.onDownloadProgress = options.onDownloadProgress;\n        }\n        if (options.spanOptions) {\n          // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.\n          httpRequest.spanOptions = options.spanOptions;\n        }\n        if (options.tracingContext) {\n          httpRequest.tracingContext = options.tracingContext;\n        }\n        if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n          httpRequest.shouldDeserialize = options.shouldDeserialize;\n        }\n      }\n      httpRequest.withCredentials = this._withCredentials;\n      serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n      if (httpRequest.streamResponseStatusCodes === undefined) {\n        httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n      }\n      let rawResponse;\n      let sendRequestError;\n      try {\n        rawResponse = await this.sendRequest(httpRequest);\n      } catch (error) {\n        sendRequestError = error;\n      }\n      if (sendRequestError) {\n        if (sendRequestError.response) {\n          sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses[\"default\"]);\n        }\n        result = Promise.reject(sendRequestError);\n      } else {\n        result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));\n      }\n    } catch (error) {\n      result = Promise.reject(error);\n    }\n    const cb = callback;\n    if (cb) {\n      result.then(res => cb(null, res._response.parsedBody, res._response.request, res._response)).catch(err => cb(err));\n    }\n    return result;\n  }\n}\nexport function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {\n  var _a, _b, _c, _d, _e, _f;\n  const serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {};\n  const updatedOptions = {\n    rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : \"\",\n    includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,\n    xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY\n  };\n  const xmlCharKey = serializerOptions.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const {\n      required,\n      xmlName,\n      xmlElementName,\n      serializedName,\n      xmlNamespace,\n      xmlNamespacePrefix\n    } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n    try {\n      if (httpRequest.body !== undefined && httpRequest.body !== null || required) {\n        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);\n        const isStream = typeName === MapperType.Stream;\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(utils.prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          }\n        } else if (typeName === MapperType.String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n      }\n    }\n  }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result = {};\n    result[options.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = {\n      [xmlnsKey]: xmlNamespace\n    };\n    return result;\n  }\n  return serializedValue;\n}\nfunction getValueOrFunctionResult(value, defaultValueCreator) {\n  let result;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\nfunction createDefaultRequestPolicyFactories(authPolicyFactory, options) {\n  const factories = [];\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n  const userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);\n  const userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({\n      key: userAgentHeaderName,\n      value: userAgentHeaderValue\n    }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n  factories.push(logPolicy({\n    logger: logger.info\n  }));\n  return factories;\n}\n/**\n * Creates an HTTP pipeline based on the given options.\n * @param pipelineOptions - Defines options that are used to configure policies in the HTTP pipeline for an SDK client.\n * @param authPolicyFactory - An optional authentication policy factory to use for signing requests.\n * @returns A set of options that can be passed to create a new {@link ServiceClient}.\n */\nexport function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {\n  const requestPolicyFactories = [];\n  if (pipelineOptions.sendStreamingJson) {\n    requestPolicyFactories.push(ndJsonPolicy());\n  }\n  let userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    const userAgentInfo = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    const defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n  const keepAliveOptions = Object.assign(Object.assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);\n  const retryOptions = Object.assign(Object.assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);\n  const redirectOptions = Object.assign(Object.assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n  const deserializationOptions = Object.assign(Object.assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);\n  const loggingOptions = Object.assign({}, pipelineOptions.loggingOptions);\n  requestPolicyFactories.push(tracingPolicy({\n    userAgent: userAgentValue\n  }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({\n    value: userAgentValue\n  }), generateClientRequestIdPolicy(), deserializationPolicy(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories\n  };\n}\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent, propertyPath) {\n  if (parent && propertyPath) {\n    const propertyPathLength = propertyPath.length;\n    for (let i = 0; i < propertyPathLength - 1; ++i) {\n      const propertyName = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\nfunction getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {\n  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);\n}\nexport function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {\n  var _a;\n  let value;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n        let useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue = parameterMapper.required || parameterPath[0] === \"options\" && parameterPath.length === 2;\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n      // Serialize just for validation purposes.\n      const parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);\n      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n    for (const propertyName in parameterPath) {\n      const propertyMapper = parameterMapper.type.modelProperties[propertyName];\n      const propertyPath = parameterPath[propertyName];\n      const propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer);\n      // Serialize just for validation purposes.\n      const propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n  const result = {\n    propertyFound: false\n  };\n  let i = 0;\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n/**\n * Parses an {@link HttpOperationResponse} into a normalized HTTP response object ({@link RestResponse}).\n * @param _response - Wrapper object for http response.\n * @param responseSpec - Mappers for how to parse the response properties.\n * @returns - A normalized response object.\n */\nexport function flattenResponse(_response, responseSpec) {\n  const parsedHeaders = _response.parsedHeaders;\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n  const addOperationResponse = obj => {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n  };\n  if (bodyMapper) {\n    const typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      }));\n    }\n    const modelProperties = typeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n    const isPageableResponse = Object.keys(modelProperties).some(k => modelProperties[k].serializedName === \"\");\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      const arrayResponse = [...(_response.parsedBody || [])];\n      for (const key of Object.keys(modelProperties)) {\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n      if (parsedHeaders) {\n        for (const key of Object.keys(parsedHeaders)) {\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n    }\n  }\n  if (bodyMapper || _response.request.method === \"HEAD\" || utils.isPrimitiveType(_response.parsedBody)) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {\n      body: _response.parsedBody\n    }));\n  }\n  return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n}\nfunction getCredentialScopes(options, baseUri) {\n  if (options === null || options === void 0 ? void 0 : options.credentialScopes) {\n    return options.credentialScopes;\n  }\n  if (baseUri) {\n    return `${baseUri}/.default`;\n  }\n  return undefined;\n}","map":{"version":3,"names":["utils","MapperType","DefaultDeserializationOptions","deserializationPolicy","DefaultKeepAliveOptions","keepAlivePolicy","DefaultRedirectOptions","redirectPolicy","DefaultRetryOptions","exponentialRetryPolicy","logPolicy","getPathStringFromParameter","getPathStringFromParameterPath","getStreamResponseStatusCodes","WebResource","isWebResourceLike","RequestPolicyOptions","XML_ATTRKEY","XML_CHARKEY","isNode","isTokenCredential","getDefaultUserAgentHeaderName","getDefaultUserAgentValue","userAgentPolicy","QueryCollectionFormat","URLBuilder","bearerTokenAuthenticationPolicy","disableResponseDecompressionPolicy","generateClientRequestIdPolicy","getCachedDefaultHttpClient","logger","ndJsonPolicy","proxyPolicy","rpRegistrationPolicy","signingPolicy","stringifyXML","systemErrorRetryPolicy","throttlingRetryPolicy","tracingPolicy","ServiceClient","constructor","credentials","options","_withCredentials","withCredentials","_httpClient","httpClient","_requestPolicyOptions","httpPipelineLogger","requestPolicyFactories","Array","isArray","info","authPolicyFactory","undefined","wrappedPolicyFactory","bearerTokenPolicyFactory","serviceClient","serviceClientOptions","create","nextPolicy","createOptions","credentialScopes","getCredentialScopes","baseUri","Error","signRequest","createDefaultRequestPolicyFactories","newRequestPolicyFactories","_requestPolicyFactories","sendRequest","httpRequest","validateRequestProperties","prepare","error","Promise","reject","httpPipeline","length","i","sendOperationRequest","operationArguments","operationSpec","callback","serializerOptions","_a","result","baseUrl","method","httpMethod","requestUrl","parse","path","appendPath","urlParameters","urlParameter","urlParameterValue","getOperationArgumentValueFromParameter","serializer","serialize","mapper","skipEncoding","encodeURIComponent","replaceAll","serializedName","queryParameters","queryParameter","queryParameterValue","collectionFormat","Multi","index","item","toString","Ssv","Tsv","join","setQueryParameter","url","contentType","requestContentType","requestBody","headers","set","headerParameters","headerParameter","headerValue","headerCollectionPrefix","key","Object","keys","customHeaders","customHeaderName","abortSignal","timeout","onUploadProgress","onDownloadProgress","spanOptions","tracingContext","shouldDeserialize","serializeRequestBody","streamResponseStatusCodes","rawResponse","sendRequestError","response","details","flattenResponse","responses","statusCode","resolve","status","cb","then","res","_response","parsedBody","request","catch","err","_b","updatedOptions","rootName","_c","includeRoot","_d","xmlCharKey","_e","body","bodyMapper","required","xmlName","xmlElementName","xmlNamespace","xmlNamespacePrefix","typeName","type","name","requestBodyParameterPathString","isStream","Stream","isXML","xmlnsKey","value","getXmlValueWithNamespace","Sequence","prepareXMLRootList","String","_f","match","mediaType","JSON","stringify","message","formDataParameters","formData","formDataParameter","formDataParameterValue","formDataParameterPropertyName","serializedValue","includes","getValueOrFunctionResult","defaultValueCreator","factories","generateClientRequestIdHeader","push","clientRequestIdHeaderName","userAgentHeaderName","userAgentHeaderValue","userAgent","rpRegistrationRetryTimeout","noRetryPolicy","deserializationContentTypes","proxySettings","createPipelineFromOptions","pipelineOptions","sendStreamingJson","userAgentValue","userAgentOptions","userAgentPrefix","userAgentInfo","defaultUserAgentInfo","indexOf","keepAliveOptions","assign","retryOptions","redirectOptions","proxyOptions","deserializationOptions","loggingOptions","expectedContentTypes","maxRetries","retryDelayInMs","maxRetryDelayInMs","handleRedirects","decompressResponse","getPropertyParent","parent","propertyPath","propertyPathLength","propertyName","parameter","getOperationArgumentValueFromParameterPath","parameterPath","parameterMapper","isConstant","defaultValue","propertySearchResult","getPropertyFromParameterPath","propertyFound","useDefaultValue","propertyValue","parameterPathString","propertyMapper","modelProperties","propertyPathString","parameterPathPart","responseSpec","parsedHeaders","addOperationResponse","obj","defineProperty","blobBody","readableStreamBody","isPageableResponse","some","k","arrayResponse","isPrimitiveType"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\core-http\\src\\serviceClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as utils from \"./util/utils\";\nimport { CompositeMapper, DictionaryMapper, Mapper, MapperType, Serializer } from \"./serializer\";\nimport {\n  DefaultDeserializationOptions,\n  DeserializationContentTypes,\n  deserializationPolicy,\n} from \"./policies/deserializationPolicy\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { DefaultRedirectOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport { DefaultRetryOptions, exponentialRetryPolicy } from \"./policies/exponentialRetryPolicy\";\nimport { HttpOperationResponse, RestResponse } from \"./httpOperationResponse\";\nimport { LogPolicyOptions, logPolicy } from \"./policies/logPolicy\";\nimport {\n  OperationParameter,\n  ParameterPath,\n  getPathStringFromParameter,\n  getPathStringFromParameterPath,\n} from \"./operationParameter\";\nimport { OperationSpec, getStreamResponseStatusCodes } from \"./operationSpec\";\nimport {\n  RequestOptionsBase,\n  RequestPrepareOptions,\n  WebResource,\n  WebResourceLike,\n  isWebResourceLike,\n} from \"./webResource\";\nimport {\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./policies/requestPolicy\";\nimport { SerializerOptions, XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nimport { ServiceCallback } from \"./util/utils\";\nimport { isNode } from \"@azure/core-util\";\nimport { TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport {\n  getDefaultUserAgentHeaderName,\n  getDefaultUserAgentValue,\n  userAgentPolicy,\n} from \"./policies/userAgentPolicy\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpPipelineLogger } from \"./httpPipelineLogger\";\nimport { InternalPipelineOptions } from \"./pipelineOptions\";\nimport { OperationArguments } from \"./operationArguments\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { ServiceClientCredentials } from \"./credentials/serviceClientCredentials\";\nimport { URLBuilder } from \"./url\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { logger } from \"./log\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { stringifyXML } from \"./util/xml\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\n\n/**\n * Options to configure a proxy for outgoing requests (Node.js only).\n */\nexport interface ProxySettings {\n  /**\n   * The proxy's host address.\n   */\n  host: string;\n\n  /**\n   * The proxy host's port.\n   */\n  port: number;\n\n  /**\n   * The user name to authenticate with the proxy, if required.\n   */\n  username?: string;\n\n  /**\n   * The password to authenticate with the proxy, if required.\n   */\n  password?: string;\n}\n\n/**\n * An alias of {@link ProxySettings} for future use.\n */\nexport type ProxyOptions = ProxySettings;\n\n/**\n * Options to be provided while creating the client.\n */\nexport interface ServiceClientOptions {\n  /**\n   * An array of factories which get called to create the RequestPolicy pipeline used to send a HTTP\n   * request on the wire, or a function that takes in the defaultRequestPolicyFactories and returns\n   * the requestPolicyFactories that will be used.\n   */\n  requestPolicyFactories?:\n    | RequestPolicyFactory[]\n    | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);\n  /**\n   * The HttpClient that will be used to send HTTP requests.\n   */\n  httpClient?: HttpClient;\n  /**\n   * The HttpPipelineLogger that can be used to debug RequestPolicies within the HTTP pipeline.\n   */\n  httpPipelineLogger?: HttpPipelineLogger;\n  /**\n   * If set to true, turn off the default retry policy.\n   */\n  noRetryPolicy?: boolean;\n  /**\n   * Gets or sets the retry timeout in seconds for AutomaticRPRegistration. Default value is 30.\n   */\n  rpRegistrationRetryTimeout?: number;\n  /**\n   * Whether or not to generate a client request ID header for each HTTP request.\n   */\n  generateClientRequestIdHeader?: boolean;\n  /**\n   * Whether to include credentials in CORS requests in the browser.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials for more information.\n   */\n  withCredentials?: boolean;\n  /**\n   * If specified, a GenerateRequestIdPolicy will be added to the HTTP pipeline that will add a\n   * header to all outgoing requests with this header name and a random UUID as the request ID.\n   */\n  clientRequestIdHeaderName?: string;\n  /**\n   * The content-types that will be associated with JSON or XML serialization.\n   */\n  deserializationContentTypes?: DeserializationContentTypes;\n  /**\n   * The header name to use for the telemetry header while sending the request. If this is not\n   * specified, then \"User-Agent\" will be used when running on Node.js and \"x-ms-useragent\" will\n   * be used when running in a browser.\n   */\n  userAgentHeaderName?: string | ((defaultUserAgentHeaderName: string) => string);\n  /**\n   * The string to be set to the telemetry header while sending the request, or a function that\n   * takes in the default user-agent string and returns the user-agent string that will be used.\n   */\n  userAgent?: string | ((defaultUserAgent: string) => string);\n  /**\n   * Proxy settings which will be used for every HTTP request (Node.js only).\n   */\n  proxySettings?: ProxySettings;\n  /**\n   * If specified, will be used to build the BearerTokenAuthenticationPolicy.\n   */\n  credentialScopes?: string | string[];\n}\n\n/**\n * ServiceClient sends service requests and receives responses.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  protected baseUri?: string;\n\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  protected requestContentType?: string;\n\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  private readonly _httpClient: HttpClient;\n  private readonly _requestPolicyOptions: RequestPolicyOptions;\n\n  private readonly _requestPolicyFactories: RequestPolicyFactory[];\n  private readonly _withCredentials: boolean;\n\n  /**\n   * The ServiceClient constructor\n   * @param credentials - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(\n    credentials?: TokenCredential | ServiceClientCredentials,\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: ServiceClientOptions\n  ) {\n    if (!options) {\n      options = {};\n    }\n\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n\n    let requestPolicyFactories: RequestPolicyFactory[];\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      let authPolicyFactory: RequestPolicyFactory | undefined = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\n          \"ServiceClient: creating bearer token authentication policy from provided credentials\"\n        );\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        const wrappedPolicyFactory: () => RequestPolicyFactory = () => {\n          let bearerTokenPolicyFactory: RequestPolicyFactory | undefined = undefined;\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const serviceClient = this;\n          const serviceClientOptions = options;\n          return {\n            create(nextPolicy: RequestPolicy, createOptions: RequestPolicyOptions): RequestPolicy {\n              const credentialScopes = getCredentialScopes(\n                serviceClientOptions,\n                serviceClient.baseUri\n              );\n\n              if (!credentialScopes) {\n                throw new Error(\n                  `When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`\n                );\n              }\n\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(\n                  credentials,\n                  credentialScopes\n                );\n              }\n\n              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n            },\n          };\n        };\n\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        const newRequestPolicyFactories: void | RequestPolicyFactory[] =\n          options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n\n  /**\n   * Send the provided httpRequest.\n   */\n  sendRequest(options: RequestPrepareOptions | WebResourceLike): Promise<HttpOperationResponse> {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n\n    let httpRequest: WebResourceLike;\n    try {\n      if (isWebResourceLike(options)) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error: any) {\n      return Promise.reject(error);\n    }\n\n    let httpPipeline: RequestPolicy = this._httpClient;\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(\n          httpPipeline,\n          this._requestPolicyOptions\n        );\n      }\n    }\n    return httpPipeline.sendRequest(httpRequest);\n  }\n\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   * @param callback - The callback to call when the response is received.\n   */\n  async sendOperationRequest(\n    operationArguments: OperationArguments,\n    operationSpec: OperationSpec,\n    callback?: ServiceCallback<any>\n  ): Promise<RestResponse> {\n    if (typeof operationArguments.options === \"function\") {\n      callback = operationArguments.options;\n      operationArguments.options = undefined;\n    }\n\n    const serializerOptions = operationArguments.options?.serializerOptions;\n    const httpRequest: WebResourceLike = new WebResource();\n\n    let result: Promise<RestResponse>;\n    try {\n      const baseUri: string | undefined = operationSpec.baseUrl || this.baseUri;\n      if (!baseUri) {\n        throw new Error(\n          \"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\"\n        );\n      }\n\n      httpRequest.method = operationSpec.httpMethod;\n      httpRequest.operationSpec = operationSpec;\n\n      const requestUrl: URLBuilder = URLBuilder.parse(baseUri);\n      if (operationSpec.path) {\n        requestUrl.appendPath(operationSpec.path);\n      }\n      if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n        for (const urlParameter of operationSpec.urlParameters) {\n          let urlParameterValue: string = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            urlParameter,\n            operationSpec.serializer\n          );\n          urlParameterValue = operationSpec.serializer.serialize(\n            urlParameter.mapper,\n            urlParameterValue,\n            getPathStringFromParameter(urlParameter),\n            serializerOptions\n          );\n          if (!urlParameter.skipEncoding) {\n            urlParameterValue = encodeURIComponent(urlParameterValue);\n          }\n          requestUrl.replaceAll(\n            `{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`,\n            urlParameterValue\n          );\n        }\n      }\n      if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n        for (const queryParameter of operationSpec.queryParameters) {\n          let queryParameterValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            queryParameter,\n            operationSpec.serializer\n          );\n          if (queryParameterValue !== undefined && queryParameterValue !== null) {\n            queryParameterValue = operationSpec.serializer.serialize(\n              queryParameter.mapper,\n              queryParameterValue,\n              getPathStringFromParameter(queryParameter),\n              serializerOptions\n            );\n            if (\n              queryParameter.collectionFormat !== undefined &&\n              queryParameter.collectionFormat !== null\n            ) {\n              if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                if (queryParameterValue.length === 0) {\n                  // The collection is empty, no need to try serializing the current queryParam\n                  continue;\n                } else {\n                  for (const index in queryParameterValue) {\n                    const item = queryParameterValue[index];\n                    queryParameterValue[index] =\n                      item === undefined || item === null ? \"\" : item.toString();\n                  }\n                }\n              } else if (\n                queryParameter.collectionFormat === QueryCollectionFormat.Ssv ||\n                queryParameter.collectionFormat === QueryCollectionFormat.Tsv\n              ) {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n            }\n            if (!queryParameter.skipEncoding) {\n              if (Array.isArray(queryParameterValue)) {\n                for (const index in queryParameterValue) {\n                  if (\n                    queryParameterValue[index] !== undefined &&\n                    queryParameterValue[index] !== null\n                  ) {\n                    queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                  }\n                }\n              } else {\n                queryParameterValue = encodeURIComponent(queryParameterValue);\n              }\n            }\n            if (\n              queryParameter.collectionFormat !== undefined &&\n              queryParameter.collectionFormat !== null &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Multi &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Ssv &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Tsv\n            ) {\n              queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n            }\n            requestUrl.setQueryParameter(\n              queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter),\n              queryParameterValue\n            );\n          }\n        }\n      }\n      httpRequest.url = requestUrl.toString();\n\n      const contentType = operationSpec.contentType || this.requestContentType;\n      if (contentType && operationSpec.requestBody) {\n        httpRequest.headers.set(\"Content-Type\", contentType);\n      }\n\n      if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n          let headerValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            headerParameter,\n            operationSpec.serializer\n          );\n          if (headerValue !== undefined && headerValue !== null) {\n            headerValue = operationSpec.serializer.serialize(\n              headerParameter.mapper,\n              headerValue,\n              getPathStringFromParameter(headerParameter),\n              serializerOptions\n            );\n            const headerCollectionPrefix = (headerParameter.mapper as DictionaryMapper)\n              .headerCollectionPrefix;\n            if (headerCollectionPrefix) {\n              for (const key of Object.keys(headerValue)) {\n                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n              }\n            } else {\n              httpRequest.headers.set(\n                headerParameter.mapper.serializedName ||\n                  getPathStringFromParameter(headerParameter),\n                headerValue\n              );\n            }\n          }\n        }\n      }\n\n      const options: RequestOptionsBase | undefined = operationArguments.options;\n      if (options) {\n        if (options.customHeaders) {\n          for (const customHeaderName in options.customHeaders) {\n            httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n          }\n        }\n\n        if (options.abortSignal) {\n          httpRequest.abortSignal = options.abortSignal;\n        }\n\n        if (options.timeout) {\n          httpRequest.timeout = options.timeout;\n        }\n\n        if (options.onUploadProgress) {\n          httpRequest.onUploadProgress = options.onUploadProgress;\n        }\n\n        if (options.onDownloadProgress) {\n          httpRequest.onDownloadProgress = options.onDownloadProgress;\n        }\n\n        if (options.spanOptions) {\n          // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.\n          (httpRequest as any).spanOptions = options.spanOptions;\n        }\n\n        if (options.tracingContext) {\n          httpRequest.tracingContext = options.tracingContext;\n        }\n\n        if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n          httpRequest.shouldDeserialize = options.shouldDeserialize;\n        }\n      }\n\n      httpRequest.withCredentials = this._withCredentials;\n\n      serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n\n      if (httpRequest.streamResponseStatusCodes === undefined) {\n        httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n      }\n\n      let rawResponse: HttpOperationResponse;\n      let sendRequestError;\n      try {\n        rawResponse = await this.sendRequest(httpRequest);\n      } catch (error: any) {\n        sendRequestError = error;\n      }\n      if (sendRequestError) {\n        if (sendRequestError.response) {\n          sendRequestError.details = flattenResponse(\n            sendRequestError.response,\n            operationSpec.responses[sendRequestError.statusCode] ||\n              operationSpec.responses[\"default\"]\n          );\n        }\n        result = Promise.reject(sendRequestError);\n      } else {\n        result = Promise.resolve(\n          flattenResponse(rawResponse!, operationSpec.responses[rawResponse!.status])\n        );\n      }\n    } catch (error: any) {\n      result = Promise.reject(error);\n    }\n\n    const cb = callback;\n    if (cb) {\n      result\n        .then((res) => cb(null, res._response.parsedBody, res._response.request, res._response))\n        .catch((err) => cb(err));\n    }\n\n    return result;\n  }\n}\n\nexport function serializeRequestBody(\n  serviceClient: ServiceClient,\n  httpRequest: WebResourceLike,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec\n): void {\n  const serializerOptions = operationArguments.options?.serializerOptions ?? {};\n  const updatedOptions: Required<SerializerOptions> = {\n    rootName: serializerOptions.rootName ?? \"\",\n    includeRoot: serializerOptions.includeRoot ?? false,\n    xmlCharKey: serializerOptions.xmlCharKey ?? XML_CHARKEY,\n  };\n\n  const xmlCharKey = serializerOptions.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(\n      serviceClient,\n      operationArguments,\n      operationSpec.requestBody,\n      operationSpec.serializer\n    );\n\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const { required, xmlName, xmlElementName, serializedName, xmlNamespace, xmlNamespacePrefix } =\n      bodyMapper;\n    const typeName = bodyMapper.type.name;\n\n    try {\n      if ((httpRequest.body !== undefined && httpRequest.body !== null) || required) {\n        const requestBodyParameterPathString: string = getPathStringFromParameter(\n          operationSpec.requestBody\n        );\n        httpRequest.body = operationSpec.serializer.serialize(\n          bodyMapper,\n          httpRequest.body,\n          requestBodyParameterPathString,\n          updatedOptions\n        );\n\n        const isStream = typeName === MapperType.Stream;\n\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(\n            xmlNamespace,\n            xmlnsKey,\n            typeName,\n            httpRequest.body,\n            updatedOptions\n          );\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(\n              utils.prepareXMLRootList(\n                value,\n                xmlElementName || xmlName || serializedName!,\n                xmlnsKey,\n                xmlNamespace\n              ),\n              {\n                rootName: xmlName || serializedName,\n                xmlCharKey,\n              }\n            );\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey,\n            });\n          }\n        } else if (\n          typeName === MapperType.String &&\n          (operationSpec.contentType?.match(\"text/plain\") || operationSpec.mediaType === \"text\")\n        ) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error: any) {\n      throw new Error(\n        `Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(\n          serializedName,\n          undefined,\n          \"  \"\n        )}.`\n      );\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue: any = getOperationArgumentValueFromParameter(\n        serviceClient,\n        operationArguments,\n        formDataParameter,\n        operationSpec.serializer\n      );\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName: string =\n          formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(\n          formDataParameter.mapper,\n          formDataParameterValue,\n          getPathStringFromParameter(formDataParameter),\n          updatedOptions\n        );\n      }\n    }\n  }\n}\n\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(\n  xmlNamespace: string | undefined,\n  xmlnsKey: string,\n  typeName: string,\n  serializedValue: any,\n  options: Required<SerializerOptions>\n): any {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result: any = {};\n    result[options.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n    return result;\n  }\n\n  return serializedValue;\n}\n\nfunction getValueOrFunctionResult(\n  value: undefined | string | ((defaultValue: string) => string),\n  defaultValueCreator: () => string\n): string {\n  let result: string;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\n\nfunction createDefaultRequestPolicyFactories(\n  authPolicyFactory: RequestPolicyFactory | undefined,\n  options: ServiceClientOptions\n): RequestPolicyFactory[] {\n  const factories: RequestPolicyFactory[] = [];\n\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n\n  const userAgentHeaderName: string = getValueOrFunctionResult(\n    options.userAgentHeaderName,\n    getDefaultUserAgentHeaderName\n  );\n  const userAgentHeaderValue: string = getValueOrFunctionResult(\n    options.userAgent,\n    getDefaultUserAgentValue\n  );\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n\n  factories.push(logPolicy({ logger: logger.info }));\n\n  return factories;\n}\n\n/**\n * Creates an HTTP pipeline based on the given options.\n * @param pipelineOptions - Defines options that are used to configure policies in the HTTP pipeline for an SDK client.\n * @param authPolicyFactory - An optional authentication policy factory to use for signing requests.\n * @returns A set of options that can be passed to create a new {@link ServiceClient}.\n */\nexport function createPipelineFromOptions(\n  pipelineOptions: InternalPipelineOptions,\n  authPolicyFactory?: RequestPolicyFactory\n): ServiceClientOptions {\n  const requestPolicyFactories: RequestPolicyFactory[] = [];\n\n  if (pipelineOptions.sendStreamingJson) {\n    requestPolicyFactories.push(ndJsonPolicy());\n  }\n\n  let userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    const userAgentInfo: string[] = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    const defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n\n  const keepAliveOptions = {\n    ...DefaultKeepAliveOptions,\n    ...pipelineOptions.keepAliveOptions,\n  };\n\n  const retryOptions = {\n    ...DefaultRetryOptions,\n    ...pipelineOptions.retryOptions,\n  };\n\n  const redirectOptions = {\n    ...DefaultRedirectOptions,\n    ...pipelineOptions.redirectOptions,\n  };\n\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n\n  const deserializationOptions = {\n    ...DefaultDeserializationOptions,\n    ...pipelineOptions.deserializationOptions,\n  };\n\n  const loggingOptions: LogPolicyOptions = {\n    ...pipelineOptions.loggingOptions,\n  };\n\n  requestPolicyFactories.push(\n    tracingPolicy({ userAgent: userAgentValue }),\n    keepAlivePolicy(keepAliveOptions),\n    userAgentPolicy({ value: userAgentValue }),\n    generateClientRequestIdPolicy(),\n    deserializationPolicy(deserializationOptions.expectedContentTypes),\n    throttlingRetryPolicy(),\n    systemErrorRetryPolicy(),\n    exponentialRetryPolicy(\n      retryOptions.maxRetries,\n      retryOptions.retryDelayInMs,\n      retryOptions.maxRetryDelayInMs\n    )\n  );\n\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories,\n  };\n}\n\nexport type PropertyParent = { [propertyName: string]: any };\n\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent: PropertyParent, propertyPath: string[]): PropertyParent {\n  if (parent && propertyPath) {\n    const propertyPathLength: number = propertyPath.length;\n    for (let i = 0; i < propertyPathLength - 1; ++i) {\n      const propertyName: string = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\n\nfunction getOperationArgumentValueFromParameter(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameter: OperationParameter,\n  serializer: Serializer\n): any {\n  return getOperationArgumentValueFromParameterPath(\n    serviceClient,\n    operationArguments,\n    parameter.parameterPath,\n    parameter.mapper,\n    serializer\n  );\n}\n\nexport function getOperationArgumentValueFromParameterPath(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameterPath: ParameterPath,\n  parameterMapper: Mapper,\n  serializer: Serializer\n): any {\n  let value: any;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  const serializerOptions = operationArguments.options?.serializerOptions;\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult: PropertySearchResult = getPropertyFromParameterPath(\n          operationArguments,\n          parameterPath\n        );\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n\n        let useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue =\n            parameterMapper.required ||\n            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n\n      // Serialize just for validation purposes.\n      const parameterPathString: string = getPathStringFromParameterPath(\n        parameterPath,\n        parameterMapper\n      );\n      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (const propertyName in parameterPath) {\n      const propertyMapper: Mapper = (parameterMapper as CompositeMapper).type.modelProperties![\n        propertyName\n      ];\n      const propertyPath: ParameterPath = parameterPath[propertyName];\n      const propertyValue: any = getOperationArgumentValueFromParameterPath(\n        serviceClient,\n        operationArguments,\n        propertyPath,\n        propertyMapper,\n        serializer\n      );\n      // Serialize just for validation purposes.\n      const propertyPathString: string = getPathStringFromParameterPath(\n        propertyPath,\n        propertyMapper\n      );\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\n\ninterface PropertySearchResult {\n  propertyValue?: any;\n  propertyFound: boolean;\n}\n\nfunction getPropertyFromParameterPath(\n  parent: { [parameterName: string]: any },\n  parameterPath: string[]\n): PropertySearchResult {\n  const result: PropertySearchResult = { propertyFound: false };\n  let i = 0;\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart: string = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n\n/**\n * Parses an {@link HttpOperationResponse} into a normalized HTTP response object ({@link RestResponse}).\n * @param _response - Wrapper object for http response.\n * @param responseSpec - Mappers for how to parse the response properties.\n * @returns - A normalized response object.\n */\nexport function flattenResponse(\n  _response: HttpOperationResponse,\n  responseSpec: OperationResponse | undefined\n): RestResponse {\n  const parsedHeaders = _response.parsedHeaders;\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n\n  const addOperationResponse = <T extends Record<string, unknown>>(\n    obj: T\n  ): T & {\n    _response: HttpOperationResponse;\n  } => {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response,\n    }) as T & {\n      _response: HttpOperationResponse;\n    };\n  };\n\n  if (bodyMapper) {\n    const typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody,\n      });\n    }\n\n    const modelProperties =\n      (typeName === \"Composite\" && (bodyMapper as CompositeMapper).type.modelProperties) || {};\n    const isPageableResponse = Object.keys(modelProperties).some(\n      (k) => modelProperties[k].serializedName === \"\"\n    );\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      const arrayResponse = [...(_response.parsedBody || [])] as RestResponse & any[];\n\n      for (const key of Object.keys(modelProperties)) {\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n\n      if (parsedHeaders) {\n        for (const key of Object.keys(parsedHeaders)) {\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        ..._response.parsedBody,\n      });\n    }\n  }\n\n  if (\n    bodyMapper ||\n    _response.request.method === \"HEAD\" ||\n    utils.isPrimitiveType(_response.parsedBody)\n  ) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse({\n      ...parsedHeaders,\n      body: _response.parsedBody,\n    });\n  }\n\n  return addOperationResponse({\n    ...parsedHeaders,\n    ..._response.parsedBody,\n  });\n}\n\nfunction getCredentialScopes(\n  options?: ServiceClientOptions,\n  baseUri?: string\n): string | string[] | undefined {\n  if (options?.credentialScopes) {\n    return options.credentialScopes;\n  }\n\n  if (baseUri) {\n    return `${baseUri}/.default`;\n  }\n  return undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}