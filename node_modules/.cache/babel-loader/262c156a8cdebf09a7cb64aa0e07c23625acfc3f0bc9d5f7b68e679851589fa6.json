{"ast":null,"code":"import _defineProperty from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { isTokenCredential, isNode, getDefaultProxySettings } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { Container, Service } from \"./generated/src/operations\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { ContainerClient } from \"./ContainerClient\";\nimport { appendToURLPath, appendToURLQuery, extractConnectionStringParts, toTags } from \"./utils/utils.common\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport \"@azure/core-paging\";\nimport { truncatedISO8061Date } from \"./utils/utils.common\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\nimport { StorageClient } from \"./StorageClient\";\nimport { AccountSASPermissions } from \"./sas/AccountSASPermissions\";\nimport { generateAccountSASQueryParameters } from \"./sas/AccountSASSignatureValues\";\nimport { AccountSASServices } from \"./sas/AccountSASServices\";\n/**\n * A BlobServiceClient represents a Client to the Azure Storage Blob service allowing you\n * to manipulate blob containers.\n */\nexport var BlobServiceClient = /*#__PURE__*/function (_StorageClient) {\n  _inherits(BlobServiceClient, _StorageClient);\n  var _super = _createSuper(BlobServiceClient);\n  function BlobServiceClient(url, credentialOrPipeline,\n  // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    var _this;\n    _classCallCheck(this, BlobServiceClient);\n    var pipeline;\n    if (isPipelineLike(credentialOrPipeline)) {\n      pipeline = credentialOrPipeline;\n    } else if (isNode && credentialOrPipeline instanceof StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential || isTokenCredential(credentialOrPipeline)) {\n      pipeline = newPipeline(credentialOrPipeline, options);\n    } else {\n      // The second parameter is undefined. Use anonymous credential\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    }\n    _this = _super.call(this, url, pipeline);\n    _this.serviceContext = new Service(_this.storageClientContext);\n    return _this;\n  }\n  /**\n   *\n   * Creates an instance of BlobServiceClient from connection string.\n   *\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  _createClass(BlobServiceClient, [{\n    key: \"getContainerClient\",\n    value:\n    /**\n     * Creates a {@link ContainerClient} object\n     *\n     * @param containerName - A container name\n     * @returns A new ContainerClient object for the given container name.\n     *\n     * Example usage:\n     *\n     * ```js\n     * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n     * ```\n     */\n    function getContainerClient(containerName) {\n      return new ContainerClient(appendToURLPath(this.url, encodeURIComponent(containerName)), this.pipeline);\n    }\n    /**\n     * Create a Blob container. @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n     *\n     * @param containerName - Name of the container to create.\n     * @param options - Options to configure Container Create operation.\n     * @returns Container creation response and the corresponding container client.\n     */\n  }, {\n    key: \"createContainer\",\n    value: function () {\n      var _createContainer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(containerName) {\n        var options,\n          _createSpan,\n          span,\n          updatedOptions,\n          containerClient,\n          containerCreateResponse,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n              _createSpan = createSpan(\"BlobServiceClient-createContainer\", options), span = _createSpan.span, updatedOptions = _createSpan.updatedOptions;\n              _context.prev = 2;\n              containerClient = this.getContainerClient(containerName);\n              _context.next = 6;\n              return containerClient.create(updatedOptions);\n            case 6:\n              containerCreateResponse = _context.sent;\n              return _context.abrupt(\"return\", {\n                containerClient: containerClient,\n                containerCreateResponse: containerCreateResponse\n              });\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](2);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context.t0.message\n              });\n              throw _context.t0;\n            case 14:\n              _context.prev = 14;\n              span.end();\n              return _context.finish(14);\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[2, 10, 14, 17]]);\n      }));\n      function createContainer(_x) {\n        return _createContainer.apply(this, arguments);\n      }\n      return createContainer;\n    }()\n    /**\n     * Deletes a Blob container.\n     *\n     * @param containerName - Name of the container to delete.\n     * @param options - Options to configure Container Delete operation.\n     * @returns Container deletion response.\n     */\n  }, {\n    key: \"deleteContainer\",\n    value: function () {\n      var _deleteContainer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(containerName) {\n        var options,\n          _createSpan2,\n          span,\n          updatedOptions,\n          containerClient,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n              _createSpan2 = createSpan(\"BlobServiceClient-deleteContainer\", options), span = _createSpan2.span, updatedOptions = _createSpan2.updatedOptions;\n              _context2.prev = 2;\n              containerClient = this.getContainerClient(containerName);\n              _context2.next = 6;\n              return containerClient.delete(updatedOptions);\n            case 6:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](2);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context2.t0.message\n              });\n              throw _context2.t0;\n            case 13:\n              _context2.prev = 13;\n              span.end();\n              return _context2.finish(13);\n            case 16:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[2, 9, 13, 16]]);\n      }));\n      function deleteContainer(_x2) {\n        return _deleteContainer.apply(this, arguments);\n      }\n      return deleteContainer;\n    }()\n    /**\n     * Restore a previously deleted Blob container.\n     * This API is only functional if Container Soft Delete is enabled for the storage account associated with the container.\n     *\n     * @param deletedContainerName - Name of the previously deleted container.\n     * @param deletedContainerVersion - Version of the previously deleted container, used to uniquely identify the deleted container.\n     * @param options - Options to configure Container Restore operation.\n     * @returns Container deletion response.\n     */\n  }, {\n    key: \"undeleteContainer\",\n    value: function () {\n      var _undeleteContainer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(deletedContainerName, deletedContainerVersion) {\n        var options,\n          _createSpan3,\n          span,\n          updatedOptions,\n          containerClient,\n          containerContext,\n          containerUndeleteResponse,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};\n              _createSpan3 = createSpan(\"BlobServiceClient-undeleteContainer\", options), span = _createSpan3.span, updatedOptions = _createSpan3.updatedOptions;\n              _context3.prev = 2;\n              containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName); // Hack to access a protected member.\n              containerContext = new Container(containerClient[\"storageClientContext\"]);\n              _context3.next = 7;\n              return containerContext.restore(Object.assign({\n                deletedContainerName: deletedContainerName,\n                deletedContainerVersion: deletedContainerVersion\n              }, updatedOptions));\n            case 7:\n              containerUndeleteResponse = _context3.sent;\n              return _context3.abrupt(\"return\", {\n                containerClient: containerClient,\n                containerUndeleteResponse: containerUndeleteResponse\n              });\n            case 11:\n              _context3.prev = 11;\n              _context3.t0 = _context3[\"catch\"](2);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context3.t0.message\n              });\n              throw _context3.t0;\n            case 15:\n              _context3.prev = 15;\n              span.end();\n              return _context3.finish(15);\n            case 18:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[2, 11, 15, 18]]);\n      }));\n      function undeleteContainer(_x3, _x4) {\n        return _undeleteContainer.apply(this, arguments);\n      }\n      return undeleteContainer;\n    }()\n    /**\n     * Rename an existing Blob Container.\n     *\n     * @param sourceContainerName - The name of the source container.\n     * @param destinationContainerName - The new name of the container.\n     * @param options - Options to configure Container Rename operation.\n     */\n    /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n    // @ts-ignore Need to hide this interface for now. Make it public and turn on the live tests for it when the service is ready.\n  }, {\n    key: \"renameContainer\",\n    value: function () {\n      var _renameContainer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(sourceContainerName, destinationContainerName) {\n        var options,\n          _a,\n          _createSpan4,\n          span,\n          updatedOptions,\n          containerClient,\n          containerContext,\n          containerRenameResponse,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n              _createSpan4 = createSpan(\"BlobServiceClient-renameContainer\", options), span = _createSpan4.span, updatedOptions = _createSpan4.updatedOptions;\n              _context4.prev = 2;\n              containerClient = this.getContainerClient(destinationContainerName); // Hack to access a protected member.\n              containerContext = new Container(containerClient[\"storageClientContext\"]);\n              _context4.next = 7;\n              return containerContext.rename(sourceContainerName, Object.assign(Object.assign({}, updatedOptions), {\n                sourceLeaseId: (_a = options.sourceCondition) === null || _a === void 0 ? void 0 : _a.leaseId\n              }));\n            case 7:\n              containerRenameResponse = _context4.sent;\n              return _context4.abrupt(\"return\", {\n                containerClient: containerClient,\n                containerRenameResponse: containerRenameResponse\n              });\n            case 11:\n              _context4.prev = 11;\n              _context4.t0 = _context4[\"catch\"](2);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context4.t0.message\n              });\n              throw _context4.t0;\n            case 15:\n              _context4.prev = 15;\n              span.end();\n              return _context4.finish(15);\n            case 18:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[2, 11, 15, 18]]);\n      }));\n      function renameContainer(_x5, _x6) {\n        return _renameContainer.apply(this, arguments);\n      }\n      return renameContainer;\n    }()\n    /**\n     * Gets the properties of a storage account’s Blob service, including properties\n     * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n     *\n     * @param options - Options to the Service Get Properties operation.\n     * @returns Response data for the Service Get Properties operation.\n     */\n  }, {\n    key: \"getProperties\",\n    value: function () {\n      var _getProperties = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var options,\n          _createSpan5,\n          span,\n          updatedOptions,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              options = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};\n              _createSpan5 = createSpan(\"BlobServiceClient-getProperties\", options), span = _createSpan5.span, updatedOptions = _createSpan5.updatedOptions;\n              _context5.prev = 2;\n              _context5.next = 5;\n              return this.serviceContext.getProperties(Object.assign({\n                abortSignal: options.abortSignal\n              }, convertTracingToRequestOptionsBase(updatedOptions)));\n            case 5:\n              return _context5.abrupt(\"return\", _context5.sent);\n            case 8:\n              _context5.prev = 8;\n              _context5.t0 = _context5[\"catch\"](2);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context5.t0.message\n              });\n              throw _context5.t0;\n            case 12:\n              _context5.prev = 12;\n              span.end();\n              return _context5.finish(12);\n            case 15:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[2, 8, 12, 15]]);\n      }));\n      function getProperties() {\n        return _getProperties.apply(this, arguments);\n      }\n      return getProperties;\n    }()\n    /**\n     * Sets properties for a storage account’s Blob service endpoint, including properties\n     * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-service-properties\n     *\n     * @param properties -\n     * @param options - Options to the Service Set Properties operation.\n     * @returns Response data for the Service Set Properties operation.\n     */\n  }, {\n    key: \"setProperties\",\n    value: function () {\n      var _setProperties = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(properties) {\n        var options,\n          _createSpan6,\n          span,\n          updatedOptions,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n              _createSpan6 = createSpan(\"BlobServiceClient-setProperties\", options), span = _createSpan6.span, updatedOptions = _createSpan6.updatedOptions;\n              _context6.prev = 2;\n              _context6.next = 5;\n              return this.serviceContext.setProperties(properties, Object.assign({\n                abortSignal: options.abortSignal\n              }, convertTracingToRequestOptionsBase(updatedOptions)));\n            case 5:\n              return _context6.abrupt(\"return\", _context6.sent);\n            case 8:\n              _context6.prev = 8;\n              _context6.t0 = _context6[\"catch\"](2);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context6.t0.message\n              });\n              throw _context6.t0;\n            case 12:\n              _context6.prev = 12;\n              span.end();\n              return _context6.finish(12);\n            case 15:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[2, 8, 12, 15]]);\n      }));\n      function setProperties(_x7) {\n        return _setProperties.apply(this, arguments);\n      }\n      return setProperties;\n    }()\n    /**\n     * Retrieves statistics related to replication for the Blob service. It is only\n     * available on the secondary location endpoint when read-access geo-redundant\n     * replication is enabled for the storage account.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-stats\n     *\n     * @param options - Options to the Service Get Statistics operation.\n     * @returns Response data for the Service Get Statistics operation.\n     */\n  }, {\n    key: \"getStatistics\",\n    value: function () {\n      var _getStatistics = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var options,\n          _createSpan7,\n          span,\n          updatedOptions,\n          _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              options = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};\n              _createSpan7 = createSpan(\"BlobServiceClient-getStatistics\", options), span = _createSpan7.span, updatedOptions = _createSpan7.updatedOptions;\n              _context7.prev = 2;\n              _context7.next = 5;\n              return this.serviceContext.getStatistics(Object.assign({\n                abortSignal: options.abortSignal\n              }, convertTracingToRequestOptionsBase(updatedOptions)));\n            case 5:\n              return _context7.abrupt(\"return\", _context7.sent);\n            case 8:\n              _context7.prev = 8;\n              _context7.t0 = _context7[\"catch\"](2);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context7.t0.message\n              });\n              throw _context7.t0;\n            case 12:\n              _context7.prev = 12;\n              span.end();\n              return _context7.finish(12);\n            case 15:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[2, 8, 12, 15]]);\n      }));\n      function getStatistics() {\n        return _getStatistics.apply(this, arguments);\n      }\n      return getStatistics;\n    }()\n    /**\n     * The Get Account Information operation returns the sku name and account kind\n     * for the specified account.\n     * The Get Account Information operation is available on service versions beginning\n     * with version 2018-03-28.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-account-information\n     *\n     * @param options - Options to the Service Get Account Info operation.\n     * @returns Response data for the Service Get Account Info operation.\n     */\n  }, {\n    key: \"getAccountInfo\",\n    value: function () {\n      var _getAccountInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var options,\n          _createSpan8,\n          span,\n          updatedOptions,\n          _args8 = arguments;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              options = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};\n              _createSpan8 = createSpan(\"BlobServiceClient-getAccountInfo\", options), span = _createSpan8.span, updatedOptions = _createSpan8.updatedOptions;\n              _context8.prev = 2;\n              _context8.next = 5;\n              return this.serviceContext.getAccountInfo(Object.assign({\n                abortSignal: options.abortSignal\n              }, convertTracingToRequestOptionsBase(updatedOptions)));\n            case 5:\n              return _context8.abrupt(\"return\", _context8.sent);\n            case 8:\n              _context8.prev = 8;\n              _context8.t0 = _context8[\"catch\"](2);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context8.t0.message\n              });\n              throw _context8.t0;\n            case 12:\n              _context8.prev = 12;\n              span.end();\n              return _context8.finish(12);\n            case 15:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[2, 8, 12, 15]]);\n      }));\n      function getAccountInfo() {\n        return _getAccountInfo.apply(this, arguments);\n      }\n      return getAccountInfo;\n    }()\n    /**\n     * Returns a list of the containers under the specified account.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-containers2\n     *\n     * @param marker - A string value that identifies the portion of\n     *                        the list of containers to be returned with the next listing operation. The\n     *                        operation returns the continuationToken value within the response body if the\n     *                        listing operation did not return all containers remaining to be listed\n     *                        with the current page. The continuationToken value can be used as the value for\n     *                        the marker parameter in a subsequent call to request the next page of list\n     *                        items. The marker value is opaque to the client.\n     * @param options - Options to the Service List Container Segment operation.\n     * @returns Response data for the Service List Container Segment operation.\n     */\n  }, {\n    key: \"listContainersSegment\",\n    value: function () {\n      var _listContainersSegment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(marker) {\n        var options,\n          _createSpan9,\n          span,\n          updatedOptions,\n          _args9 = arguments;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};\n              _createSpan9 = createSpan(\"BlobServiceClient-listContainersSegment\", options), span = _createSpan9.span, updatedOptions = _createSpan9.updatedOptions;\n              _context9.prev = 2;\n              _context9.next = 5;\n              return this.serviceContext.listContainersSegment(Object.assign(Object.assign(Object.assign({\n                abortSignal: options.abortSignal,\n                marker: marker\n              }, options), {\n                include: typeof options.include === \"string\" ? [options.include] : options.include\n              }), convertTracingToRequestOptionsBase(updatedOptions)));\n            case 5:\n              return _context9.abrupt(\"return\", _context9.sent);\n            case 8:\n              _context9.prev = 8;\n              _context9.t0 = _context9[\"catch\"](2);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context9.t0.message\n              });\n              throw _context9.t0;\n            case 12:\n              _context9.prev = 12;\n              span.end();\n              return _context9.finish(12);\n            case 15:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[2, 8, 12, 15]]);\n      }));\n      function listContainersSegment(_x8) {\n        return _listContainersSegment.apply(this, arguments);\n      }\n      return listContainersSegment;\n    }()\n    /**\n     * The Filter Blobs operation enables callers to list blobs across all containers whose tags\n     * match a given search expression. Filter blobs searches across all containers within a\n     * storage account but can be scoped within the expression to a single container.\n     *\n     * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.\n     *                                        The given expression must evaluate to true for a blob to be returned in the results.\n     *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n     *                                        however, only a subset of the OData filter syntax is supported in the Blob service.\n     * @param marker - A string value that identifies the portion of\n     *                          the list of blobs to be returned with the next listing operation. The\n     *                          operation returns the continuationToken value within the response body if the\n     *                          listing operation did not return all blobs remaining to be listed\n     *                          with the current page. The continuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of list\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to find blobs by tags.\n     */\n  }, {\n    key: \"findBlobsByTagsSegment\",\n    value: function () {\n      var _findBlobsByTagsSegment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(tagFilterSqlExpression, marker) {\n        var options,\n          _createSpan10,\n          span,\n          updatedOptions,\n          response,\n          wrappedResponse,\n          _args10 = arguments;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              options = _args10.length > 2 && _args10[2] !== undefined ? _args10[2] : {};\n              _createSpan10 = createSpan(\"BlobServiceClient-findBlobsByTagsSegment\", options), span = _createSpan10.span, updatedOptions = _createSpan10.updatedOptions;\n              _context10.prev = 2;\n              _context10.next = 5;\n              return this.serviceContext.filterBlobs(Object.assign({\n                abortSignal: options.abortSignal,\n                where: tagFilterSqlExpression,\n                marker: marker,\n                maxPageSize: options.maxPageSize\n              }, convertTracingToRequestOptionsBase(updatedOptions)));\n            case 5:\n              response = _context10.sent;\n              wrappedResponse = Object.assign(Object.assign({}, response), {\n                _response: response._response,\n                blobs: response.blobs.map(function (blob) {\n                  var _a;\n                  var tagValue = \"\";\n                  if (((_a = blob.tags) === null || _a === void 0 ? void 0 : _a.blobTagSet.length) === 1) {\n                    tagValue = blob.tags.blobTagSet[0].value;\n                  }\n                  return Object.assign(Object.assign({}, blob), {\n                    tags: toTags(blob.tags),\n                    tagValue: tagValue\n                  });\n                })\n              });\n              return _context10.abrupt(\"return\", wrappedResponse);\n            case 10:\n              _context10.prev = 10;\n              _context10.t0 = _context10[\"catch\"](2);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context10.t0.message\n              });\n              throw _context10.t0;\n            case 14:\n              _context10.prev = 14;\n              span.end();\n              return _context10.finish(14);\n            case 17:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this, [[2, 10, 14, 17]]);\n      }));\n      function findBlobsByTagsSegment(_x9, _x10) {\n        return _findBlobsByTagsSegment.apply(this, arguments);\n      }\n      return findBlobsByTagsSegment;\n    }()\n    /**\n     * Returns an AsyncIterableIterator for ServiceFindBlobsByTagsSegmentResponse.\n     *\n     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n     *                                         The given expression must evaluate to true for a blob to be returned in the results.\n     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n     * @param marker - A string value that identifies the portion of\n     *                          the list of blobs to be returned with the next listing operation. The\n     *                          operation returns the continuationToken value within the response body if the\n     *                          listing operation did not return all blobs remaining to be listed\n     *                          with the current page. The continuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of list\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to find blobs by tags.\n     */\n  }, {\n    key: \"findBlobsByTagsSegments\",\n    value: function findBlobsByTagsSegments(tagFilterSqlExpression, marker) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function findBlobsByTagsSegments_1() {\n        var response;\n        return _regeneratorRuntime().wrap(function findBlobsByTagsSegments_1$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              if (!(!!marker || marker === undefined)) {\n                _context11.next = 11;\n                break;\n              }\n            case 1:\n              _context11.next = 3;\n              return __await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options));\n            case 3:\n              response = _context11.sent;\n              response.blobs = response.blobs || [];\n              marker = response.continuationToken;\n              _context11.next = 8;\n              return __await(response);\n            case 8:\n              _context11.next = 10;\n              return _context11.sent;\n            case 10:\n              if (marker) {\n                _context11.next = 1;\n                break;\n              }\n            case 11:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, findBlobsByTagsSegments_1, this);\n      }));\n    }\n    /**\n     * Returns an AsyncIterableIterator for blobs.\n     *\n     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n     *                                         The given expression must evaluate to true for a blob to be returned in the results.\n     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n     * @param options - Options to findBlobsByTagsItems.\n     */\n  }, {\n    key: \"findBlobsByTagsItems\",\n    value: function findBlobsByTagsItems(tagFilterSqlExpression) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function findBlobsByTagsItems_1() {\n        var e_1, _a, marker, _b, _c, segment;\n        return _regeneratorRuntime().wrap(function findBlobsByTagsItems_1$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.prev = 0;\n              _b = __asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options));\n            case 2:\n              _context12.next = 4;\n              return __await(_b.next());\n            case 4:\n              _c = _context12.sent;\n              if (_c.done) {\n                _context12.next = 14;\n                break;\n              }\n              segment = _c.value;\n              _context12.t0 = __await;\n              return _context12.delegateYield(__asyncDelegator(__asyncValues(segment.blobs)), \"t1\", 9);\n            case 9:\n              _context12.t2 = _context12.t1;\n              _context12.next = 12;\n              return (0, _context12.t0)(_context12.t2);\n            case 12:\n              _context12.next = 2;\n              break;\n            case 14:\n              _context12.next = 19;\n              break;\n            case 16:\n              _context12.prev = 16;\n              _context12.t3 = _context12[\"catch\"](0);\n              e_1 = {\n                error: _context12.t3\n              };\n            case 19:\n              _context12.prev = 19;\n              _context12.prev = 20;\n              if (!(_c && !_c.done && (_a = _b.return))) {\n                _context12.next = 24;\n                break;\n              }\n              _context12.next = 24;\n              return __await(_a.call(_b));\n            case 24:\n              _context12.prev = 24;\n              if (!e_1) {\n                _context12.next = 27;\n                break;\n              }\n              throw e_1.error;\n            case 27:\n              return _context12.finish(24);\n            case 28:\n              return _context12.finish(19);\n            case 29:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, findBlobsByTagsItems_1, this, [[0, 16, 19, 29], [20,, 24, 28]]);\n      }));\n    }\n    /**\n     * Returns an async iterable iterator to find all blobs with specified tag\n     * under the specified account.\n     *\n     * .byPage() returns an async iterable iterator to list the blobs in pages.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * let i = 1;\n     * for await (const blob of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\")) {\n     *   console.log(`Blob ${i++}: ${container.name}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * const iter = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\");\n     * let blobItem = await iter.next();\n     * while (!blobItem.done) {\n     *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n     *   blobItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 20 })) {\n     *   if (response.blobs) {\n     *     for (const blob of response.blobs) {\n     *       console.log(`Blob ${i++}: ${blob.name}`);\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 blob names\n     * if (response.blobs) {\n     *   for (const blob of response.blobs) {\n     *     console.log(`Blob ${i++}: ${blob.name}`);\n     *   }\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     * // Passing next marker as continuationToken\n     * iterator = blobServiceClient\n     *   .findBlobsByTags(\"tagkey='tagvalue'\")\n     *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints blob names\n     * if (response.blobs) {\n     *   for (const blob of response.blobs) {\n     *      console.log(`Blob ${i++}: ${blob.name}`);\n     *   }\n     * }\n     * ```\n     *\n     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n     *                                         The given expression must evaluate to true for a blob to be returned in the results.\n     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n     * @param options - Options to find blobs by tags.\n     */\n  }, {\n    key: \"findBlobsByTags\",\n    value: function findBlobsByTags(tagFilterSqlExpression) {\n      var _this2 = this,\n        _ref;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // AsyncIterableIterator to iterate over blobs\n      var listSegmentOptions = Object.assign({}, options);\n      var iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);\n      return _ref = {\n        /**\n         * The next method, part of the iteration protocol\n         */\n        next: function next() {\n          return iter.next();\n        }\n      }, _defineProperty(_ref, Symbol.asyncIterator, function () {\n        return this;\n      }), _defineProperty(_ref, \"byPage\", function byPage() {\n        var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return _this2.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, listSegmentOptions));\n      }), _ref;\n    }\n    /**\n     * Returns an AsyncIterableIterator for ServiceListContainersSegmentResponses\n     *\n     * @param marker - A string value that identifies the portion of\n     *                        the list of containers to be returned with the next listing operation. The\n     *                        operation returns the continuationToken value within the response body if the\n     *                        listing operation did not return all containers remaining to be listed\n     *                        with the current page. The continuationToken value can be used as the value for\n     *                        the marker parameter in a subsequent call to request the next page of list\n     *                        items. The marker value is opaque to the client.\n     * @param options - Options to list containers operation.\n     */\n  }, {\n    key: \"listSegments\",\n    value: function listSegments(marker) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function listSegments_1() {\n        var listContainersSegmentResponse;\n        return _regeneratorRuntime().wrap(function listSegments_1$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              if (!(!!marker || marker === undefined)) {\n                _context13.next = 15;\n                break;\n              }\n            case 1:\n              _context13.next = 3;\n              return __await(this.listContainersSegment(marker, options));\n            case 3:\n              listContainersSegmentResponse = _context13.sent;\n              listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];\n              marker = listContainersSegmentResponse.continuationToken;\n              _context13.t0 = __await;\n              _context13.next = 9;\n              return __await(listContainersSegmentResponse);\n            case 9:\n              _context13.t1 = _context13.sent;\n              _context13.next = 12;\n              return (0, _context13.t0)(_context13.t1);\n            case 12:\n              _context13.next = 14;\n              return _context13.sent;\n            case 14:\n              if (marker) {\n                _context13.next = 1;\n                break;\n              }\n            case 15:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, listSegments_1, this);\n      }));\n    }\n    /**\n     * Returns an AsyncIterableIterator for Container Items\n     *\n     * @param options - Options to list containers operation.\n     */\n  }, {\n    key: \"listItems\",\n    value: function listItems() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function listItems_1() {\n        var e_2, _a, marker, _b, _c, segment;\n        return _regeneratorRuntime().wrap(function listItems_1$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              _context14.prev = 0;\n              _b = __asyncValues(this.listSegments(marker, options));\n            case 2:\n              _context14.next = 4;\n              return __await(_b.next());\n            case 4:\n              _c = _context14.sent;\n              if (_c.done) {\n                _context14.next = 14;\n                break;\n              }\n              segment = _c.value;\n              _context14.t0 = __await;\n              return _context14.delegateYield(__asyncDelegator(__asyncValues(segment.containerItems)), \"t1\", 9);\n            case 9:\n              _context14.t2 = _context14.t1;\n              _context14.next = 12;\n              return (0, _context14.t0)(_context14.t2);\n            case 12:\n              _context14.next = 2;\n              break;\n            case 14:\n              _context14.next = 19;\n              break;\n            case 16:\n              _context14.prev = 16;\n              _context14.t3 = _context14[\"catch\"](0);\n              e_2 = {\n                error: _context14.t3\n              };\n            case 19:\n              _context14.prev = 19;\n              _context14.prev = 20;\n              if (!(_c && !_c.done && (_a = _b.return))) {\n                _context14.next = 24;\n                break;\n              }\n              _context14.next = 24;\n              return __await(_a.call(_b));\n            case 24:\n              _context14.prev = 24;\n              if (!e_2) {\n                _context14.next = 27;\n                break;\n              }\n              throw e_2.error;\n            case 27:\n              return _context14.finish(24);\n            case 28:\n              return _context14.finish(19);\n            case 29:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, listItems_1, this, [[0, 16, 19, 29], [20,, 24, 28]]);\n      }));\n    }\n    /**\n     * Returns an async iterable iterator to list all the containers\n     * under the specified account.\n     *\n     * .byPage() returns an async iterable iterator to list the containers in pages.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * let i = 1;\n     * for await (const container of blobServiceClient.listContainers()) {\n     *   console.log(`Container ${i++}: ${container.name}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * const iter = blobServiceClient.listContainers();\n     * let containerItem = await iter.next();\n     * while (!containerItem.done) {\n     *   console.log(`Container ${i++}: ${containerItem.value.name}`);\n     *   containerItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of blobServiceClient.listContainers().byPage({ maxPageSize: 20 })) {\n     *   if (response.containerItems) {\n     *     for (const container of response.containerItems) {\n     *       console.log(`Container ${i++}: ${container.name}`);\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = blobServiceClient.listContainers().byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 container names\n     * if (response.containerItems) {\n     *   for (const container of response.containerItems) {\n     *     console.log(`Container ${i++}: ${container.name}`);\n     *   }\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     * // Passing next marker as continuationToken\n     * iterator = blobServiceClient\n     *   .listContainers()\n     *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints 10 container names\n     * if (response.containerItems) {\n     *   for (const container of response.containerItems) {\n     *      console.log(`Container ${i++}: ${container.name}`);\n     *   }\n     * }\n     * ```\n     *\n     * @param options - Options to list containers.\n     * @returns An asyncIterableIterator that supports paging.\n     */\n  }, {\n    key: \"listContainers\",\n    value: function listContainers() {\n      var _this3 = this,\n        _ref2;\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (options.prefix === \"\") {\n        options.prefix = undefined;\n      }\n      var include = [];\n      if (options.includeDeleted) {\n        include.push(\"deleted\");\n      }\n      if (options.includeMetadata) {\n        include.push(\"metadata\");\n      }\n      if (options.includeSystem) {\n        include.push(\"system\");\n      }\n      // AsyncIterableIterator to iterate over containers\n      var listSegmentOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {\n        include: include\n      } : {});\n      var iter = this.listItems(listSegmentOptions);\n      return _ref2 = {\n        /**\n         * The next method, part of the iteration protocol\n         */\n        next: function next() {\n          return iter.next();\n        }\n      }, _defineProperty(_ref2, Symbol.asyncIterator, function () {\n        return this;\n      }), _defineProperty(_ref2, \"byPage\", function byPage() {\n        var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return _this3.listSegments(settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, listSegmentOptions));\n      }), _ref2;\n    }\n    /**\n     * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).\n     *\n     * Retrieves a user delegation key for the Blob service. This is only a valid operation when using\n     * bearer token authentication.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-user-delegation-key\n     *\n     * @param startsOn -      The start time for the user delegation SAS. Must be within 7 days of the current time\n     * @param expiresOn -     The end time for the user delegation SAS. Must be within 7 days of the current time\n     */\n  }, {\n    key: \"getUserDelegationKey\",\n    value: function () {\n      var _getUserDelegationKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(startsOn, expiresOn) {\n        var options,\n          _createSpan11,\n          span,\n          updatedOptions,\n          response,\n          userDelegationKey,\n          res,\n          _args15 = arguments;\n        return _regeneratorRuntime().wrap(function _callee11$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              options = _args15.length > 2 && _args15[2] !== undefined ? _args15[2] : {};\n              _createSpan11 = createSpan(\"BlobServiceClient-getUserDelegationKey\", options), span = _createSpan11.span, updatedOptions = _createSpan11.updatedOptions;\n              _context15.prev = 2;\n              _context15.next = 5;\n              return this.serviceContext.getUserDelegationKey({\n                startsOn: truncatedISO8061Date(startsOn, false),\n                expiresOn: truncatedISO8061Date(expiresOn, false)\n              }, Object.assign({\n                abortSignal: options.abortSignal\n              }, convertTracingToRequestOptionsBase(updatedOptions)));\n            case 5:\n              response = _context15.sent;\n              userDelegationKey = {\n                signedObjectId: response.signedObjectId,\n                signedTenantId: response.signedTenantId,\n                signedStartsOn: new Date(response.signedStartsOn),\n                signedExpiresOn: new Date(response.signedExpiresOn),\n                signedService: response.signedService,\n                signedVersion: response.signedVersion,\n                value: response.value\n              };\n              res = Object.assign({\n                _response: response._response,\n                requestId: response.requestId,\n                clientRequestId: response.clientRequestId,\n                version: response.version,\n                date: response.date,\n                errorCode: response.errorCode\n              }, userDelegationKey);\n              return _context15.abrupt(\"return\", res);\n            case 11:\n              _context15.prev = 11;\n              _context15.t0 = _context15[\"catch\"](2);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context15.t0.message\n              });\n              throw _context15.t0;\n            case 15:\n              _context15.prev = 15;\n              span.end();\n              return _context15.finish(15);\n            case 18:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee11, this, [[2, 11, 15, 18]]);\n      }));\n      function getUserDelegationKey(_x11, _x12) {\n        return _getUserDelegationKey.apply(this, arguments);\n      }\n      return getUserDelegationKey;\n    }()\n    /**\n     * Creates a BlobBatchClient object to conduct batch operations.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch\n     *\n     * @returns A new BlobBatchClient object for this service.\n     */\n  }, {\n    key: \"getBlobBatchClient\",\n    value: function getBlobBatchClient() {\n      return new BlobBatchClient(this.url, this.pipeline);\n    }\n    /**\n     * Only available for BlobServiceClient constructed with a shared key credential.\n     *\n     * Generates a Blob account Shared Access Signature (SAS) URI based on the client properties\n     * and parameters passed in. The SAS is signed by the shared key credential of the client.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-account-sas\n     *\n     * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.\n     * @param permissions - Specifies the list of permissions to be associated with the SAS.\n     * @param resourceTypes - Specifies the resource types associated with the shared access signature.\n     * @param options - Optional parameters.\n     * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n     */\n  }, {\n    key: \"generateAccountSasUrl\",\n    value: function generateAccountSasUrl(expiresOn) {\n      var permissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AccountSASPermissions.parse(\"r\");\n      var resourceTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"sco\";\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      if (!(this.credential instanceof StorageSharedKeyCredential)) {\n        throw RangeError(\"Can only generate the account SAS when the client is initialized with a shared key credential\");\n      }\n      if (expiresOn === undefined) {\n        var now = new Date();\n        expiresOn = new Date(now.getTime() + 3600 * 1000);\n      }\n      var sas = generateAccountSASQueryParameters(Object.assign({\n        permissions: permissions,\n        expiresOn: expiresOn,\n        resourceTypes: resourceTypes,\n        services: AccountSASServices.parse(\"b\").toString()\n      }, options), this.credential).toString();\n      return appendToURLQuery(this.url, sas);\n    }\n  }], [{\n    key: \"fromConnectionString\",\n    value: function fromConnectionString(connectionString,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options) {\n      options = options || {};\n      var extractedCreds = extractConnectionStringParts(connectionString);\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n          var pipeline = newPipeline(sharedKeyCredential, options);\n          return new BlobServiceClient(extractedCreds.url, pipeline);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        var _pipeline = newPipeline(new AnonymousCredential(), options);\n        return new BlobServiceClient(extractedCreds.url + \"?\" + extractedCreds.accountSas, _pipeline);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    }\n  }]);\n  return BlobServiceClient;\n}(StorageClient);","map":{"version":3,"names":["isTokenCredential","isNode","getDefaultProxySettings","SpanStatusCode","Container","Service","newPipeline","isPipelineLike","ContainerClient","appendToURLPath","appendToURLQuery","extractConnectionStringParts","toTags","StorageSharedKeyCredential","AnonymousCredential","truncatedISO8061Date","convertTracingToRequestOptionsBase","createSpan","BlobBatchClient","StorageClient","AccountSASPermissions","generateAccountSASQueryParameters","AccountSASServices","BlobServiceClient","_StorageClient","_inherits","_super","_createSuper","url","credentialOrPipeline","options","_this","_classCallCheck","pipeline","call","serviceContext","storageClientContext","_createClass","key","value","getContainerClient","containerName","encodeURIComponent","_createContainer","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_createSpan","span","updatedOptions","containerClient","containerCreateResponse","_args","arguments","wrap","_callee$","_context","prev","next","length","undefined","create","sent","abrupt","t0","setStatus","code","ERROR","message","end","finish","stop","createContainer","_x","apply","_deleteContainer","_callee2","_createSpan2","_args2","_callee2$","_context2","delete","deleteContainer","_x2","_undeleteContainer","_callee3","deletedContainerName","deletedContainerVersion","_createSpan3","containerContext","containerUndeleteResponse","_args3","_callee3$","_context3","destinationContainerName","restore","Object","assign","undeleteContainer","_x3","_x4","_renameContainer","_callee4","sourceContainerName","_a","_createSpan4","containerRenameResponse","_args4","_callee4$","_context4","rename","sourceLeaseId","sourceCondition","leaseId","renameContainer","_x5","_x6","_getProperties","_callee5","_createSpan5","_args5","_callee5$","_context5","getProperties","abortSignal","_setProperties","_callee6","properties","_createSpan6","_args6","_callee6$","_context6","setProperties","_x7","_getStatistics","_callee7","_createSpan7","_args7","_callee7$","_context7","getStatistics","_getAccountInfo","_callee8","_createSpan8","_args8","_callee8$","_context8","getAccountInfo","_listContainersSegment","_callee9","marker","_createSpan9","_args9","_callee9$","_context9","listContainersSegment","include","_x8","_findBlobsByTagsSegment","_callee10","tagFilterSqlExpression","_createSpan10","response","wrappedResponse","_args10","_callee10$","_context10","filterBlobs","where","maxPageSize","_response","blobs","map","blob","tagValue","tags","blobTagSet","findBlobsByTagsSegment","_x9","_x10","findBlobsByTagsSegments","_context11","__await","continuationToken","findBlobsByTagsItems","_b","__asyncValues","_context12","_c","done","segment","delegateYield","__asyncDelegator","t2","t1","t3","findBlobsByTags","_this2","_ref","listSegmentOptions","iter","_defineProperty","Symbol","asyncIterator","byPage","settings","listSegments","_context13","listContainersSegmentResponse","containerItems","listItems","_context14","listContainers","_this3","_ref2","prefix","includeDeleted","push","includeMetadata","includeSystem","_getUserDelegationKey","_callee11","startsOn","expiresOn","_createSpan11","userDelegationKey","res","_args15","_callee11$","_context15","getUserDelegationKey","signedObjectId","signedTenantId","signedStartsOn","Date","signedExpiresOn","signedService","signedVersion","requestId","clientRequestId","version","date","errorCode","_x11","_x12","getBlobBatchClient","generateAccountSasUrl","permissions","parse","resourceTypes","credential","RangeError","now","getTime","sas","services","toString","fromConnectionString","connectionString","extractedCreds","kind","sharedKeyCredential","accountName","accountKey","proxyOptions","proxyUri","Error","accountSas"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\storage-blob\\src\\BlobServiceClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport {\n  TokenCredential,\n  isTokenCredential,\n  isNode,\n  HttpResponse,\n  getDefaultProxySettings,\n} from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  ServiceGetUserDelegationKeyHeaders,\n  ContainerCreateResponse,\n  ContainerDeleteResponse,\n  ServiceGetPropertiesResponse,\n  BlobServiceProperties,\n  ServiceSetPropertiesResponse,\n  ServiceGetStatisticsResponse,\n  ServiceGetAccountInfoResponse,\n  ServiceListContainersSegmentResponse,\n  ContainerItem,\n  UserDelegationKeyModel,\n  ContainerUndeleteResponse,\n  FilterBlobSegmentModel,\n  ServiceFilterBlobsHeaders,\n  ContainerRenameResponse,\n  LeaseAccessConditions,\n  FilterBlobSegment,\n  FilterBlobItem,\n} from \"./generatedModels\";\nimport { Container, Service } from \"./generated/src/operations\";\nimport { newPipeline, StoragePipelineOptions, PipelineLike, isPipelineLike } from \"./Pipeline\";\nimport {\n  ContainerClient,\n  ContainerCreateOptions,\n  ContainerDeleteMethodOptions,\n} from \"./ContainerClient\";\nimport {\n  appendToURLPath,\n  appendToURLQuery,\n  extractConnectionStringParts,\n  toTags,\n} from \"./utils/utils.common\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { truncatedISO8061Date } from \"./utils/utils.common\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\nimport { CommonOptions, StorageClient } from \"./StorageClient\";\nimport { AccountSASPermissions } from \"./sas/AccountSASPermissions\";\nimport { SASProtocol } from \"./sas/SASQueryParameters\";\nimport { SasIPRange } from \"./sas/SasIPRange\";\nimport { generateAccountSASQueryParameters } from \"./sas/AccountSASSignatureValues\";\nimport { AccountSASServices } from \"./sas/AccountSASServices\";\nimport { ListContainersIncludeType } from \"./generated/src\";\n\n/**\n * Options to configure the {@link BlobServiceClient.getProperties} operation.\n */\nexport interface ServiceGetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.setProperties} operation.\n */\nexport interface ServiceSetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.getAccountInfo} operation.\n */\nexport interface ServiceGetAccountInfoOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.getStatistics} operation.\n */\nexport interface ServiceGetStatisticsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the Service - Get User Delegation Key.\n */\nexport interface ServiceGetUserDelegationKeyOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.listContainerSegment} operation.\n */\ninterface ServiceListContainersSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Filters the results to return only containers\n   * whose name begins with the specified prefix.\n   */\n  prefix?: string;\n  /**\n   * Specifies the maximum number of containers\n   * to return. If the request does not specify maxPageSize, or specifies a\n   * value greater than 5000, the server will return up to 5000 items. Note\n   * that if the listing operation crosses a partition boundary, then the\n   * service will return a continuation token for retrieving the remainder of\n   * the results. For this reason, it is possible that the service will return\n   * fewer results than specified by maxPageSize, or than the default of 5000.\n   */\n  maxPageSize?: number;\n  /**\n   * Include this parameter to\n   * specify that the container's metadata be returned as part of the response\n   * body. Possible values include: 'metadata'\n   */\n  include?: ListContainersIncludeType | ListContainersIncludeType[];\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.listContainers} operation.\n */\nexport interface ServiceListContainersOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Filters the results to return only containers\n   * whose name begins with the specified prefix.\n   */\n  prefix?: string;\n  /**\n   * Specifies whether the container's metadata\n   *                                   should be returned as part of the response body.\n   */\n  includeMetadata?: boolean;\n\n  /**\n   * Specifies whether soft deleted containers should be included in the response.\n   */\n  includeDeleted?: boolean;\n  /**\n   * Specifies whether system containers should be included in the response.\n   */\n  includeSystem?: boolean;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.findBlobsByTagsSegment} operation.\n */\ninterface ServiceFindBlobsByTagsSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies the maximum number of blobs\n   * to return. If the request does not specify maxPageSize, or specifies a\n   * value greater than 5000, the server will return up to 5000 items. Note\n   * that if the listing operation crosses a partition boundary, then the\n   * service will return a continuation token for retrieving the remainder of\n   * the results. For this reason, it is possible that the service will return\n   * fewer results than specified by maxPageSize, or than the default of 5000.\n   */\n  maxPageSize?: number;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.findBlobsByTags} operation.\n */\nexport interface ServiceFindBlobByTagsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * The response of {@link BlobServiceClient.findBlobsByTags} operation.\n */\nexport type ServiceFindBlobsByTagsSegmentResponse = FilterBlobSegment &\n  ServiceFilterBlobsHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: ServiceFilterBlobsHeaders;\n\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: FilterBlobSegmentModel;\n    };\n  };\n\n/**\n * A user delegation key.\n */\nexport interface UserDelegationKey {\n  /**\n   * The Azure Active Directory object ID in GUID format.\n   */\n  signedObjectId: string;\n  /**\n   * The Azure Active Directory tenant ID in GUID format.\n   */\n  signedTenantId: string;\n  /**\n   * The date-time the key is active.\n   */\n  signedStartsOn: Date;\n  /**\n   * The date-time the key expires.\n   */\n  signedExpiresOn: Date;\n  /**\n   * Abbreviation of the Azure Storage service that accepts the key.\n   */\n  signedService: string;\n  /**\n   * The service version that created the key.\n   */\n  signedVersion: string;\n  /**\n   * The key as a base64 string.\n   */\n  value: string;\n}\n\n/**\n * Contains response data for the {@link getUserDelegationKey} operation.\n */\nexport declare type ServiceGetUserDelegationKeyResponse = UserDelegationKey &\n  ServiceGetUserDelegationKeyHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: ServiceGetUserDelegationKeyHeaders;\n\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: UserDelegationKeyModel;\n    };\n  };\n\n/**\n * Options to configure {@link BlobServiceClient.undeleteContainer} operation.\n */\nexport interface ServiceUndeleteContainerOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Optional. Specifies the new name of the restored container.\n   * Will use its original name if this is not specified.\n   * @deprecated Restore container to a different name is not supported by service anymore.\n   */\n  destinationContainerName?: string;\n}\n\n/**\n * Options to configure {@link BlobServiceClient.renameContainer} operation.\n */\nexport interface ServiceRenameContainerOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Condition to meet for the source container.\n   */\n  sourceCondition?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure {@link BlobServiceClient.generateAccountSasUrl} operation.\n */\nexport interface ServiceGenerateAccountSasUrlOptions {\n  /**\n   * The version of the service this SAS will target. If not specified, it will default to the version targeted by the\n   * library.\n   */\n  version?: string;\n\n  /**\n   * Optional. SAS protocols allowed.\n   */\n  protocol?: SASProtocol;\n\n  /**\n   * Optional. When the SAS will take effect.\n   */\n  startsOn?: Date;\n  /**\n   * Optional. IP range allowed.\n   */\n  ipRange?: SasIPRange;\n  /**\n   * Optional. Encryption scope to use when sending requests authorized with this SAS URI.\n   */\n  encryptionScope?: string;\n}\n\n/**\n * A BlobServiceClient represents a Client to the Azure Storage Blob service allowing you\n * to manipulate blob containers.\n */\nexport class BlobServiceClient extends StorageClient {\n  /**\n   * serviceContext provided by protocol layer.\n   */\n  private serviceContext: Service;\n\n  /**\n   *\n   * Creates an instance of BlobServiceClient from connection string.\n   *\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  public static fromConnectionString(\n    connectionString: string,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  ): BlobServiceClient {\n    options = options || {};\n    const extractedCreds = extractConnectionStringParts(connectionString);\n    if (extractedCreds.kind === \"AccountConnString\") {\n      if (isNode) {\n        const sharedKeyCredential = new StorageSharedKeyCredential(\n          extractedCreds.accountName!,\n          extractedCreds.accountKey\n        );\n\n        if (!options.proxyOptions) {\n          options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n        }\n\n        const pipeline = newPipeline(sharedKeyCredential, options);\n        return new BlobServiceClient(extractedCreds.url, pipeline);\n      } else {\n        throw new Error(\"Account connection string is only supported in Node.js environment\");\n      }\n    } else if (extractedCreds.kind === \"SASConnString\") {\n      const pipeline = newPipeline(new AnonymousCredential(), options);\n      return new BlobServiceClient(extractedCreds.url + \"?\" + extractedCreds.accountSas, pipeline);\n    } else {\n      throw new Error(\n        \"Connection string must be either an Account connection string or a SAS connection string\"\n      );\n    }\n  }\n\n  /**\n   * Creates an instance of BlobServiceClient.\n   *\n   * @param url - A Client string pointing to Azure Storage blob service, such as\n   *                     \"https://myaccount.blob.core.windows.net\". You can append a SAS\n   *                     if using AnonymousCredential, such as \"https://myaccount.blob.core.windows.net?sasString\".\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   *\n   * Example using DefaultAzureCredential from `@azure/identity`:\n   *\n   * ```js\n   * const account = \"<storage account name>\";\n   *\n   * const defaultAzureCredential = new DefaultAzureCredential();\n   *\n   * const blobServiceClient = new BlobServiceClient(\n   *   `https://${account}.blob.core.windows.net`,\n   *   defaultAzureCredential\n   * );\n   * ```\n   *\n   * Example using an account name/key:\n   *\n   * ```js\n   * const account = \"<storage account name>\"\n   * const sharedKeyCredential = new StorageSharedKeyCredential(account, \"<account key>\");\n   *\n   * const blobServiceClient = new BlobServiceClient(\n   *   `https://${account}.blob.core.windows.net`,\n   *   sharedKeyCredential\n   * );\n   * ```\n   */\n  constructor(\n    url: string,\n    credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  );\n  /**\n   * Creates an instance of BlobServiceClient.\n   *\n   * @param url - A Client string pointing to Azure Storage blob service, such as\n   *                     \"https://myaccount.blob.core.windows.net\". You can append a SAS\n   *                     if using AnonymousCredential, such as \"https://myaccount.blob.core.windows.net?sasString\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  constructor(url: string, pipeline: PipelineLike);\n  constructor(\n    url: string,\n    credentialOrPipeline?:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | PipelineLike,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  ) {\n    let pipeline: PipelineLike;\n    if (isPipelineLike(credentialOrPipeline)) {\n      pipeline = credentialOrPipeline;\n    } else if (\n      (isNode && credentialOrPipeline instanceof StorageSharedKeyCredential) ||\n      credentialOrPipeline instanceof AnonymousCredential ||\n      isTokenCredential(credentialOrPipeline)\n    ) {\n      pipeline = newPipeline(credentialOrPipeline, options);\n    } else {\n      // The second parameter is undefined. Use anonymous credential\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    }\n    super(url, pipeline);\n    this.serviceContext = new Service(this.storageClientContext);\n  }\n\n  /**\n   * Creates a {@link ContainerClient} object\n   *\n   * @param containerName - A container name\n   * @returns A new ContainerClient object for the given container name.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n   * ```\n   */\n  public getContainerClient(containerName: string): ContainerClient {\n    return new ContainerClient(\n      appendToURLPath(this.url, encodeURIComponent(containerName)),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Create a Blob container. @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param containerName - Name of the container to create.\n   * @param options - Options to configure Container Create operation.\n   * @returns Container creation response and the corresponding container client.\n   */\n  public async createContainer(\n    containerName: string,\n    options: ContainerCreateOptions = {}\n  ): Promise<{\n    containerClient: ContainerClient;\n    containerCreateResponse: ContainerCreateResponse;\n  }> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-createContainer\", options);\n    try {\n      const containerClient = this.getContainerClient(containerName);\n      const containerCreateResponse = await containerClient.create(updatedOptions);\n      return {\n        containerClient,\n        containerCreateResponse,\n      };\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes a Blob container.\n   *\n   * @param containerName - Name of the container to delete.\n   * @param options - Options to configure Container Delete operation.\n   * @returns Container deletion response.\n   */\n  public async deleteContainer(\n    containerName: string,\n    options: ContainerDeleteMethodOptions = {}\n  ): Promise<ContainerDeleteResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-deleteContainer\", options);\n    try {\n      const containerClient = this.getContainerClient(containerName);\n      return await containerClient.delete(updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Restore a previously deleted Blob container.\n   * This API is only functional if Container Soft Delete is enabled for the storage account associated with the container.\n   *\n   * @param deletedContainerName - Name of the previously deleted container.\n   * @param deletedContainerVersion - Version of the previously deleted container, used to uniquely identify the deleted container.\n   * @param options - Options to configure Container Restore operation.\n   * @returns Container deletion response.\n   */\n  public async undeleteContainer(\n    deletedContainerName: string,\n    deletedContainerVersion: string,\n    options: ServiceUndeleteContainerOptions = {}\n  ): Promise<{\n    containerClient: ContainerClient;\n    containerUndeleteResponse: ContainerUndeleteResponse;\n  }> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-undeleteContainer\", options);\n    try {\n      const containerClient = this.getContainerClient(\n        options.destinationContainerName || deletedContainerName\n      );\n      // Hack to access a protected member.\n      const containerContext = new Container(containerClient[\"storageClientContext\"]);\n      const containerUndeleteResponse = await containerContext.restore({\n        deletedContainerName,\n        deletedContainerVersion,\n        ...updatedOptions,\n      });\n      return { containerClient, containerUndeleteResponse };\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Rename an existing Blob Container.\n   *\n   * @param sourceContainerName - The name of the source container.\n   * @param destinationContainerName - The new name of the container.\n   * @param options - Options to configure Container Rename operation.\n   */\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n  // @ts-ignore Need to hide this interface for now. Make it public and turn on the live tests for it when the service is ready.\n  private async renameContainer(\n    sourceContainerName: string,\n    destinationContainerName: string,\n    options: ServiceRenameContainerOptions = {}\n  ): Promise<{\n    containerClient: ContainerClient;\n    containerRenameResponse: ContainerRenameResponse;\n  }> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-renameContainer\", options);\n    try {\n      const containerClient = this.getContainerClient(destinationContainerName);\n      // Hack to access a protected member.\n      const containerContext = new Container(containerClient[\"storageClientContext\"]);\n      const containerRenameResponse = await containerContext.rename(sourceContainerName, {\n        ...updatedOptions,\n        sourceLeaseId: options.sourceCondition?.leaseId,\n      });\n      return { containerClient, containerRenameResponse };\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Gets the properties of a storage account’s Blob service, including properties\n   * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n   *\n   * @param options - Options to the Service Get Properties operation.\n   * @returns Response data for the Service Get Properties operation.\n   */\n  public async getProperties(\n    options: ServiceGetPropertiesOptions = {}\n  ): Promise<ServiceGetPropertiesResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-getProperties\", options);\n    try {\n      return await this.serviceContext.getProperties({\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets properties for a storage account’s Blob service endpoint, including properties\n   * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-service-properties\n   *\n   * @param properties -\n   * @param options - Options to the Service Set Properties operation.\n   * @returns Response data for the Service Set Properties operation.\n   */\n  public async setProperties(\n    properties: BlobServiceProperties,\n    options: ServiceSetPropertiesOptions = {}\n  ): Promise<ServiceSetPropertiesResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-setProperties\", options);\n    try {\n      return await this.serviceContext.setProperties(properties, {\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves statistics related to replication for the Blob service. It is only\n   * available on the secondary location endpoint when read-access geo-redundant\n   * replication is enabled for the storage account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-stats\n   *\n   * @param options - Options to the Service Get Statistics operation.\n   * @returns Response data for the Service Get Statistics operation.\n   */\n  public async getStatistics(\n    options: ServiceGetStatisticsOptions = {}\n  ): Promise<ServiceGetStatisticsResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-getStatistics\", options);\n    try {\n      return await this.serviceContext.getStatistics({\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * The Get Account Information operation returns the sku name and account kind\n   * for the specified account.\n   * The Get Account Information operation is available on service versions beginning\n   * with version 2018-03-28.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-account-information\n   *\n   * @param options - Options to the Service Get Account Info operation.\n   * @returns Response data for the Service Get Account Info operation.\n   */\n  public async getAccountInfo(\n    options: ServiceGetAccountInfoOptions = {}\n  ): Promise<ServiceGetAccountInfoResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-getAccountInfo\", options);\n    try {\n      return await this.serviceContext.getAccountInfo({\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns a list of the containers under the specified account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-containers2\n   *\n   * @param marker - A string value that identifies the portion of\n   *                        the list of containers to be returned with the next listing operation. The\n   *                        operation returns the continuationToken value within the response body if the\n   *                        listing operation did not return all containers remaining to be listed\n   *                        with the current page. The continuationToken value can be used as the value for\n   *                        the marker parameter in a subsequent call to request the next page of list\n   *                        items. The marker value is opaque to the client.\n   * @param options - Options to the Service List Container Segment operation.\n   * @returns Response data for the Service List Container Segment operation.\n   */\n  private async listContainersSegment(\n    marker?: string,\n    options: ServiceListContainersSegmentOptions = {}\n  ): Promise<ServiceListContainersSegmentResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-listContainersSegment\", options);\n\n    try {\n      return await this.serviceContext.listContainersSegment({\n        abortSignal: options.abortSignal,\n        marker,\n        ...options,\n        include: typeof options.include === \"string\" ? [options.include] : options.include,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * The Filter Blobs operation enables callers to list blobs across all containers whose tags\n   * match a given search expression. Filter blobs searches across all containers within a\n   * storage account but can be scoped within the expression to a single container.\n   *\n   * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                        The given expression must evaluate to true for a blob to be returned in the results.\n   *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                        however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n  private async findBlobsByTagsSegment(\n    tagFilterSqlExpression: string,\n    marker?: string,\n    options: ServiceFindBlobsByTagsSegmentOptions = {}\n  ): Promise<ServiceFindBlobsByTagsSegmentResponse> {\n    const { span, updatedOptions } = createSpan(\n      \"BlobServiceClient-findBlobsByTagsSegment\",\n      options\n    );\n\n    try {\n      const response = await this.serviceContext.filterBlobs({\n        abortSignal: options.abortSignal,\n        where: tagFilterSqlExpression,\n        marker,\n        maxPageSize: options.maxPageSize,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n\n      const wrappedResponse: ServiceFindBlobsByTagsSegmentResponse = {\n        ...response,\n        _response: response._response, // _response is made non-enumerable\n        blobs: response.blobs.map((blob) => {\n          let tagValue = \"\";\n          if (blob.tags?.blobTagSet.length === 1) {\n            tagValue = blob.tags.blobTagSet[0].value;\n          }\n          return { ...blob, tags: toTags(blob.tags), tagValue };\n        }),\n      };\n      return wrappedResponse;\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for ServiceFindBlobsByTagsSegmentResponse.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n  private async *findBlobsByTagsSegments(\n    tagFilterSqlExpression: string,\n    marker?: string,\n    options: ServiceFindBlobsByTagsSegmentOptions = {}\n  ): AsyncIterableIterator<ServiceFindBlobsByTagsSegmentResponse> {\n    let response;\n    if (!!marker || marker === undefined) {\n      do {\n        response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options);\n        response.blobs = response.blobs || [];\n        marker = response.continuationToken;\n        yield response;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for blobs.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to findBlobsByTagsItems.\n   */\n  private async *findBlobsByTagsItems(\n    tagFilterSqlExpression: string,\n    options: ServiceFindBlobsByTagsSegmentOptions = {}\n  ): AsyncIterableIterator<FilterBlobItem> {\n    let marker: string | undefined;\n    for await (const segment of this.findBlobsByTagsSegments(\n      tagFilterSqlExpression,\n      marker,\n      options\n    )) {\n      yield* segment.blobs;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to find all blobs with specified tag\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs in pages.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const blob of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\")) {\n   *   console.log(`Blob ${i++}: ${container.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\");\n   * let blobItem = await iter.next();\n   * while (!blobItem.done) {\n   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n   *   blobItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 20 })) {\n   *   if (response.blobs) {\n   *     for (const blob of response.blobs) {\n   *       console.log(`Blob ${i++}: ${blob.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *     console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = blobServiceClient\n   *   .findBlobsByTags(\"tagkey='tagvalue'\")\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *      console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to find blobs by tags.\n   */\n  public findBlobsByTags(\n    tagFilterSqlExpression: string,\n    options: ServiceFindBlobByTagsOptions = {}\n  ): PagedAsyncIterableIterator<FilterBlobItem, ServiceFindBlobsByTagsSegmentResponse> {\n    // AsyncIterableIterator to iterate over blobs\n    const listSegmentOptions: ServiceFindBlobsByTagsSegmentOptions = {\n      ...options,\n    };\n\n    const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...listSegmentOptions,\n        });\n      },\n    };\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for ServiceListContainersSegmentResponses\n   *\n   * @param marker - A string value that identifies the portion of\n   *                        the list of containers to be returned with the next listing operation. The\n   *                        operation returns the continuationToken value within the response body if the\n   *                        listing operation did not return all containers remaining to be listed\n   *                        with the current page. The continuationToken value can be used as the value for\n   *                        the marker parameter in a subsequent call to request the next page of list\n   *                        items. The marker value is opaque to the client.\n   * @param options - Options to list containers operation.\n   */\n  private async *listSegments(\n    marker?: string,\n    options: ServiceListContainersSegmentOptions = {}\n  ): AsyncIterableIterator<ServiceListContainersSegmentResponse> {\n    let listContainersSegmentResponse;\n    if (!!marker || marker === undefined) {\n      do {\n        listContainersSegmentResponse = await this.listContainersSegment(marker, options);\n        listContainersSegmentResponse.containerItems =\n          listContainersSegmentResponse.containerItems || [];\n        marker = listContainersSegmentResponse.continuationToken;\n        yield await listContainersSegmentResponse;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for Container Items\n   *\n   * @param options - Options to list containers operation.\n   */\n  private async *listItems(\n    options: ServiceListContainersSegmentOptions = {}\n  ): AsyncIterableIterator<ContainerItem> {\n    let marker: string | undefined;\n    for await (const segment of this.listSegments(marker, options)) {\n      yield* segment.containerItems;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the containers\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the containers in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const container of blobServiceClient.listContainers()) {\n   *   console.log(`Container ${i++}: ${container.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = blobServiceClient.listContainers();\n   * let containerItem = await iter.next();\n   * while (!containerItem.done) {\n   *   console.log(`Container ${i++}: ${containerItem.value.name}`);\n   *   containerItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of blobServiceClient.listContainers().byPage({ maxPageSize: 20 })) {\n   *   if (response.containerItems) {\n   *     for (const container of response.containerItems) {\n   *       console.log(`Container ${i++}: ${container.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = blobServiceClient.listContainers().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 container names\n   * if (response.containerItems) {\n   *   for (const container of response.containerItems) {\n   *     console.log(`Container ${i++}: ${container.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = blobServiceClient\n   *   .listContainers()\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 container names\n   * if (response.containerItems) {\n   *   for (const container of response.containerItems) {\n   *      console.log(`Container ${i++}: ${container.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param options - Options to list containers.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listContainers(\n    options: ServiceListContainersOptions = {}\n  ): PagedAsyncIterableIterator<ContainerItem, ServiceListContainersSegmentResponse> {\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    const include: ListContainersIncludeType[] = [];\n    if (options.includeDeleted) {\n      include.push(\"deleted\");\n    }\n    if (options.includeMetadata) {\n      include.push(\"metadata\");\n    }\n    if (options.includeSystem) {\n      include.push(\"system\");\n    }\n\n    // AsyncIterableIterator to iterate over containers\n    const listSegmentOptions: ServiceListContainersSegmentOptions = {\n      ...options,\n      ...(include.length > 0 ? { include } : {}),\n    };\n\n    const iter = this.listItems(listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.listSegments(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...listSegmentOptions,\n        });\n      },\n    };\n  }\n\n  /**\n   * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).\n   *\n   * Retrieves a user delegation key for the Blob service. This is only a valid operation when using\n   * bearer token authentication.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-user-delegation-key\n   *\n   * @param startsOn -      The start time for the user delegation SAS. Must be within 7 days of the current time\n   * @param expiresOn -     The end time for the user delegation SAS. Must be within 7 days of the current time\n   */\n  public async getUserDelegationKey(\n    startsOn: Date,\n    expiresOn: Date,\n    options: ServiceGetUserDelegationKeyOptions = {}\n  ): Promise<ServiceGetUserDelegationKeyResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-getUserDelegationKey\", options);\n    try {\n      const response = await this.serviceContext.getUserDelegationKey(\n        {\n          startsOn: truncatedISO8061Date(startsOn, false),\n          expiresOn: truncatedISO8061Date(expiresOn, false),\n        },\n        {\n          abortSignal: options.abortSignal,\n          ...convertTracingToRequestOptionsBase(updatedOptions),\n        }\n      );\n\n      const userDelegationKey = {\n        signedObjectId: response.signedObjectId,\n        signedTenantId: response.signedTenantId,\n        signedStartsOn: new Date(response.signedStartsOn),\n        signedExpiresOn: new Date(response.signedExpiresOn),\n        signedService: response.signedService,\n        signedVersion: response.signedVersion,\n        value: response.value,\n      };\n\n      const res: ServiceGetUserDelegationKeyResponse = {\n        _response: response._response,\n        requestId: response.requestId,\n        clientRequestId: response.clientRequestId,\n        version: response.version,\n        date: response.date,\n        errorCode: response.errorCode,\n        ...userDelegationKey,\n      };\n\n      return res;\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a BlobBatchClient object to conduct batch operations.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch\n   *\n   * @returns A new BlobBatchClient object for this service.\n   */\n  public getBlobBatchClient(): BlobBatchClient {\n    return new BlobBatchClient(this.url, this.pipeline);\n  }\n\n  /**\n   * Only available for BlobServiceClient constructed with a shared key credential.\n   *\n   * Generates a Blob account Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-account-sas\n   *\n   * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.\n   * @param permissions - Specifies the list of permissions to be associated with the SAS.\n   * @param resourceTypes - Specifies the resource types associated with the shared access signature.\n   * @param options - Optional parameters.\n   * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateAccountSasUrl(\n    expiresOn?: Date,\n    permissions: AccountSASPermissions = AccountSASPermissions.parse(\"r\"),\n    resourceTypes: string = \"sco\",\n    options: ServiceGenerateAccountSasUrlOptions = {}\n  ): string {\n    if (!(this.credential instanceof StorageSharedKeyCredential)) {\n      throw RangeError(\n        \"Can only generate the account SAS when the client is initialized with a shared key credential\"\n      );\n    }\n\n    if (expiresOn === undefined) {\n      const now = new Date();\n      expiresOn = new Date(now.getTime() + 3600 * 1000);\n    }\n\n    const sas = generateAccountSASQueryParameters(\n      {\n        permissions,\n        expiresOn,\n        resourceTypes,\n        services: AccountSASServices.parse(\"b\").toString(),\n        ...options,\n      },\n      this.credential\n    ).toString();\n\n    return appendToURLQuery(this.url, sas);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}