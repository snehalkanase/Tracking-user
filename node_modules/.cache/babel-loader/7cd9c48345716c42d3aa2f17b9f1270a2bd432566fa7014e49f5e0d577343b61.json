{"ast":null,"code":"import _inherits from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy, deserializationPolicy, generateUuid, HttpHeaders, WebResource, isTokenCredential, bearerTokenAuthenticationPolicy, isNode } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { BlobClient } from \"./Clients\";\nimport { Mutex } from \"./utils/Mutex\";\nimport { Pipeline } from \"./Pipeline\";\nimport { attachCredential, getURLPath, getURLPathAndQuery, iEqual } from \"./utils/utils.common\";\nimport { HeaderConstants, BATCH_MAX_REQUEST, HTTP_VERSION_1_1, HTTP_LINE_ENDING, StorageOAuthScopes } from \"./utils/constants\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { createSpan } from \"./utils/tracing\";\n/**\n * A BlobBatch represents an aggregated set of operations on blobs.\n * Currently, only `delete` and `setAccessTier` are supported.\n */\nexport var BlobBatch = /*#__PURE__*/function () {\n  function BlobBatch() {\n    _classCallCheck(this, BlobBatch);\n    this.batch = \"batch\";\n    this.batchRequest = new InnerBatchRequest();\n  }\n  /**\n   * Get the value of Content-Type for a batch request.\n   * The value must be multipart/mixed with a batch boundary.\n   * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252\n   */\n  _createClass(BlobBatch, [{\n    key: \"getMultiPartContentType\",\n    value: function getMultiPartContentType() {\n      return this.batchRequest.getMultipartContentType();\n    }\n    /**\n     * Get assembled HTTP request body for sub requests.\n     */\n  }, {\n    key: \"getHttpRequestBody\",\n    value: function getHttpRequestBody() {\n      return this.batchRequest.getHttpRequestBody();\n    }\n    /**\n     * Get sub requests that are added into the batch request.\n     */\n  }, {\n    key: \"getSubRequests\",\n    value: function getSubRequests() {\n      return this.batchRequest.getSubRequests();\n    }\n  }, {\n    key: \"addSubRequestInternal\",\n    value: function () {\n      var _addSubRequestInternal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(subRequest, assembleSubRequestFunc) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Mutex.lock(this.batch);\n            case 2:\n              _context.prev = 2;\n              this.batchRequest.preAddSubRequest(subRequest);\n              _context.next = 6;\n              return assembleSubRequestFunc();\n            case 6:\n              this.batchRequest.postAddSubRequest(subRequest);\n            case 7:\n              _context.prev = 7;\n              _context.next = 10;\n              return Mutex.unlock(this.batch);\n            case 10:\n              return _context.finish(7);\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[2,, 7, 11]]);\n      }));\n      function addSubRequestInternal(_x, _x2) {\n        return _addSubRequestInternal.apply(this, arguments);\n      }\n      return addSubRequestInternal;\n    }()\n  }, {\n    key: \"setBatchType\",\n    value: function setBatchType(batchType) {\n      if (!this.batchType) {\n        this.batchType = batchType;\n      }\n      if (this.batchType !== batchType) {\n        throw new RangeError(\"BlobBatch only supports one operation type per batch and it already is being used for \".concat(this.batchType, \" operations.\"));\n      }\n    }\n  }, {\n    key: \"deleteBlob\",\n    value: function () {\n      var _deleteBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(urlOrBlobClient, credentialOrOptions, options) {\n        var _this = this;\n        var url, credential, _createSpan, span, updatedOptions;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(typeof urlOrBlobClient === \"string\" && (isNode && credentialOrOptions instanceof StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential || isTokenCredential(credentialOrOptions)))) {\n                _context3.next = 5;\n                break;\n              }\n              // First overload\n              url = urlOrBlobClient;\n              credential = credentialOrOptions;\n              _context3.next = 12;\n              break;\n            case 5:\n              if (!(urlOrBlobClient instanceof BlobClient)) {\n                _context3.next = 11;\n                break;\n              }\n              // Second overload\n              url = urlOrBlobClient.url;\n              credential = urlOrBlobClient.credential;\n              options = credentialOrOptions;\n              _context3.next = 12;\n              break;\n            case 11:\n              throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n            case 12:\n              if (!options) {\n                options = {};\n              }\n              _createSpan = createSpan(\"BatchDeleteRequest-addSubRequest\", options), span = _createSpan.span, updatedOptions = _createSpan.updatedOptions;\n              _context3.prev = 14;\n              this.setBatchType(\"delete\");\n              _context3.next = 18;\n              return this.addSubRequestInternal({\n                url: url,\n                credential: credential\n              }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                  while (1) switch (_context2.prev = _context2.next) {\n                    case 0:\n                      _context2.next = 2;\n                      return new BlobClient(url, _this.batchRequest.createPipeline(credential)).delete(updatedOptions);\n                    case 2:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }, _callee2);\n              })));\n            case 18:\n              _context3.next = 24;\n              break;\n            case 20:\n              _context3.prev = 20;\n              _context3.t0 = _context3[\"catch\"](14);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context3.t0.message\n              });\n              throw _context3.t0;\n            case 24:\n              _context3.prev = 24;\n              span.end();\n              return _context3.finish(24);\n            case 27:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[14, 20, 24, 27]]);\n      }));\n      function deleteBlob(_x3, _x4, _x5) {\n        return _deleteBlob.apply(this, arguments);\n      }\n      return deleteBlob;\n    }()\n  }, {\n    key: \"setBlobAccessTier\",\n    value: function () {\n      var _setBlobAccessTier = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {\n        var _this2 = this;\n        var url, credential, tier, _createSpan2, span, updatedOptions;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(typeof urlOrBlobClient === \"string\" && (isNode && credentialOrTier instanceof StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential || isTokenCredential(credentialOrTier)))) {\n                _context5.next = 6;\n                break;\n              }\n              // First overload\n              url = urlOrBlobClient;\n              credential = credentialOrTier;\n              tier = tierOrOptions;\n              _context5.next = 14;\n              break;\n            case 6:\n              if (!(urlOrBlobClient instanceof BlobClient)) {\n                _context5.next = 13;\n                break;\n              }\n              // Second overload\n              url = urlOrBlobClient.url;\n              credential = urlOrBlobClient.credential;\n              tier = credentialOrTier;\n              options = tierOrOptions;\n              _context5.next = 14;\n              break;\n            case 13:\n              throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n            case 14:\n              if (!options) {\n                options = {};\n              }\n              _createSpan2 = createSpan(\"BatchSetTierRequest-addSubRequest\", options), span = _createSpan2.span, updatedOptions = _createSpan2.updatedOptions;\n              _context5.prev = 16;\n              this.setBatchType(\"setAccessTier\");\n              _context5.next = 20;\n              return this.addSubRequestInternal({\n                url: url,\n                credential: credential\n              }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                  while (1) switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _context4.next = 2;\n                      return new BlobClient(url, _this2.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);\n                    case 2:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }, _callee4);\n              })));\n            case 20:\n              _context5.next = 26;\n              break;\n            case 22:\n              _context5.prev = 22;\n              _context5.t0 = _context5[\"catch\"](16);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: _context5.t0.message\n              });\n              throw _context5.t0;\n            case 26:\n              _context5.prev = 26;\n              span.end();\n              return _context5.finish(26);\n            case 29:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[16, 22, 26, 29]]);\n      }));\n      function setBlobAccessTier(_x6, _x7, _x8, _x9) {\n        return _setBlobAccessTier.apply(this, arguments);\n      }\n      return setBlobAccessTier;\n    }()\n  }]);\n  return BlobBatch;\n}();\n/**\n * Inner batch request class which is responsible for assembling and serializing sub requests.\n * See https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#request-body for how requests are assembled.\n */\nvar InnerBatchRequest = /*#__PURE__*/function () {\n  function InnerBatchRequest() {\n    _classCallCheck(this, InnerBatchRequest);\n    this.operationCount = 0;\n    this.body = \"\";\n    var tempGuid = generateUuid();\n    // batch_{batchid}\n    this.boundary = \"batch_\".concat(tempGuid);\n    // --batch_{batchid}\n    // Content-Type: application/http\n    // Content-Transfer-Encoding: binary\n    this.subRequestPrefix = \"--\".concat(this.boundary).concat(HTTP_LINE_ENDING).concat(HeaderConstants.CONTENT_TYPE, \": application/http\").concat(HTTP_LINE_ENDING).concat(HeaderConstants.CONTENT_TRANSFER_ENCODING, \": binary\");\n    // multipart/mixed; boundary=batch_{batchid}\n    this.multipartContentType = \"multipart/mixed; boundary=\".concat(this.boundary);\n    // --batch_{batchid}--\n    this.batchRequestEnding = \"--\".concat(this.boundary, \"--\");\n    this.subRequests = new Map();\n  }\n  /**\n   * Create pipeline to assemble sub requests. The idea here is to use existing\n   * credential and serialization/deserialization components, with additional policies to\n   * filter unnecessary headers, assemble sub requests into request's body\n   * and intercept request from going to wire.\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n  _createClass(InnerBatchRequest, [{\n    key: \"createPipeline\",\n    value: function createPipeline(credential) {\n      var isAnonymousCreds = credential instanceof AnonymousCredential;\n      var policyFactoryLength = 3 + (isAnonymousCreds ? 0 : 1); // [deserializationPolicy, BatchHeaderFilterPolicyFactory, (Optional)Credential, BatchRequestAssemblePolicyFactory]\n      var factories = new Array(policyFactoryLength);\n      factories[0] = deserializationPolicy(); // Default deserializationPolicy is provided by protocol layer\n      factories[1] = new BatchHeaderFilterPolicyFactory(); // Use batch header filter policy to exclude unnecessary headers\n      if (!isAnonymousCreds) {\n        factories[2] = isTokenCredential(credential) ? attachCredential(bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes), credential) : credential;\n      }\n      factories[policyFactoryLength - 1] = new BatchRequestAssemblePolicyFactory(this); // Use batch assemble policy to assemble request and intercept request from going to wire\n      return new Pipeline(factories, {});\n    }\n  }, {\n    key: \"appendSubRequestToBody\",\n    value: function appendSubRequestToBody(request) {\n      // Start to assemble sub request\n      this.body += [this.subRequestPrefix, \"\".concat(HeaderConstants.CONTENT_ID, \": \").concat(this.operationCount), \"\", \"\".concat(request.method.toString(), \" \").concat(getURLPathAndQuery(request.url), \" \").concat(HTTP_VERSION_1_1).concat(HTTP_LINE_ENDING) // sub request start line with method\n      ].join(HTTP_LINE_ENDING);\n      var _iterator = _createForOfIteratorHelper(request.headers.headersArray()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var header = _step.value;\n          this.body += \"\".concat(header.name, \": \").concat(header.value).concat(HTTP_LINE_ENDING);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.body += HTTP_LINE_ENDING; // sub request's headers need be ending with an empty line\n      // No body to assemble for current batch request support\n      // End to assemble sub request\n    }\n  }, {\n    key: \"preAddSubRequest\",\n    value: function preAddSubRequest(subRequest) {\n      if (this.operationCount >= BATCH_MAX_REQUEST) {\n        throw new RangeError(\"Cannot exceed \".concat(BATCH_MAX_REQUEST, \" sub requests in a single batch\"));\n      }\n      // Fast fail if url for sub request is invalid\n      var path = getURLPath(subRequest.url);\n      if (!path || path === \"\") {\n        throw new RangeError(\"Invalid url for sub request: '\".concat(subRequest.url, \"'\"));\n      }\n    }\n  }, {\n    key: \"postAddSubRequest\",\n    value: function postAddSubRequest(subRequest) {\n      this.subRequests.set(this.operationCount, subRequest);\n      this.operationCount++;\n    }\n    // Return the http request body with assembling the ending line to the sub request body.\n  }, {\n    key: \"getHttpRequestBody\",\n    value: function getHttpRequestBody() {\n      return \"\".concat(this.body).concat(this.batchRequestEnding).concat(HTTP_LINE_ENDING);\n    }\n  }, {\n    key: \"getMultipartContentType\",\n    value: function getMultipartContentType() {\n      return this.multipartContentType;\n    }\n  }, {\n    key: \"getSubRequests\",\n    value: function getSubRequests() {\n      return this.subRequests;\n    }\n  }]);\n  return InnerBatchRequest;\n}();\nvar BatchRequestAssemblePolicy = /*#__PURE__*/function (_BaseRequestPolicy) {\n  _inherits(BatchRequestAssemblePolicy, _BaseRequestPolicy);\n  var _super = _createSuper(BatchRequestAssemblePolicy);\n  function BatchRequestAssemblePolicy(batchRequest, nextPolicy, options) {\n    var _this3;\n    _classCallCheck(this, BatchRequestAssemblePolicy);\n    _this3 = _super.call(this, nextPolicy, options);\n    _this3.dummyResponse = {\n      request: new WebResource(),\n      status: 200,\n      headers: new HttpHeaders()\n    };\n    _this3.batchRequest = batchRequest;\n    return _this3;\n  }\n  _createClass(BatchRequestAssemblePolicy, [{\n    key: \"sendRequest\",\n    value: function () {\n      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this.batchRequest.appendSubRequestToBody(request);\n            case 2:\n              return _context6.abrupt(\"return\", this.dummyResponse);\n            case 3:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function sendRequest(_x10) {\n        return _sendRequest.apply(this, arguments);\n      }\n      return sendRequest;\n    }()\n  }]);\n  return BatchRequestAssemblePolicy;\n}(BaseRequestPolicy);\nvar BatchRequestAssemblePolicyFactory = /*#__PURE__*/function () {\n  function BatchRequestAssemblePolicyFactory(batchRequest) {\n    _classCallCheck(this, BatchRequestAssemblePolicyFactory);\n    this.batchRequest = batchRequest;\n  }\n  _createClass(BatchRequestAssemblePolicyFactory, [{\n    key: \"create\",\n    value: function create(nextPolicy, options) {\n      return new BatchRequestAssemblePolicy(this.batchRequest, nextPolicy, options);\n    }\n  }]);\n  return BatchRequestAssemblePolicyFactory;\n}();\nvar BatchHeaderFilterPolicy = /*#__PURE__*/function (_BaseRequestPolicy2) {\n  _inherits(BatchHeaderFilterPolicy, _BaseRequestPolicy2);\n  var _super2 = _createSuper(BatchHeaderFilterPolicy);\n  // The base class has a protected constructor. Adding a public one to enable constructing of this class.\n  /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/\n  function BatchHeaderFilterPolicy(nextPolicy, options) {\n    _classCallCheck(this, BatchHeaderFilterPolicy);\n    return _super2.call(this, nextPolicy, options);\n  }\n  _createClass(BatchHeaderFilterPolicy, [{\n    key: \"sendRequest\",\n    value: function () {\n      var _sendRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(request) {\n        var xMsHeaderName, _iterator2, _step2, header;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              xMsHeaderName = \"\";\n              _iterator2 = _createForOfIteratorHelper(request.headers.headersArray());\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  header = _step2.value;\n                  if (iEqual(header.name, HeaderConstants.X_MS_VERSION)) {\n                    xMsHeaderName = header.name;\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              if (xMsHeaderName !== \"\") {\n                request.headers.remove(xMsHeaderName); // The subrequests should not have the x-ms-version header.\n              }\n              return _context7.abrupt(\"return\", this._nextPolicy.sendRequest(request));\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function sendRequest(_x11) {\n        return _sendRequest2.apply(this, arguments);\n      }\n      return sendRequest;\n    }()\n  }]);\n  return BatchHeaderFilterPolicy;\n}(BaseRequestPolicy);\nvar BatchHeaderFilterPolicyFactory = /*#__PURE__*/function () {\n  function BatchHeaderFilterPolicyFactory() {\n    _classCallCheck(this, BatchHeaderFilterPolicyFactory);\n  }\n  _createClass(BatchHeaderFilterPolicyFactory, [{\n    key: \"create\",\n    value: function create(nextPolicy, options) {\n      return new BatchHeaderFilterPolicy(nextPolicy, options);\n    }\n  }]);\n  return BatchHeaderFilterPolicyFactory;\n}();","map":{"version":3,"names":["BaseRequestPolicy","deserializationPolicy","generateUuid","HttpHeaders","WebResource","isTokenCredential","bearerTokenAuthenticationPolicy","isNode","SpanStatusCode","AnonymousCredential","BlobClient","Mutex","Pipeline","attachCredential","getURLPath","getURLPathAndQuery","iEqual","HeaderConstants","BATCH_MAX_REQUEST","HTTP_VERSION_1_1","HTTP_LINE_ENDING","StorageOAuthScopes","StorageSharedKeyCredential","createSpan","BlobBatch","_classCallCheck","batch","batchRequest","InnerBatchRequest","_createClass","key","value","getMultiPartContentType","getMultipartContentType","getHttpRequestBody","getSubRequests","_addSubRequestInternal","_asyncToGenerator","_regeneratorRuntime","mark","_callee","subRequest","assembleSubRequestFunc","wrap","_callee$","_context","prev","next","lock","preAddSubRequest","postAddSubRequest","unlock","finish","stop","addSubRequestInternal","_x","_x2","apply","arguments","setBatchType","batchType","RangeError","concat","_deleteBlob","_callee3","urlOrBlobClient","credentialOrOptions","options","_this","url","credential","_createSpan","span","updatedOptions","_callee3$","_context3","_callee2","_callee2$","_context2","createPipeline","delete","t0","setStatus","code","ERROR","message","end","deleteBlob","_x3","_x4","_x5","_setBlobAccessTier","_callee5","credentialOrTier","tierOrOptions","_this2","tier","_createSpan2","_callee5$","_context5","_callee4","_callee4$","_context4","setAccessTier","setBlobAccessTier","_x6","_x7","_x8","_x9","operationCount","body","tempGuid","boundary","subRequestPrefix","CONTENT_TYPE","CONTENT_TRANSFER_ENCODING","multipartContentType","batchRequestEnding","subRequests","Map","isAnonymousCreds","policyFactoryLength","factories","Array","BatchHeaderFilterPolicyFactory","BatchRequestAssemblePolicyFactory","appendSubRequestToBody","request","CONTENT_ID","method","toString","join","_iterator","_createForOfIteratorHelper","headers","headersArray","_step","s","n","done","header","name","err","e","f","path","set","BatchRequestAssemblePolicy","_BaseRequestPolicy","_inherits","_super","_createSuper","nextPolicy","_this3","call","dummyResponse","status","_sendRequest","_callee6","_callee6$","_context6","abrupt","sendRequest","_x10","create","BatchHeaderFilterPolicy","_BaseRequestPolicy2","_super2","_sendRequest2","_callee7","xMsHeaderName","_iterator2","_step2","_callee7$","_context7","X_MS_VERSION","remove","_nextPolicy","_x11"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\storage-blob\\src\\BlobBatch.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  deserializationPolicy,\n  generateUuid,\n  HttpHeaders,\n  HttpOperationResponse,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n  WebResource,\n  TokenCredential,\n  isTokenCredential,\n  bearerTokenAuthenticationPolicy,\n  isNode,\n} from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { BlobClient, BlobDeleteOptions, BlobSetTierOptions } from \"./Clients\";\nimport { AccessTier } from \"./generatedModels\";\nimport { Mutex } from \"./utils/Mutex\";\nimport { Pipeline } from \"./Pipeline\";\nimport { attachCredential, getURLPath, getURLPathAndQuery, iEqual } from \"./utils/utils.common\";\nimport {\n  HeaderConstants,\n  BATCH_MAX_REQUEST,\n  HTTP_VERSION_1_1,\n  HTTP_LINE_ENDING,\n  StorageOAuthScopes,\n} from \"./utils/constants\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { createSpan } from \"./utils/tracing\";\n\n/**\n * A request associated with a batch operation.\n */\nexport interface BatchSubRequest {\n  /**\n   * The URL of the resource to request operation.\n   */\n  url: string;\n\n  /**\n   * The credential used for sub request.\n   * Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service.\n   * You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n  credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;\n}\n\n/**\n * A BlobBatch represents an aggregated set of operations on blobs.\n * Currently, only `delete` and `setAccessTier` are supported.\n */\nexport class BlobBatch {\n  private batchRequest: InnerBatchRequest;\n  private readonly batch: string = \"batch\";\n  private batchType: \"delete\" | \"setAccessTier\" | undefined;\n\n  constructor() {\n    this.batchRequest = new InnerBatchRequest();\n  }\n\n  /**\n   * Get the value of Content-Type for a batch request.\n   * The value must be multipart/mixed with a batch boundary.\n   * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252\n   */\n  public getMultiPartContentType(): string {\n    return this.batchRequest.getMultipartContentType();\n  }\n\n  /**\n   * Get assembled HTTP request body for sub requests.\n   */\n  public getHttpRequestBody(): string {\n    return this.batchRequest.getHttpRequestBody();\n  }\n\n  /**\n   * Get sub requests that are added into the batch request.\n   */\n  public getSubRequests(): Map<number, BatchSubRequest> {\n    return this.batchRequest.getSubRequests();\n  }\n\n  private async addSubRequestInternal(\n    subRequest: BatchSubRequest,\n    assembleSubRequestFunc: () => Promise<void>\n  ): Promise<void> {\n    await Mutex.lock(this.batch);\n\n    try {\n      this.batchRequest.preAddSubRequest(subRequest);\n      await assembleSubRequestFunc();\n      this.batchRequest.postAddSubRequest(subRequest);\n    } finally {\n      await Mutex.unlock(this.batch);\n    }\n  }\n\n  private setBatchType(batchType: \"delete\" | \"setAccessTier\"): void {\n    if (!this.batchType) {\n      this.batchType = batchType;\n    }\n    if (this.batchType !== batchType) {\n      throw new RangeError(\n        `BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`\n      );\n    }\n  }\n\n  /**\n   * The deleteBlob operation marks the specified blob or snapshot for deletion.\n   * The blob is later deleted during garbage collection.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * Note that in order to delete a blob, you must delete all of its snapshots.\n   * You can delete both at the same time. See [delete operation details](https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob).\n   * The operation will be authenticated and authorized with specified credential.\n   * See [blob batch authorization details](https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param url - The url of the blob resource to delete.\n   * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options -\n   */\n  public async deleteBlob(\n    url: string,\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    options?: BlobDeleteOptions\n  ): Promise<void>;\n\n  /**\n   * The deleteBlob operation marks the specified blob or snapshot for deletion.\n   * The blob is later deleted during garbage collection.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * Note that in order to delete a blob, you must delete all of its snapshots.\n   * You can delete both at the same time. See [delete operation details](https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob).\n   * The operation will be authenticated and authorized with specified credential.\n   * See [blob batch authorization details](https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param blobClient - The BlobClient.\n   * @param options -\n   */\n  public async deleteBlob(blobClient: BlobClient, options?: BlobDeleteOptions): Promise<void>;\n\n  public async deleteBlob(\n    urlOrBlobClient: string | BlobClient,\n    credentialOrOptions:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | BlobDeleteOptions\n      | undefined,\n    options?: BlobDeleteOptions\n  ): Promise<void> {\n    let url: string;\n    let credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;\n\n    if (\n      typeof urlOrBlobClient === \"string\" &&\n      ((isNode && credentialOrOptions instanceof StorageSharedKeyCredential) ||\n        credentialOrOptions instanceof AnonymousCredential ||\n        isTokenCredential(credentialOrOptions))\n    ) {\n      // First overload\n      url = urlOrBlobClient;\n      credential = credentialOrOptions;\n    } else if (urlOrBlobClient instanceof BlobClient) {\n      // Second overload\n      url = urlOrBlobClient.url;\n      credential = urlOrBlobClient.credential;\n      options = credentialOrOptions as BlobDeleteOptions;\n    } else {\n      throw new RangeError(\n        \"Invalid arguments. Either url and credential, or BlobClient need be provided.\"\n      );\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"BatchDeleteRequest-addSubRequest\", options);\n\n    try {\n      this.setBatchType(\"delete\");\n      await this.addSubRequestInternal(\n        {\n          url: url,\n          credential: credential,\n        },\n        async () => {\n          await new BlobClient(url, this.batchRequest.createPipeline(credential)).delete(\n            updatedOptions\n          );\n        }\n      );\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * The setBlobAccessTier operation sets the tier on a blob.\n   * The operation is allowed on block blobs in a blob storage or general purpose v2 account.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * A block blob's tier determines Hot/Cool/Archive storage type.\n   * This operation does not update the blob's ETag.\n   * For detailed information about block blob level tiering\n   * see [hot, cool, and archive access tiers](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers).\n   * The operation will be authenticated and authorized\n   * with specified credential. See [blob batch authorization details](https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param url - The url of the blob resource to delete.\n   * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param tier -\n   * @param options -\n   */\n  public async setBlobAccessTier(\n    url: string,\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    tier: AccessTier,\n    options?: BlobSetTierOptions\n  ): Promise<void>;\n\n  /**\n   * The setBlobAccessTier operation sets the tier on a blob.\n   * The operation is allowed on block blobs in a blob storage or general purpose v2 account.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * A block blob's tier determines Hot/Cool/Archive storage type.\n   * This operation does not update the blob's ETag.\n   * For detailed information about block blob level tiering\n   * see [hot, cool, and archive access tiers](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers).\n   * The operation will be authenticated and authorized\n   * with specified credential. See [blob batch authorization details](https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param blobClient - The BlobClient.\n   * @param tier -\n   * @param options -\n   */\n  public async setBlobAccessTier(\n    blobClient: BlobClient,\n    tier: AccessTier,\n    options?: BlobSetTierOptions\n  ): Promise<void>;\n\n  public async setBlobAccessTier(\n    urlOrBlobClient: string | BlobClient,\n    credentialOrTier:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | AccessTier,\n    tierOrOptions?: AccessTier | BlobSetTierOptions,\n    options?: BlobSetTierOptions\n  ): Promise<void> {\n    let url: string;\n    let credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;\n    let tier: AccessTier;\n\n    if (\n      typeof urlOrBlobClient === \"string\" &&\n      ((isNode && credentialOrTier instanceof StorageSharedKeyCredential) ||\n        credentialOrTier instanceof AnonymousCredential ||\n        isTokenCredential(credentialOrTier))\n    ) {\n      // First overload\n      url = urlOrBlobClient;\n      credential = credentialOrTier as\n        | StorageSharedKeyCredential\n        | AnonymousCredential\n        | TokenCredential;\n      tier = tierOrOptions as AccessTier;\n    } else if (urlOrBlobClient instanceof BlobClient) {\n      // Second overload\n      url = urlOrBlobClient.url;\n      credential = urlOrBlobClient.credential;\n      tier = credentialOrTier as AccessTier;\n      options = tierOrOptions as BlobSetTierOptions;\n    } else {\n      throw new RangeError(\n        \"Invalid arguments. Either url and credential, or BlobClient need be provided.\"\n      );\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"BatchSetTierRequest-addSubRequest\", options);\n\n    try {\n      this.setBatchType(\"setAccessTier\");\n      await this.addSubRequestInternal(\n        {\n          url: url,\n          credential: credential,\n        },\n        async () => {\n          await new BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(\n            tier,\n            updatedOptions\n          );\n        }\n      );\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n\n/**\n * Inner batch request class which is responsible for assembling and serializing sub requests.\n * See https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#request-body for how requests are assembled.\n */\nclass InnerBatchRequest {\n  private operationCount: number;\n  private body: string;\n  private subRequests: Map<number, BatchSubRequest>;\n  private readonly boundary: string;\n  private readonly subRequestPrefix: string;\n  private readonly multipartContentType: string;\n  private readonly batchRequestEnding: string;\n\n  constructor() {\n    this.operationCount = 0;\n    this.body = \"\";\n\n    const tempGuid = generateUuid();\n\n    // batch_{batchid}\n    this.boundary = `batch_${tempGuid}`;\n    // --batch_{batchid}\n    // Content-Type: application/http\n    // Content-Transfer-Encoding: binary\n    this.subRequestPrefix = `--${this.boundary}${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TYPE}: application/http${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;\n    // multipart/mixed; boundary=batch_{batchid}\n    this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;\n    // --batch_{batchid}--\n    this.batchRequestEnding = `--${this.boundary}--`;\n\n    this.subRequests = new Map();\n  }\n\n  /**\n   * Create pipeline to assemble sub requests. The idea here is to use existing\n   * credential and serialization/deserialization components, with additional policies to\n   * filter unnecessary headers, assemble sub requests into request's body\n   * and intercept request from going to wire.\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n  public createPipeline(\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential\n  ): Pipeline {\n    const isAnonymousCreds = credential instanceof AnonymousCredential;\n    const policyFactoryLength = 3 + (isAnonymousCreds ? 0 : 1); // [deserializationPolicy, BatchHeaderFilterPolicyFactory, (Optional)Credential, BatchRequestAssemblePolicyFactory]\n    const factories: RequestPolicyFactory[] = new Array(policyFactoryLength);\n\n    factories[0] = deserializationPolicy(); // Default deserializationPolicy is provided by protocol layer\n    factories[1] = new BatchHeaderFilterPolicyFactory(); // Use batch header filter policy to exclude unnecessary headers\n    if (!isAnonymousCreds) {\n      factories[2] = isTokenCredential(credential)\n        ? attachCredential(\n            bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes),\n            credential\n          )\n        : credential;\n    }\n    factories[policyFactoryLength - 1] = new BatchRequestAssemblePolicyFactory(this); // Use batch assemble policy to assemble request and intercept request from going to wire\n\n    return new Pipeline(factories, {});\n  }\n\n  public appendSubRequestToBody(request: WebResource) {\n    // Start to assemble sub request\n    this.body += [\n      this.subRequestPrefix, // sub request constant prefix\n      `${HeaderConstants.CONTENT_ID}: ${this.operationCount}`, // sub request's content ID\n      \"\", // empty line after sub request's content ID\n      `${request.method.toString()} ${getURLPathAndQuery(\n        request.url\n      )} ${HTTP_VERSION_1_1}${HTTP_LINE_ENDING}`, // sub request start line with method\n    ].join(HTTP_LINE_ENDING);\n\n    for (const header of request.headers.headersArray()) {\n      this.body += `${header.name}: ${header.value}${HTTP_LINE_ENDING}`;\n    }\n\n    this.body += HTTP_LINE_ENDING; // sub request's headers need be ending with an empty line\n    // No body to assemble for current batch request support\n    // End to assemble sub request\n  }\n\n  public preAddSubRequest(subRequest: BatchSubRequest) {\n    if (this.operationCount >= BATCH_MAX_REQUEST) {\n      throw new RangeError(`Cannot exceed ${BATCH_MAX_REQUEST} sub requests in a single batch`);\n    }\n\n    // Fast fail if url for sub request is invalid\n    const path = getURLPath(subRequest.url);\n    if (!path || path === \"\") {\n      throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);\n    }\n  }\n\n  public postAddSubRequest(subRequest: BatchSubRequest) {\n    this.subRequests.set(this.operationCount, subRequest);\n    this.operationCount++;\n  }\n\n  // Return the http request body with assembling the ending line to the sub request body.\n  public getHttpRequestBody(): string {\n    return `${this.body}${this.batchRequestEnding}${HTTP_LINE_ENDING}`;\n  }\n\n  public getMultipartContentType(): string {\n    return this.multipartContentType;\n  }\n\n  public getSubRequests(): Map<number, BatchSubRequest> {\n    return this.subRequests;\n  }\n}\n\nclass BatchRequestAssemblePolicy extends BaseRequestPolicy {\n  private batchRequest: InnerBatchRequest;\n  private readonly dummyResponse: HttpOperationResponse = {\n    request: new WebResource(),\n    status: 200,\n    headers: new HttpHeaders(),\n  };\n\n  constructor(\n    batchRequest: InnerBatchRequest,\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions\n  ) {\n    super(nextPolicy, options);\n\n    this.batchRequest = batchRequest;\n  }\n\n  public async sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    await this.batchRequest.appendSubRequestToBody(request);\n\n    return this.dummyResponse; // Intercept request from going to wire\n  }\n}\n\nclass BatchRequestAssemblePolicyFactory implements RequestPolicyFactory {\n  private batchRequest: InnerBatchRequest;\n\n  constructor(batchRequest: InnerBatchRequest) {\n    this.batchRequest = batchRequest;\n  }\n\n  public create(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions\n  ): BatchRequestAssemblePolicy {\n    return new BatchRequestAssemblePolicy(this.batchRequest, nextPolicy, options);\n  }\n}\n\nclass BatchHeaderFilterPolicy extends BaseRequestPolicy {\n  // The base class has a protected constructor. Adding a public one to enable constructing of this class.\n  /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/\n  constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n    super(nextPolicy, options);\n  }\n\n  public async sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    let xMsHeaderName = \"\";\n\n    for (const header of request.headers.headersArray()) {\n      if (iEqual(header.name, HeaderConstants.X_MS_VERSION)) {\n        xMsHeaderName = header.name;\n      }\n    }\n\n    if (xMsHeaderName !== \"\") {\n      request.headers.remove(xMsHeaderName); // The subrequests should not have the x-ms-version header.\n    }\n\n    return this._nextPolicy.sendRequest(request);\n  }\n}\n\nclass BatchHeaderFilterPolicyFactory implements RequestPolicyFactory {\n  public create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): BatchHeaderFilterPolicy {\n    return new BatchHeaderFilterPolicy(nextPolicy, options);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}