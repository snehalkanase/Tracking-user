{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders } from \"@azure/core-http\";\nimport { HTTP_VERSION_1_1, HTTP_LINE_ENDING, HeaderConstants, HTTPURLConnection } from \"./utils/constants\";\nimport { getBodyAsText } from \"./BatchUtils\";\nimport { logger } from \"./log\";\nvar HTTP_HEADER_DELIMITER = \": \";\nvar SPACE_DELIMITER = \" \";\nvar NOT_FOUND = -1;\n/**\n * Util class for parsing batch response.\n */\nexport var BatchResponseParser = /*#__PURE__*/function () {\n  function BatchResponseParser(batchResponse, subRequests) {\n    _classCallCheck(this, BatchResponseParser);\n    if (!batchResponse || !batchResponse.contentType) {\n      // In special case(reported), server may return invalid content-type which could not be parsed.\n      throw new RangeError(\"batchResponse is malformed or doesn't contain valid content-type.\");\n    }\n    if (!subRequests || subRequests.size === 0) {\n      // This should be prevent during coding.\n      throw new RangeError(\"Invalid state: subRequests is not provided or size is 0.\");\n    }\n    this.batchResponse = batchResponse;\n    this.subRequests = subRequests;\n    this.responseBatchBoundary = this.batchResponse.contentType.split(\"=\")[1];\n    this.perResponsePrefix = \"--\".concat(this.responseBatchBoundary).concat(HTTP_LINE_ENDING);\n    this.batchResponseEnding = \"--\".concat(this.responseBatchBoundary, \"--\");\n  }\n  // For example of response, please refer to https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#response\n  _createClass(BatchResponseParser, [{\n    key: \"parseBatchResponse\",\n    value: function () {\n      var _parseBatchResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var responseBodyAsText, subResponses, subResponseCount, deserializedSubResponses, subResponsesSucceededCount, subResponsesFailedCount, index, subResponse, deserializedSubResponse, responseLines, subRespHeaderStartFound, subRespHeaderEndFound, subRespFailed, contentId, _iterator, _step, responseLine, tokens, _tokens;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED)) {\n                _context.next = 2;\n                break;\n              }\n              throw new Error(\"Invalid state: batch request failed with status: '\".concat(this.batchResponse._response.status, \"'.\"));\n            case 2:\n              _context.next = 4;\n              return getBodyAsText(this.batchResponse);\n            case 4:\n              responseBodyAsText = _context.sent;\n              subResponses = responseBodyAsText.split(this.batchResponseEnding)[0] // string after ending is useless\n              .split(this.perResponsePrefix).slice(1); // string before first response boundary is useless\n              subResponseCount = subResponses.length; // Defensive coding in case of potential error parsing.\n              // Note: subResponseCount == 1 is special case where sub request is invalid.\n              // We try to prevent such cases through early validation, e.g. validate sub request count >= 1.\n              // While in unexpected sub request invalid case, we allow sub response to be parsed and return to user.\n              if (!(subResponseCount !== this.subRequests.size && subResponseCount !== 1)) {\n                _context.next = 9;\n                break;\n              }\n              throw new Error(\"Invalid state: sub responses' count is not equal to sub requests' count.\");\n            case 9:\n              deserializedSubResponses = new Array(subResponseCount);\n              subResponsesSucceededCount = 0;\n              subResponsesFailedCount = 0; // Parse sub subResponses.\n              index = 0;\n            case 13:\n              if (!(index < subResponseCount)) {\n                _context.next = 59;\n                break;\n              }\n              subResponse = subResponses[index];\n              deserializedSubResponse = {};\n              deserializedSubResponse.headers = new HttpHeaders();\n              responseLines = subResponse.split(\"\".concat(HTTP_LINE_ENDING));\n              subRespHeaderStartFound = false;\n              subRespHeaderEndFound = false;\n              subRespFailed = false;\n              contentId = NOT_FOUND;\n              _iterator = _createForOfIteratorHelper(responseLines);\n              _context.prev = 23;\n              _iterator.s();\n            case 25:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 46;\n                break;\n              }\n              responseLine = _step.value;\n              if (subRespHeaderStartFound) {\n                _context.next = 31;\n                break;\n              }\n              // Convention line to indicate content ID\n              if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {\n                contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);\n              }\n              // Http version line with status code indicates the start of sub request's response.\n              // Example: HTTP/1.1 202 Accepted\n              if (responseLine.startsWith(HTTP_VERSION_1_1)) {\n                subRespHeaderStartFound = true;\n                tokens = responseLine.split(SPACE_DELIMITER);\n                deserializedSubResponse.status = parseInt(tokens[1]);\n                deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);\n              }\n              return _context.abrupt(\"continue\", 44);\n            case 31:\n              if (!(responseLine.trim() === \"\")) {\n                _context.next = 34;\n                break;\n              }\n              // Sub response's header start line already found, and the first empty line indicates header end line found.\n              if (!subRespHeaderEndFound) {\n                subRespHeaderEndFound = true;\n              }\n              return _context.abrupt(\"continue\", 44);\n            case 34:\n              if (subRespHeaderEndFound) {\n                _context.next = 42;\n                break;\n              }\n              if (!(responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1)) {\n                _context.next = 37;\n                break;\n              }\n              throw new Error(\"Invalid state: find non-empty line '\".concat(responseLine, \"' without HTTP header delimiter '\").concat(HTTP_HEADER_DELIMITER, \"'.\"));\n            case 37:\n              // Parse headers of sub response.\n              _tokens = responseLine.split(HTTP_HEADER_DELIMITER);\n              deserializedSubResponse.headers.set(_tokens[0], _tokens[1]);\n              if (_tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {\n                deserializedSubResponse.errorCode = _tokens[1];\n                subRespFailed = true;\n              }\n              _context.next = 44;\n              break;\n            case 42:\n              // Assemble body of sub response.\n              if (!deserializedSubResponse.bodyAsText) {\n                deserializedSubResponse.bodyAsText = \"\";\n              }\n              deserializedSubResponse.bodyAsText += responseLine;\n            case 44:\n              _context.next = 25;\n              break;\n            case 46:\n              _context.next = 51;\n              break;\n            case 48:\n              _context.prev = 48;\n              _context.t0 = _context[\"catch\"](23);\n              _iterator.e(_context.t0);\n            case 51:\n              _context.prev = 51;\n              _iterator.f();\n              return _context.finish(51);\n            case 54:\n              // Inner for end\n              // The response will contain the Content-ID header for each corresponding subrequest response to use for tracking.\n              // The Content-IDs are set to a valid index in the subrequests we sent. In the status code 202 path, we could expect it\n              // to be 1-1 mapping from the [0, subRequests.size) to the Content-IDs returned. If not, we simply don't return that\n              // unexpected subResponse in the parsed reponse and we can always look it up in the raw response for debugging purpose.\n              if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === undefined) {\n                deserializedSubResponse._request = this.subRequests.get(contentId);\n                deserializedSubResponses[contentId] = deserializedSubResponse;\n              } else {\n                logger.error(\"subResponses[\".concat(index, \"] is dropped as the Content-ID is not found or invalid, Content-ID: \").concat(contentId));\n              }\n              if (subRespFailed) {\n                subResponsesFailedCount++;\n              } else {\n                subResponsesSucceededCount++;\n              }\n            case 56:\n              index++;\n              _context.next = 13;\n              break;\n            case 59:\n              return _context.abrupt(\"return\", {\n                subResponses: deserializedSubResponses,\n                subResponsesSucceededCount: subResponsesSucceededCount,\n                subResponsesFailedCount: subResponsesFailedCount\n              });\n            case 60:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[23, 48, 51, 54]]);\n      }));\n      function parseBatchResponse() {\n        return _parseBatchResponse.apply(this, arguments);\n      }\n      return parseBatchResponse;\n    }()\n  }]);\n  return BatchResponseParser;\n}();","map":{"version":3,"names":["HttpHeaders","HTTP_VERSION_1_1","HTTP_LINE_ENDING","HeaderConstants","HTTPURLConnection","getBodyAsText","logger","HTTP_HEADER_DELIMITER","SPACE_DELIMITER","NOT_FOUND","BatchResponseParser","batchResponse","subRequests","_classCallCheck","contentType","RangeError","size","responseBatchBoundary","split","perResponsePrefix","concat","batchResponseEnding","_createClass","key","value","_parseBatchResponse","_asyncToGenerator","_regeneratorRuntime","mark","_callee","responseBodyAsText","subResponses","subResponseCount","deserializedSubResponses","subResponsesSucceededCount","subResponsesFailedCount","index","subResponse","deserializedSubResponse","responseLines","subRespHeaderStartFound","subRespHeaderEndFound","subRespFailed","contentId","_iterator","_step","responseLine","tokens","_tokens","wrap","_callee$","_context","prev","next","_response","status","HTTP_ACCEPTED","Error","sent","slice","length","Array","headers","_createForOfIteratorHelper","s","n","done","startsWith","CONTENT_ID","parseInt","statusMessage","join","abrupt","trim","indexOf","set","X_MS_ERROR_CODE","errorCode","bodyAsText","t0","e","f","finish","Number","isInteger","undefined","_request","get","error","stop","parseBatchResponse","apply","arguments"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\storage-blob\\src\\BatchResponseParser.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpHeaders } from \"@azure/core-http\";\n\nimport { ServiceSubmitBatchResponseModel } from \"./generatedModels\";\nimport {\n  HTTP_VERSION_1_1,\n  HTTP_LINE_ENDING,\n  HeaderConstants,\n  HTTPURLConnection,\n} from \"./utils/constants\";\nimport { getBodyAsText } from \"./BatchUtils\";\nimport { BatchSubRequest } from \"./BlobBatch\";\nimport { BatchSubResponse, ParsedBatchResponse } from \"./BatchResponse\";\nimport { logger } from \"./log\";\n\nconst HTTP_HEADER_DELIMITER = \": \";\nconst SPACE_DELIMITER = \" \";\nconst NOT_FOUND = -1;\n\n/**\n * Util class for parsing batch response.\n */\nexport class BatchResponseParser {\n  private readonly batchResponse: ServiceSubmitBatchResponseModel;\n  private readonly responseBatchBoundary: string;\n  private readonly perResponsePrefix: string;\n  private readonly batchResponseEnding: string;\n  private readonly subRequests: Map<number, BatchSubRequest>;\n\n  constructor(\n    batchResponse: ServiceSubmitBatchResponseModel,\n    subRequests: Map<number, BatchSubRequest>\n  ) {\n    if (!batchResponse || !batchResponse.contentType) {\n      // In special case(reported), server may return invalid content-type which could not be parsed.\n      throw new RangeError(\"batchResponse is malformed or doesn't contain valid content-type.\");\n    }\n\n    if (!subRequests || subRequests.size === 0) {\n      // This should be prevent during coding.\n      throw new RangeError(\"Invalid state: subRequests is not provided or size is 0.\");\n    }\n\n    this.batchResponse = batchResponse;\n    this.subRequests = subRequests;\n    this.responseBatchBoundary = this.batchResponse.contentType!.split(\"=\")[1];\n    this.perResponsePrefix = `--${this.responseBatchBoundary}${HTTP_LINE_ENDING}`;\n    this.batchResponseEnding = `--${this.responseBatchBoundary}--`;\n  }\n\n  // For example of response, please refer to https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#response\n  public async parseBatchResponse(): Promise<ParsedBatchResponse> {\n    // When logic reach here, suppose batch request has already succeeded with 202, so we can further parse\n    // sub request's response.\n    if (this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) {\n      throw new Error(\n        `Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`\n      );\n    }\n\n    const responseBodyAsText = await getBodyAsText(this.batchResponse);\n\n    const subResponses = responseBodyAsText\n      .split(this.batchResponseEnding)[0] // string after ending is useless\n      .split(this.perResponsePrefix)\n      .slice(1); // string before first response boundary is useless\n    const subResponseCount = subResponses.length;\n\n    // Defensive coding in case of potential error parsing.\n    // Note: subResponseCount == 1 is special case where sub request is invalid.\n    // We try to prevent such cases through early validation, e.g. validate sub request count >= 1.\n    // While in unexpected sub request invalid case, we allow sub response to be parsed and return to user.\n    if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {\n      throw new Error(\"Invalid state: sub responses' count is not equal to sub requests' count.\");\n    }\n\n    const deserializedSubResponses: Array<BatchSubResponse> = new Array(subResponseCount);\n    let subResponsesSucceededCount: number = 0;\n    let subResponsesFailedCount: number = 0;\n\n    // Parse sub subResponses.\n    for (let index = 0; index < subResponseCount; index++) {\n      const subResponse = subResponses[index];\n      const deserializedSubResponse = {} as BatchSubResponse;\n      deserializedSubResponse.headers = new HttpHeaders();\n\n      const responseLines = subResponse.split(`${HTTP_LINE_ENDING}`);\n      let subRespHeaderStartFound = false;\n      let subRespHeaderEndFound = false;\n      let subRespFailed = false;\n      let contentId = NOT_FOUND;\n\n      for (const responseLine of responseLines) {\n        if (!subRespHeaderStartFound) {\n          // Convention line to indicate content ID\n          if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {\n            contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);\n          }\n\n          // Http version line with status code indicates the start of sub request's response.\n          // Example: HTTP/1.1 202 Accepted\n          if (responseLine.startsWith(HTTP_VERSION_1_1)) {\n            subRespHeaderStartFound = true;\n\n            const tokens = responseLine.split(SPACE_DELIMITER);\n            deserializedSubResponse.status = parseInt(tokens[1]);\n            deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);\n          }\n\n          continue; // Skip convention headers not specifically for sub request i.e. Content-Type: application/http and Content-ID: *\n        }\n\n        if (responseLine.trim() === \"\") {\n          // Sub response's header start line already found, and the first empty line indicates header end line found.\n          if (!subRespHeaderEndFound) {\n            subRespHeaderEndFound = true;\n          }\n\n          continue; // Skip empty line\n        }\n\n        // Note: when code reach here, it indicates subRespHeaderStartFound == true\n        if (!subRespHeaderEndFound) {\n          if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {\n            // Defensive coding to prevent from missing valuable lines.\n            throw new Error(\n              `Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`\n            );\n          }\n\n          // Parse headers of sub response.\n          const tokens = responseLine.split(HTTP_HEADER_DELIMITER);\n          deserializedSubResponse.headers.set(tokens[0], tokens[1]);\n          if (tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {\n            deserializedSubResponse.errorCode = tokens[1];\n            subRespFailed = true;\n          }\n        } else {\n          // Assemble body of sub response.\n          if (!deserializedSubResponse.bodyAsText) {\n            deserializedSubResponse.bodyAsText = \"\";\n          }\n\n          deserializedSubResponse.bodyAsText += responseLine;\n        }\n      } // Inner for end\n\n      // The response will contain the Content-ID header for each corresponding subrequest response to use for tracking.\n      // The Content-IDs are set to a valid index in the subrequests we sent. In the status code 202 path, we could expect it\n      // to be 1-1 mapping from the [0, subRequests.size) to the Content-IDs returned. If not, we simply don't return that\n      // unexpected subResponse in the parsed reponse and we can always look it up in the raw response for debugging purpose.\n      if (\n        contentId !== NOT_FOUND &&\n        Number.isInteger(contentId) &&\n        contentId >= 0 &&\n        contentId < this.subRequests.size &&\n        deserializedSubResponses[contentId] === undefined\n      ) {\n        deserializedSubResponse._request = this.subRequests.get(contentId)!;\n        deserializedSubResponses[contentId] = deserializedSubResponse;\n      } else {\n        logger.error(\n          `subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`\n        );\n      }\n\n      if (subRespFailed) {\n        subResponsesFailedCount++;\n      } else {\n        subResponsesSucceededCount++;\n      }\n    }\n\n    return {\n      subResponses: deserializedSubResponses,\n      subResponsesSucceededCount: subResponsesSucceededCount,\n      subResponsesFailedCount: subResponsesFailedCount,\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}