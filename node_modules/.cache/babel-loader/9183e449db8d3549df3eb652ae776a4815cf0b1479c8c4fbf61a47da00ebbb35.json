{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n/**\n * States for Batch.\n */\nvar BatchStates;\n(function (BatchStates) {\n  BatchStates[BatchStates[\"Good\"] = 0] = \"Good\";\n  BatchStates[BatchStates[\"Error\"] = 1] = \"Error\";\n})(BatchStates || (BatchStates = {}));\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\nexport var Batch = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of Batch.\n   * @param concurrency -\n   */\n  function Batch() {\n    var concurrency = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n    _classCallCheck(this, Batch);\n    /**\n     * Number of active operations under execution.\n     */\n    this.actives = 0;\n    /**\n     * Number of completed operations under execution.\n     */\n    this.completed = 0;\n    /**\n     * Offset of next operation to be executed.\n     */\n    this.offset = 0;\n    /**\n     * Operation array to be executed.\n     */\n    this.operations = [];\n    /**\n     * States of Batch. When an error happens, state will turn into error.\n     * Batch will stop execute left operations.\n     */\n    this.state = BatchStates.Good;\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n  /**\n   * Add a operation into queue.\n   *\n   * @param operation -\n   */\n  _createClass(Batch, [{\n    key: \"addOperation\",\n    value: function addOperation(operation) {\n      var _this = this;\n      this.operations.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _this.actives++;\n              _context.next = 4;\n              return operation();\n            case 4:\n              _this.actives--;\n              _this.completed++;\n              _this.parallelExecute();\n              _context.next = 12;\n              break;\n            case 9:\n              _context.prev = 9;\n              _context.t0 = _context[\"catch\"](0);\n              _this.emitter.emit(\"error\", _context.t0);\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[0, 9]]);\n      })));\n    }\n    /**\n     * Start execute operations in the queue.\n     *\n     */\n  }, {\n    key: \"do\",\n    value: function () {\n      var _do2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this2 = this;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(this.operations.length === 0)) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\", Promise.resolve());\n            case 2:\n              this.parallelExecute();\n              return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                _this2.emitter.on(\"finish\", resolve);\n                _this2.emitter.on(\"error\", function (error) {\n                  _this2.state = BatchStates.Error;\n                  reject(error);\n                });\n              }));\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function _do() {\n        return _do2.apply(this, arguments);\n      }\n      return _do;\n    }()\n    /**\n     * Get next operation to be executed. Return null when reaching ends.\n     *\n     */\n  }, {\n    key: \"nextOperation\",\n    value: function nextOperation() {\n      if (this.offset < this.operations.length) {\n        return this.operations[this.offset++];\n      }\n      return null;\n    }\n    /**\n     * Start execute operations. One one the most important difference between\n     * this method with do() is that do() wraps as an sync method.\n     *\n     */\n  }, {\n    key: \"parallelExecute\",\n    value: function parallelExecute() {\n      if (this.state === BatchStates.Error) {\n        return;\n      }\n      if (this.completed >= this.operations.length) {\n        this.emitter.emit(\"finish\");\n        return;\n      }\n      while (this.actives < this.concurrency) {\n        var operation = this.nextOperation();\n        if (operation) {\n          operation();\n        } else {\n          return;\n        }\n      }\n    }\n  }]);\n  return Batch;\n}();","map":{"version":3,"names":["EventEmitter","BatchStates","Batch","concurrency","arguments","length","undefined","_classCallCheck","actives","completed","offset","operations","state","Good","RangeError","emitter","_createClass","key","value","addOperation","operation","_this","push","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","parallelExecute","t0","emit","stop","_do2","_callee2","_this2","_callee2$","_context2","abrupt","Promise","resolve","reject","on","error","Error","_do","apply","nextOperation"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\storage-blob\\src\\utils\\Batch.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n\n/**\n * Operation is an async function to be executed and managed by Batch.\n */\nexport declare type Operation = () => Promise<any>;\n\n/**\n * States for Batch.\n */\nenum BatchStates {\n  Good,\n  Error,\n}\n\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\nexport class Batch {\n  /**\n   * Concurrency. Must be lager than 0.\n   */\n  private concurrency: number;\n\n  /**\n   * Number of active operations under execution.\n   */\n  private actives: number = 0;\n\n  /**\n   * Number of completed operations under execution.\n   */\n  private completed: number = 0;\n\n  /**\n   * Offset of next operation to be executed.\n   */\n  private offset: number = 0;\n\n  /**\n   * Operation array to be executed.\n   */\n  private operations: Operation[] = [];\n\n  /**\n   * States of Batch. When an error happens, state will turn into error.\n   * Batch will stop execute left operations.\n   */\n  private state: BatchStates = BatchStates.Good;\n\n  /**\n   * A private emitter used to pass events inside this class.\n   */\n  private emitter: EventEmitter;\n\n  /**\n   * Creates an instance of Batch.\n   * @param concurrency -\n   */\n  public constructor(concurrency: number = 5) {\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n\n  /**\n   * Add a operation into queue.\n   *\n   * @param operation -\n   */\n  public addOperation(operation: Operation): void {\n    this.operations.push(async () => {\n      try {\n        this.actives++;\n        await operation();\n        this.actives--;\n        this.completed++;\n        this.parallelExecute();\n      } catch (error: any) {\n        this.emitter.emit(\"error\", error);\n      }\n    });\n  }\n\n  /**\n   * Start execute operations in the queue.\n   *\n   */\n  public async do(): Promise<void> {\n    if (this.operations.length === 0) {\n      return Promise.resolve();\n    }\n\n    this.parallelExecute();\n\n    return new Promise<void>((resolve, reject) => {\n      this.emitter.on(\"finish\", resolve);\n\n      this.emitter.on(\"error\", (error) => {\n        this.state = BatchStates.Error;\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   */\n  private nextOperation(): Operation | null {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n    return null;\n  }\n\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   */\n  private parallelExecute(): void {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n\n    while (this.actives < this.concurrency) {\n      const operation = this.nextOperation();\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}