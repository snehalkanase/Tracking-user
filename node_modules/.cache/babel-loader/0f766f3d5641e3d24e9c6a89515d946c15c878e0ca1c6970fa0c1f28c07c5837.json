{"ast":null,"code":"import _classCallCheck from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * Defines the default token refresh buffer duration.\n */\nexport var TokenRefreshBufferMs = 2 * 60 * 1000; // 2 Minutes\n/**\n * Provides an {@link AccessTokenCache} implementation which clears\n * the cached {@link AccessToken}'s after the expiresOnTimestamp has\n * passed.\n *\n * @deprecated No longer used in the bearer authorization policy.\n */\nexport var ExpiringAccessTokenCache = /*#__PURE__*/function () {\n  /**\n   * Constructs an instance of {@link ExpiringAccessTokenCache} with\n   * an optional expiration buffer time.\n   */\n  function ExpiringAccessTokenCache() {\n    var tokenRefreshBufferMs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TokenRefreshBufferMs;\n    _classCallCheck(this, ExpiringAccessTokenCache);\n    this.cachedToken = undefined;\n    this.tokenRefreshBufferMs = tokenRefreshBufferMs;\n  }\n  /**\n   * Saves an access token into the internal in-memory cache.\n   * @param accessToken - Access token or undefined to clear the cache.\n   */\n  _createClass(ExpiringAccessTokenCache, [{\n    key: \"setCachedToken\",\n    value: function setCachedToken(accessToken) {\n      this.cachedToken = accessToken;\n    }\n    /**\n     * Returns the cached access token, or `undefined` if one is not cached or the cached one is expiring soon.\n     */\n  }, {\n    key: \"getCachedToken\",\n    value: function getCachedToken() {\n      if (this.cachedToken && Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp) {\n        this.cachedToken = undefined;\n      }\n      return this.cachedToken;\n    }\n  }]);\n  return ExpiringAccessTokenCache;\n}();","map":{"version":3,"names":["TokenRefreshBufferMs","ExpiringAccessTokenCache","tokenRefreshBufferMs","arguments","length","undefined","_classCallCheck","cachedToken","_createClass","key","value","setCachedToken","accessToken","getCachedToken","Date","now","expiresOnTimestamp"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\core-http\\src\\credentials\\accessTokenCache.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken } from \"@azure/core-auth\";\n\n/**\n * Defines the default token refresh buffer duration.\n */\nexport const TokenRefreshBufferMs = 2 * 60 * 1000; // 2 Minutes\n\n/**\n * Provides a cache for an AccessToken that was that\n * was returned from a TokenCredential.\n */\nexport interface AccessTokenCache {\n  /**\n   * Sets the cached token.\n   *\n   * @param accessToken - The {@link AccessToken} to be cached or null to\n   *        clear the cached token.\n   */\n  setCachedToken(accessToken: AccessToken | undefined): void;\n\n  /**\n   * Returns the cached {@link AccessToken} or undefined if nothing is cached.\n   */\n  getCachedToken(): AccessToken | undefined;\n}\n\n/**\n * Provides an {@link AccessTokenCache} implementation which clears\n * the cached {@link AccessToken}'s after the expiresOnTimestamp has\n * passed.\n *\n * @deprecated No longer used in the bearer authorization policy.\n */\nexport class ExpiringAccessTokenCache implements AccessTokenCache {\n  private tokenRefreshBufferMs: number;\n  private cachedToken?: AccessToken = undefined;\n\n  /**\n   * Constructs an instance of {@link ExpiringAccessTokenCache} with\n   * an optional expiration buffer time.\n   */\n  constructor(tokenRefreshBufferMs: number = TokenRefreshBufferMs) {\n    this.tokenRefreshBufferMs = tokenRefreshBufferMs;\n  }\n\n  /**\n   * Saves an access token into the internal in-memory cache.\n   * @param accessToken - Access token or undefined to clear the cache.\n   */\n  setCachedToken(accessToken: AccessToken | undefined): void {\n    this.cachedToken = accessToken;\n  }\n\n  /**\n   * Returns the cached access token, or `undefined` if one is not cached or the cached one is expiring soon.\n   */\n  getCachedToken(): AccessToken | undefined {\n    if (\n      this.cachedToken &&\n      Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp\n    ) {\n      this.cachedToken = undefined;\n    }\n\n    return this.cachedToken;\n  }\n}\n"],"mappings":";;AAAA;AACA;AAIA;;;AAGA,OAAO,IAAMA,oBAAoB,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;AAqBnD;;;;;;;AAOA,WAAaC,wBAAwB;EAInC;;;;EAIA,SAAAA,yBAAA,EAA+D;IAAA,IAAnDC,oBAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA+BH,oBAAoB;IAAAM,eAAA,OAAAL,wBAAA;IANvD,KAAAM,WAAW,GAAiBF,SAAS;IAO3C,IAAI,CAACH,oBAAoB,GAAGA,oBAAoB;EAClD;EAEA;;;;EAAAM,YAAA,CAAAP,wBAAA;IAAAQ,GAAA;IAAAC,KAAA,EAIA,SAAAC,eAAeC,WAAoC;MACjD,IAAI,CAACL,WAAW,GAAGK,WAAW;IAChC;IAEA;;;EAAA;IAAAH,GAAA;IAAAC,KAAA,EAGA,SAAAG,eAAA,EAAc;MACZ,IACE,IAAI,CAACN,WAAW,IAChBO,IAAI,CAACC,GAAG,EAAE,GAAG,IAAI,CAACb,oBAAoB,IAAI,IAAI,CAACK,WAAW,CAACS,kBAAkB,EAC7E;QACA,IAAI,CAACT,WAAW,GAAGF,SAAS;;MAG9B,OAAO,IAAI,CAACE,WAAW;IACzB;EAAC;EAAA,OAAAN,wBAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}