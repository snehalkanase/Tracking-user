{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortController } from \"@azure/abort-controller\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delay } from \"@azure/core-util\";\nconst createStateProxy = () => ({\n  /**\n   * The state at this point is created to be of type OperationState<TResult>.\n   * It will be updated later to be of type TState when the\n   * customer-provided callback, `updateState`, is called during polling.\n   */\n  initState: config => ({\n    status: \"running\",\n    config\n  }),\n  setCanceled: state => state.status = \"canceled\",\n  setError: (state, error) => state.error = error,\n  setResult: (state, result) => state.result = result,\n  setRunning: state => state.status = \"running\",\n  setSucceeded: state => state.status = \"succeeded\",\n  setFailed: state => state.status = \"failed\",\n  getError: state => state.error,\n  getResult: state => state.result,\n  isCanceled: state => state.status === \"canceled\",\n  isFailed: state => state.status === \"failed\",\n  isRunning: state => state.status === \"running\",\n  isSucceeded: state => state.status === \"succeeded\"\n});\n/**\n * Returns a poller factory.\n */\nexport function buildCreatePoller(inputs) {\n  const {\n    getOperationLocation,\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse,\n    isOperationError,\n    getResourceLocation,\n    getPollingInterval,\n    getError,\n    resolveOnUnsuccessful\n  } = inputs;\n  return async (_ref, options) => {\n    let {\n      init,\n      poll\n    } = _ref;\n    const {\n      processResult,\n      updateState,\n      withOperationLocation: withOperationLocationCallback,\n      intervalInMs = POLL_INTERVAL_IN_MS,\n      restoreFrom\n    } = options || {};\n    const stateProxy = createStateProxy();\n    const withOperationLocation = withOperationLocationCallback ? (() => {\n      let called = false;\n      return (operationLocation, isUpdated) => {\n        if (isUpdated) withOperationLocationCallback(operationLocation);else if (!called) withOperationLocationCallback(operationLocation);\n        called = true;\n      };\n    })() : undefined;\n    const state = restoreFrom ? deserializeState(restoreFrom) : await initOperation({\n      init,\n      stateProxy,\n      processResult,\n      getOperationStatus: getStatusFromInitialResponse,\n      withOperationLocation,\n      setErrorAsResult: !resolveOnUnsuccessful\n    });\n    let resultPromise;\n    const abortController = new AbortController();\n    const handlers = new Map();\n    const handleProgressEvents = async () => handlers.forEach(h => h(state));\n    const cancelErrMsg = \"Operation was canceled\";\n    let currentPollIntervalInMs = intervalInMs;\n    const poller = {\n      getOperationState: () => state,\n      getResult: () => state.result,\n      isDone: () => [\"succeeded\", \"failed\", \"canceled\"].includes(state.status),\n      isStopped: () => resultPromise === undefined,\n      stopPolling: () => {\n        abortController.abort();\n      },\n      toString: () => JSON.stringify({\n        state\n      }),\n      onProgress: callback => {\n        const s = Symbol();\n        handlers.set(s, callback);\n        return () => handlers.delete(s);\n      },\n      pollUntilDone: pollOptions => resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = (async () => {\n        const {\n          abortSignal: inputAbortSignal\n        } = pollOptions || {};\n        const {\n          signal: abortSignal\n        } = inputAbortSignal ? new AbortController([inputAbortSignal, abortController.signal]) : abortController;\n        if (!poller.isDone()) {\n          await poller.poll({\n            abortSignal\n          });\n          while (!poller.isDone()) {\n            await delay(currentPollIntervalInMs, {\n              abortSignal\n            });\n            await poller.poll({\n              abortSignal\n            });\n          }\n        }\n        if (resolveOnUnsuccessful) {\n          return poller.getResult();\n        } else {\n          switch (state.status) {\n            case \"succeeded\":\n              return poller.getResult();\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n            case \"failed\":\n              throw state.error;\n            case \"notStarted\":\n            case \"running\":\n              throw new Error(`Polling completed without succeeding or failing`);\n          }\n        }\n      })().finally(() => {\n        resultPromise = undefined;\n      }),\n      async poll(pollOptions) {\n        if (resolveOnUnsuccessful) {\n          if (poller.isDone()) return;\n        } else {\n          switch (state.status) {\n            case \"succeeded\":\n              return;\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n            case \"failed\":\n              throw state.error;\n          }\n        }\n        await pollOperation({\n          poll,\n          state,\n          stateProxy,\n          getOperationLocation,\n          isOperationError,\n          withOperationLocation,\n          getPollingInterval,\n          getOperationStatus: getStatusFromPollResponse,\n          getResourceLocation,\n          processResult,\n          getError,\n          updateState,\n          options: pollOptions,\n          setDelay: pollIntervalInMs => {\n            currentPollIntervalInMs = pollIntervalInMs;\n          },\n          setErrorAsResult: !resolveOnUnsuccessful\n        });\n        await handleProgressEvents();\n        if (!resolveOnUnsuccessful) {\n          switch (state.status) {\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n            case \"failed\":\n              throw state.error;\n          }\n        }\n      }\n    };\n    return poller;\n  };\n}","map":{"version":3,"names":["AbortController","deserializeState","initOperation","pollOperation","POLL_INTERVAL_IN_MS","delay","createStateProxy","initState","config","status","setCanceled","state","setError","error","setResult","result","setRunning","setSucceeded","setFailed","getError","getResult","isCanceled","isFailed","isRunning","isSucceeded","buildCreatePoller","inputs","getOperationLocation","getStatusFromInitialResponse","getStatusFromPollResponse","isOperationError","getResourceLocation","getPollingInterval","resolveOnUnsuccessful","_ref","options","init","poll","processResult","updateState","withOperationLocation","withOperationLocationCallback","intervalInMs","restoreFrom","stateProxy","called","operationLocation","isUpdated","undefined","getOperationStatus","setErrorAsResult","resultPromise","abortController","handlers","Map","handleProgressEvents","forEach","h","cancelErrMsg","currentPollIntervalInMs","poller","getOperationState","isDone","includes","isStopped","stopPolling","abort","toString","JSON","stringify","onProgress","callback","s","Symbol","set","delete","pollUntilDone","pollOptions","abortSignal","inputAbortSignal","signal","Error","finally","setDelay","pollIntervalInMs"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\core-lro\\src\\poller\\poller.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortController, AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  BuildCreatePollerOptions,\n  CreatePollerOptions,\n  Operation,\n  OperationState,\n  RestorableOperationState,\n  SimplePollerLike,\n  StateProxy,\n} from \"./models\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delay } from \"@azure/core-util\";\n\nconst createStateProxy: <TResult, TState extends OperationState<TResult>>() => StateProxy<\n  TState,\n  TResult\n> = () => ({\n  /**\n   * The state at this point is created to be of type OperationState<TResult>.\n   * It will be updated later to be of type TState when the\n   * customer-provided callback, `updateState`, is called during polling.\n   */\n  initState: (config) => ({ status: \"running\", config } as any),\n  setCanceled: (state) => (state.status = \"canceled\"),\n  setError: (state, error) => (state.error = error),\n  setResult: (state, result) => (state.result = result),\n  setRunning: (state) => (state.status = \"running\"),\n  setSucceeded: (state) => (state.status = \"succeeded\"),\n  setFailed: (state) => (state.status = \"failed\"),\n\n  getError: (state) => state.error,\n  getResult: (state) => state.result,\n  isCanceled: (state) => state.status === \"canceled\",\n  isFailed: (state) => state.status === \"failed\",\n  isRunning: (state) => state.status === \"running\",\n  isSucceeded: (state) => state.status === \"succeeded\",\n});\n\n/**\n * Returns a poller factory.\n */\nexport function buildCreatePoller<TResponse, TResult, TState extends OperationState<TResult>>(\n  inputs: BuildCreatePollerOptions<TResponse, TState>\n): (\n  lro: Operation<TResponse, { abortSignal?: AbortSignalLike }>,\n  options?: CreatePollerOptions<TResponse, TResult, TState>\n) => Promise<SimplePollerLike<TState, TResult>> {\n  const {\n    getOperationLocation,\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse,\n    isOperationError,\n    getResourceLocation,\n    getPollingInterval,\n    getError,\n    resolveOnUnsuccessful,\n  } = inputs;\n  return async (\n    { init, poll }: Operation<TResponse, { abortSignal?: AbortSignalLike }>,\n    options?: CreatePollerOptions<TResponse, TResult, TState>\n  ) => {\n    const {\n      processResult,\n      updateState,\n      withOperationLocation: withOperationLocationCallback,\n      intervalInMs = POLL_INTERVAL_IN_MS,\n      restoreFrom,\n    } = options || {};\n    const stateProxy = createStateProxy<TResult, TState>();\n    const withOperationLocation = withOperationLocationCallback\n      ? (() => {\n          let called = false;\n          return (operationLocation: string, isUpdated: boolean) => {\n            if (isUpdated) withOperationLocationCallback(operationLocation);\n            else if (!called) withOperationLocationCallback(operationLocation);\n            called = true;\n          };\n        })()\n      : undefined;\n    const state: RestorableOperationState<TState> = restoreFrom\n      ? deserializeState(restoreFrom)\n      : await initOperation({\n          init,\n          stateProxy,\n          processResult,\n          getOperationStatus: getStatusFromInitialResponse,\n          withOperationLocation,\n          setErrorAsResult: !resolveOnUnsuccessful,\n        });\n    let resultPromise: Promise<TResult> | undefined;\n    const abortController = new AbortController();\n    // Progress handlers\n    type Handler = (state: TState) => void;\n    const handlers = new Map<symbol, Handler>();\n    const handleProgressEvents = async (): Promise<void> => handlers.forEach((h) => h(state));\n    const cancelErrMsg = \"Operation was canceled\";\n    let currentPollIntervalInMs = intervalInMs;\n\n    const poller: SimplePollerLike<TState, TResult> = {\n      getOperationState: () => state,\n      getResult: () => state.result,\n      isDone: () => [\"succeeded\", \"failed\", \"canceled\"].includes(state.status),\n      isStopped: () => resultPromise === undefined,\n      stopPolling: () => {\n        abortController.abort();\n      },\n      toString: () =>\n        JSON.stringify({\n          state,\n        }),\n      onProgress: (callback: (state: TState) => void) => {\n        const s = Symbol();\n        handlers.set(s, callback);\n        return () => handlers.delete(s);\n      },\n      pollUntilDone: (pollOptions?: { abortSignal?: AbortSignalLike }) =>\n        (resultPromise ??= (async () => {\n          const { abortSignal: inputAbortSignal } = pollOptions || {};\n          const { signal: abortSignal } = inputAbortSignal\n            ? new AbortController([inputAbortSignal, abortController.signal])\n            : abortController;\n          if (!poller.isDone()) {\n            await poller.poll({ abortSignal });\n            while (!poller.isDone()) {\n              await delay(currentPollIntervalInMs, { abortSignal });\n              await poller.poll({ abortSignal });\n            }\n          }\n          if (resolveOnUnsuccessful) {\n            return poller.getResult() as TResult;\n          } else {\n            switch (state.status) {\n              case \"succeeded\":\n                return poller.getResult() as TResult;\n              case \"canceled\":\n                throw new Error(cancelErrMsg);\n              case \"failed\":\n                throw state.error;\n              case \"notStarted\":\n              case \"running\":\n                throw new Error(`Polling completed without succeeding or failing`);\n            }\n          }\n        })().finally(() => {\n          resultPromise = undefined;\n        })),\n      async poll(pollOptions?: { abortSignal?: AbortSignalLike }): Promise<void> {\n        if (resolveOnUnsuccessful) {\n          if (poller.isDone()) return;\n        } else {\n          switch (state.status) {\n            case \"succeeded\":\n              return;\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n            case \"failed\":\n              throw state.error;\n          }\n        }\n        await pollOperation({\n          poll,\n          state,\n          stateProxy,\n          getOperationLocation,\n          isOperationError,\n          withOperationLocation,\n          getPollingInterval,\n          getOperationStatus: getStatusFromPollResponse,\n          getResourceLocation,\n          processResult,\n          getError,\n          updateState,\n          options: pollOptions,\n          setDelay: (pollIntervalInMs) => {\n            currentPollIntervalInMs = pollIntervalInMs;\n          },\n          setErrorAsResult: !resolveOnUnsuccessful,\n        });\n        await handleProgressEvents();\n        if (!resolveOnUnsuccessful) {\n          switch (state.status) {\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n            case \"failed\":\n              throw state.error;\n          }\n        }\n      },\n    };\n    return poller;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}