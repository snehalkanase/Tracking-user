{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { initOperation, pollOperation } from \"../poller/operation\";\nimport { logger } from \"../logger\";\nfunction getOperationLocationPollingUrl(inputs) {\n  var azureAsyncOperation = inputs.azureAsyncOperation,\n    operationLocation = inputs.operationLocation;\n  return operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation;\n}\nfunction getLocationHeader(rawResponse) {\n  return rawResponse.headers[\"location\"];\n}\nfunction getOperationLocationHeader(rawResponse) {\n  return rawResponse.headers[\"operation-location\"];\n}\nfunction getAzureAsyncOperationHeader(rawResponse) {\n  return rawResponse.headers[\"azure-asyncoperation\"];\n}\nfunction findResourceLocation(inputs) {\n  var location = inputs.location,\n    requestMethod = inputs.requestMethod,\n    requestPath = inputs.requestPath,\n    resourceLocationConfig = inputs.resourceLocationConfig;\n  switch (requestMethod) {\n    case \"PUT\":\n      {\n        return requestPath;\n      }\n    case \"DELETE\":\n      {\n        return undefined;\n      }\n    default:\n      {\n        switch (resourceLocationConfig) {\n          case \"azure-async-operation\":\n            {\n              return undefined;\n            }\n          case \"original-uri\":\n            {\n              return requestPath;\n            }\n          case \"location\":\n          default:\n            {\n              return location;\n            }\n        }\n      }\n  }\n}\nexport function inferLroMode(inputs) {\n  var rawResponse = inputs.rawResponse,\n    requestMethod = inputs.requestMethod,\n    requestPath = inputs.requestPath,\n    resourceLocationConfig = inputs.resourceLocationConfig;\n  var operationLocation = getOperationLocationHeader(rawResponse);\n  var azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);\n  var pollingUrl = getOperationLocationPollingUrl({\n    operationLocation: operationLocation,\n    azureAsyncOperation: azureAsyncOperation\n  });\n  var location = getLocationHeader(rawResponse);\n  var normalizedRequestMethod = requestMethod === null || requestMethod === void 0 ? void 0 : requestMethod.toLocaleUpperCase();\n  if (pollingUrl !== undefined) {\n    return {\n      mode: \"OperationLocation\",\n      operationLocation: pollingUrl,\n      resourceLocation: findResourceLocation({\n        requestMethod: normalizedRequestMethod,\n        location: location,\n        requestPath: requestPath,\n        resourceLocationConfig: resourceLocationConfig\n      })\n    };\n  } else if (location !== undefined) {\n    return {\n      mode: \"ResourceLocation\",\n      operationLocation: location\n    };\n  } else if (normalizedRequestMethod === \"PUT\" && requestPath) {\n    return {\n      mode: \"Body\",\n      operationLocation: requestPath\n    };\n  } else {\n    return undefined;\n  }\n}\nfunction transformStatus(inputs) {\n  var status = inputs.status,\n    statusCode = inputs.statusCode;\n  if (typeof status !== \"string\" && status !== undefined) {\n    throw new Error(\"Polling was unsuccessful. Expected status to have a string value or no value but it has instead: \".concat(status, \". This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.\"));\n  }\n  switch (status === null || status === void 0 ? void 0 : status.toLocaleLowerCase()) {\n    case undefined:\n      return toOperationStatus(statusCode);\n    case \"succeeded\":\n      return \"succeeded\";\n    case \"failed\":\n      return \"failed\";\n    case \"running\":\n    case \"accepted\":\n    case \"started\":\n    case \"canceling\":\n    case \"cancelling\":\n      return \"running\";\n    case \"canceled\":\n    case \"cancelled\":\n      return \"canceled\";\n    default:\n      {\n        logger.verbose(\"LRO: unrecognized operation status: \".concat(status));\n        return status;\n      }\n  }\n}\nfunction getStatus(rawResponse) {\n  var _a;\n  var _ref = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {},\n    status = _ref.status;\n  return transformStatus({\n    status: status,\n    statusCode: rawResponse.statusCode\n  });\n}\nfunction getProvisioningState(rawResponse) {\n  var _a, _b;\n  var _ref2 = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {},\n    properties = _ref2.properties,\n    provisioningState = _ref2.provisioningState;\n  var status = (_b = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b !== void 0 ? _b : provisioningState;\n  return transformStatus({\n    status: status,\n    statusCode: rawResponse.statusCode\n  });\n}\nfunction toOperationStatus(statusCode) {\n  if (statusCode === 202) {\n    return \"running\";\n  } else if (statusCode < 300) {\n    return \"succeeded\";\n  } else {\n    return \"failed\";\n  }\n}\nexport function parseRetryAfter(_ref3) {\n  var rawResponse = _ref3.rawResponse;\n  var retryAfter = rawResponse.headers[\"retry-after\"];\n  if (retryAfter !== undefined) {\n    // Retry-After header value is either in HTTP date format, or in seconds\n    var retryAfterInSeconds = parseInt(retryAfter);\n    return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1000;\n  }\n  return undefined;\n}\nexport function getErrorFromResponse(response) {\n  var error = response.flatResponse.error;\n  if (!error) {\n    logger.warning(\"The long-running operation failed but there is no error property in the response's body\");\n    return;\n  }\n  if (!error.code || !error.message) {\n    logger.warning(\"The long-running operation failed but the error property in the response's body doesn't contain code or message\");\n    return;\n  }\n  return error;\n}\nfunction calculatePollingIntervalFromDate(retryAfterDate) {\n  var timeNow = Math.floor(new Date().getTime());\n  var retryAfterTime = retryAfterDate.getTime();\n  if (timeNow < retryAfterTime) {\n    return retryAfterTime - timeNow;\n  }\n  return undefined;\n}\nexport function getStatusFromInitialResponse(inputs) {\n  var response = inputs.response,\n    state = inputs.state,\n    operationLocation = inputs.operationLocation;\n  function helper() {\n    var _a;\n    var mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a[\"mode\"];\n    switch (mode) {\n      case undefined:\n        return toOperationStatus(response.rawResponse.statusCode);\n      case \"Body\":\n        return getOperationStatus(response, state);\n      default:\n        return \"running\";\n    }\n  }\n  var status = helper();\n  return status === \"running\" && operationLocation === undefined ? \"succeeded\" : status;\n}\n/**\n * Initiates the long-running operation.\n */\nexport function initHttpOperation(_x) {\n  return _initHttpOperation.apply(this, arguments);\n}\nfunction _initHttpOperation() {\n  _initHttpOperation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(inputs) {\n    var stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          stateProxy = inputs.stateProxy, resourceLocationConfig = inputs.resourceLocationConfig, processResult = inputs.processResult, lro = inputs.lro, setErrorAsResult = inputs.setErrorAsResult;\n          return _context2.abrupt(\"return\", initOperation({\n            init: function () {\n              var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var response, config;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) switch (_context.prev = _context.next) {\n                    case 0:\n                      _context.next = 2;\n                      return lro.sendInitialRequest();\n                    case 2:\n                      response = _context.sent;\n                      config = inferLroMode({\n                        rawResponse: response.rawResponse,\n                        requestPath: lro.requestPath,\n                        requestMethod: lro.requestMethod,\n                        resourceLocationConfig: resourceLocationConfig\n                      });\n                      return _context.abrupt(\"return\", Object.assign({\n                        response: response,\n                        operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation,\n                        resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation\n                      }, (config === null || config === void 0 ? void 0 : config.mode) ? {\n                        metadata: {\n                          mode: config.mode\n                        }\n                      } : {}));\n                    case 5:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }, _callee);\n              }));\n              function init() {\n                return _init.apply(this, arguments);\n              }\n              return init;\n            }(),\n            stateProxy: stateProxy,\n            processResult: processResult ? function (_ref7, state) {\n              var flatResponse = _ref7.flatResponse;\n              return processResult(flatResponse, state);\n            } : function (_ref8) {\n              var flatResponse = _ref8.flatResponse;\n              return flatResponse;\n            },\n            getOperationStatus: getStatusFromInitialResponse,\n            setErrorAsResult: setErrorAsResult\n          }));\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _initHttpOperation.apply(this, arguments);\n}\nexport function getOperationLocation(_ref4, state) {\n  var rawResponse = _ref4.rawResponse;\n  var _a;\n  var mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a[\"mode\"];\n  switch (mode) {\n    case \"OperationLocation\":\n      {\n        return getOperationLocationPollingUrl({\n          operationLocation: getOperationLocationHeader(rawResponse),\n          azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)\n        });\n      }\n    case \"ResourceLocation\":\n      {\n        return getLocationHeader(rawResponse);\n      }\n    case \"Body\":\n    default:\n      {\n        return undefined;\n      }\n  }\n}\nexport function getOperationStatus(_ref5, state) {\n  var rawResponse = _ref5.rawResponse;\n  var _a;\n  var mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a[\"mode\"];\n  switch (mode) {\n    case \"OperationLocation\":\n      {\n        return getStatus(rawResponse);\n      }\n    case \"ResourceLocation\":\n      {\n        return toOperationStatus(rawResponse.statusCode);\n      }\n    case \"Body\":\n      {\n        return getProvisioningState(rawResponse);\n      }\n    default:\n      throw new Error(\"Internal error: Unexpected operation mode: \".concat(mode));\n  }\n}\nexport function getResourceLocation(_ref6, state) {\n  var flatResponse = _ref6.flatResponse;\n  if (typeof flatResponse === \"object\") {\n    var resourceLocation = flatResponse.resourceLocation;\n    if (resourceLocation !== undefined) {\n      state.config.resourceLocation = resourceLocation;\n    }\n  }\n  return state.config.resourceLocation;\n}\nexport function isOperationError(e) {\n  return e.name === \"RestError\";\n}\n/** Polls the long-running operation. */\nexport function pollHttpOperation(_x2) {\n  return _pollHttpOperation.apply(this, arguments);\n}\nfunction _pollHttpOperation() {\n  _pollHttpOperation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(inputs) {\n    var lro, stateProxy, options, processResult, updateState, setDelay, state, setErrorAsResult;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          lro = inputs.lro, stateProxy = inputs.stateProxy, options = inputs.options, processResult = inputs.processResult, updateState = inputs.updateState, setDelay = inputs.setDelay, state = inputs.state, setErrorAsResult = inputs.setErrorAsResult;\n          return _context4.abrupt(\"return\", pollOperation({\n            state: state,\n            stateProxy: stateProxy,\n            setDelay: setDelay,\n            processResult: processResult ? function (_ref9, inputState) {\n              var flatResponse = _ref9.flatResponse;\n              return processResult(flatResponse, inputState);\n            } : function (_ref10) {\n              var flatResponse = _ref10.flatResponse;\n              return flatResponse;\n            },\n            getError: getErrorFromResponse,\n            updateState: updateState,\n            getPollingInterval: parseRetryAfter,\n            getOperationLocation: getOperationLocation,\n            getOperationStatus: getOperationStatus,\n            isOperationError: isOperationError,\n            getResourceLocation: getResourceLocation,\n            options: options,\n            /**\n             * The expansion here is intentional because `lro` could be an object that\n             * references an inner this, so we need to preserve a reference to it.\n             */\n            poll: function () {\n              var _poll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(location, inputOptions) {\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) switch (_context3.prev = _context3.next) {\n                    case 0:\n                      return _context3.abrupt(\"return\", lro.sendPollRequest(location, inputOptions));\n                    case 1:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }, _callee3);\n              }));\n              function poll(_x3, _x4) {\n                return _poll.apply(this, arguments);\n              }\n              return poll;\n            }(),\n            setErrorAsResult: setErrorAsResult\n          }));\n        case 2:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _pollHttpOperation.apply(this, arguments);\n}","map":{"version":3,"names":["initOperation","pollOperation","logger","getOperationLocationPollingUrl","inputs","azureAsyncOperation","operationLocation","getLocationHeader","rawResponse","headers","getOperationLocationHeader","getAzureAsyncOperationHeader","findResourceLocation","location","requestMethod","requestPath","resourceLocationConfig","undefined","inferLroMode","pollingUrl","normalizedRequestMethod","toLocaleUpperCase","mode","resourceLocation","transformStatus","status","statusCode","Error","concat","toLocaleLowerCase","toOperationStatus","verbose","getStatus","_ref","_a","body","getProvisioningState","_ref2","properties","provisioningState","_b","parseRetryAfter","_ref3","retryAfter","retryAfterInSeconds","parseInt","isNaN","calculatePollingIntervalFromDate","Date","getErrorFromResponse","response","error","flatResponse","warning","code","message","retryAfterDate","timeNow","Math","floor","getTime","retryAfterTime","getStatusFromInitialResponse","state","helper","config","metadata","getOperationStatus","initHttpOperation","_x","_initHttpOperation","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","stateProxy","processResult","lro","setErrorAsResult","wrap","_callee2$","_context2","prev","next","abrupt","init","_init","_callee","_callee$","_context","sendInitialRequest","sent","Object","assign","stop","_ref7","_ref8","getOperationLocation","_ref4","_ref5","getResourceLocation","_ref6","isOperationError","e","name","pollHttpOperation","_x2","_pollHttpOperation","_callee4","options","updateState","setDelay","_callee4$","_context4","_ref9","inputState","_ref10","getError","getPollingInterval","poll","_poll","_callee3","inputOptions","_callee3$","_context3","sendPollRequest","_x3","_x4"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\core-lro\\src\\http\\operation.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  HttpOperationMode,\n  LongRunningOperation,\n  LroResourceLocationConfig,\n  LroResponse,\n  RawResponse,\n  ResponseBody,\n} from \"./models\";\nimport {\n  LroError,\n  OperationConfig,\n  OperationStatus,\n  RestorableOperationState,\n  StateProxy,\n} from \"../poller/models\";\nimport { initOperation, pollOperation } from \"../poller/operation\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { logger } from \"../logger\";\n\nfunction getOperationLocationPollingUrl(inputs: {\n  operationLocation?: string;\n  azureAsyncOperation?: string;\n}): string | undefined {\n  const { azureAsyncOperation, operationLocation } = inputs;\n  return operationLocation ?? azureAsyncOperation;\n}\n\nfunction getLocationHeader(rawResponse: RawResponse): string | undefined {\n  return rawResponse.headers[\"location\"];\n}\n\nfunction getOperationLocationHeader(rawResponse: RawResponse): string | undefined {\n  return rawResponse.headers[\"operation-location\"];\n}\n\nfunction getAzureAsyncOperationHeader(rawResponse: RawResponse): string | undefined {\n  return rawResponse.headers[\"azure-asyncoperation\"];\n}\n\nfunction findResourceLocation(inputs: {\n  requestMethod?: string;\n  location?: string;\n  requestPath?: string;\n  resourceLocationConfig?: LroResourceLocationConfig;\n}): string | undefined {\n  const { location, requestMethod, requestPath, resourceLocationConfig } = inputs;\n  switch (requestMethod) {\n    case \"PUT\": {\n      return requestPath;\n    }\n    case \"DELETE\": {\n      return undefined;\n    }\n    default: {\n      switch (resourceLocationConfig) {\n        case \"azure-async-operation\": {\n          return undefined;\n        }\n        case \"original-uri\": {\n          return requestPath;\n        }\n        case \"location\":\n        default: {\n          return location;\n        }\n      }\n    }\n  }\n}\n\nexport function inferLroMode(inputs: {\n  rawResponse: RawResponse;\n  requestPath?: string;\n  requestMethod?: string;\n  resourceLocationConfig?: LroResourceLocationConfig;\n}): (OperationConfig & { mode: HttpOperationMode }) | undefined {\n  const { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs;\n  const operationLocation = getOperationLocationHeader(rawResponse);\n  const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);\n  const pollingUrl = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation });\n  const location = getLocationHeader(rawResponse);\n  const normalizedRequestMethod = requestMethod?.toLocaleUpperCase();\n  if (pollingUrl !== undefined) {\n    return {\n      mode: \"OperationLocation\",\n      operationLocation: pollingUrl,\n      resourceLocation: findResourceLocation({\n        requestMethod: normalizedRequestMethod,\n        location,\n        requestPath,\n        resourceLocationConfig,\n      }),\n    };\n  } else if (location !== undefined) {\n    return {\n      mode: \"ResourceLocation\",\n      operationLocation: location,\n    };\n  } else if (normalizedRequestMethod === \"PUT\" && requestPath) {\n    return {\n      mode: \"Body\",\n      operationLocation: requestPath,\n    };\n  } else {\n    return undefined;\n  }\n}\n\nfunction transformStatus(inputs: { status: unknown; statusCode: number }): OperationStatus {\n  const { status, statusCode } = inputs;\n  if (typeof status !== \"string\" && status !== undefined) {\n    throw new Error(\n      `Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`\n    );\n  }\n  switch (status?.toLocaleLowerCase()) {\n    case undefined:\n      return toOperationStatus(statusCode);\n    case \"succeeded\":\n      return \"succeeded\";\n    case \"failed\":\n      return \"failed\";\n    case \"running\":\n    case \"accepted\":\n    case \"started\":\n    case \"canceling\":\n    case \"cancelling\":\n      return \"running\";\n    case \"canceled\":\n    case \"cancelled\":\n      return \"canceled\";\n    default: {\n      logger.verbose(`LRO: unrecognized operation status: ${status}`);\n      return status as OperationStatus;\n    }\n  }\n}\n\nfunction getStatus(rawResponse: RawResponse): OperationStatus {\n  const { status } = (rawResponse.body as ResponseBody) ?? {};\n  return transformStatus({ status, statusCode: rawResponse.statusCode });\n}\n\nfunction getProvisioningState(rawResponse: RawResponse): OperationStatus {\n  const { properties, provisioningState } = (rawResponse.body as ResponseBody) ?? {};\n  const status = properties?.provisioningState ?? provisioningState;\n  return transformStatus({ status, statusCode: rawResponse.statusCode });\n}\n\nfunction toOperationStatus(statusCode: number): OperationStatus {\n  if (statusCode === 202) {\n    return \"running\";\n  } else if (statusCode < 300) {\n    return \"succeeded\";\n  } else {\n    return \"failed\";\n  }\n}\n\nexport function parseRetryAfter<T>({ rawResponse }: LroResponse<T>): number | undefined {\n  const retryAfter: string | undefined = rawResponse.headers[\"retry-after\"];\n  if (retryAfter !== undefined) {\n    // Retry-After header value is either in HTTP date format, or in seconds\n    const retryAfterInSeconds = parseInt(retryAfter);\n    return isNaN(retryAfterInSeconds)\n      ? calculatePollingIntervalFromDate(new Date(retryAfter))\n      : retryAfterInSeconds * 1000;\n  }\n  return undefined;\n}\n\nexport function getErrorFromResponse<T>(response: LroResponse<T>): LroError | undefined {\n  const error = (response.flatResponse as ResponseBody).error;\n  if (!error) {\n    logger.warning(\n      `The long-running operation failed but there is no error property in the response's body`\n    );\n    return;\n  }\n  if (!error.code || !error.message) {\n    logger.warning(\n      `The long-running operation failed but the error property in the response's body doesn't contain code or message`\n    );\n    return;\n  }\n  return error as LroError;\n}\n\nfunction calculatePollingIntervalFromDate(retryAfterDate: Date): number | undefined {\n  const timeNow = Math.floor(new Date().getTime());\n  const retryAfterTime = retryAfterDate.getTime();\n  if (timeNow < retryAfterTime) {\n    return retryAfterTime - timeNow;\n  }\n  return undefined;\n}\n\nexport function getStatusFromInitialResponse<TState>(inputs: {\n  response: LroResponse<unknown>;\n  state: RestorableOperationState<TState>;\n  operationLocation?: string;\n}): OperationStatus {\n  const { response, state, operationLocation } = inputs;\n  function helper(): OperationStatus {\n    const mode = state.config.metadata?.[\"mode\"];\n    switch (mode) {\n      case undefined:\n        return toOperationStatus(response.rawResponse.statusCode);\n      case \"Body\":\n        return getOperationStatus(response, state);\n      default:\n        return \"running\";\n    }\n  }\n  const status = helper();\n  return status === \"running\" && operationLocation === undefined ? \"succeeded\" : status;\n}\n\n/**\n * Initiates the long-running operation.\n */\nexport async function initHttpOperation<TResult, TState>(inputs: {\n  stateProxy: StateProxy<TState, TResult>;\n  resourceLocationConfig?: LroResourceLocationConfig;\n  processResult?: (result: unknown, state: TState) => TResult;\n  setErrorAsResult: boolean;\n  lro: LongRunningOperation;\n}): Promise<RestorableOperationState<TState>> {\n  const { stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult } = inputs;\n  return initOperation({\n    init: async () => {\n      const response = await lro.sendInitialRequest();\n      const config = inferLroMode({\n        rawResponse: response.rawResponse,\n        requestPath: lro.requestPath,\n        requestMethod: lro.requestMethod,\n        resourceLocationConfig,\n      });\n      return {\n        response,\n        operationLocation: config?.operationLocation,\n        resourceLocation: config?.resourceLocation,\n        ...(config?.mode ? { metadata: { mode: config.mode } } : {}),\n      };\n    },\n    stateProxy,\n    processResult: processResult\n      ? ({ flatResponse }, state) => processResult(flatResponse, state)\n      : ({ flatResponse }) => flatResponse as TResult,\n    getOperationStatus: getStatusFromInitialResponse,\n    setErrorAsResult,\n  });\n}\n\nexport function getOperationLocation<TState>(\n  { rawResponse }: LroResponse,\n  state: RestorableOperationState<TState>\n): string | undefined {\n  const mode = state.config.metadata?.[\"mode\"];\n  switch (mode) {\n    case \"OperationLocation\": {\n      return getOperationLocationPollingUrl({\n        operationLocation: getOperationLocationHeader(rawResponse),\n        azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse),\n      });\n    }\n    case \"ResourceLocation\": {\n      return getLocationHeader(rawResponse);\n    }\n    case \"Body\":\n    default: {\n      return undefined;\n    }\n  }\n}\n\nexport function getOperationStatus<TState>(\n  { rawResponse }: LroResponse,\n  state: RestorableOperationState<TState>\n): OperationStatus {\n  const mode = state.config.metadata?.[\"mode\"];\n  switch (mode) {\n    case \"OperationLocation\": {\n      return getStatus(rawResponse);\n    }\n    case \"ResourceLocation\": {\n      return toOperationStatus(rawResponse.statusCode);\n    }\n    case \"Body\": {\n      return getProvisioningState(rawResponse);\n    }\n    default:\n      throw new Error(`Internal error: Unexpected operation mode: ${mode}`);\n  }\n}\n\nexport function getResourceLocation<TState>(\n  { flatResponse }: LroResponse,\n  state: RestorableOperationState<TState>\n): string | undefined {\n  if (typeof flatResponse === \"object\") {\n    const resourceLocation = (flatResponse as { resourceLocation?: string }).resourceLocation;\n    if (resourceLocation !== undefined) {\n      state.config.resourceLocation = resourceLocation;\n    }\n  }\n  return state.config.resourceLocation;\n}\n\nexport function isOperationError(e: Error): boolean {\n  return e.name === \"RestError\";\n}\n\n/** Polls the long-running operation. */\nexport async function pollHttpOperation<TState, TResult>(inputs: {\n  lro: LongRunningOperation;\n  stateProxy: StateProxy<TState, TResult>;\n  processResult?: (result: unknown, state: TState) => TResult;\n  updateState?: (state: TState, lastResponse: LroResponse) => void;\n  isDone?: (lastResponse: LroResponse, state: TState) => boolean;\n  setDelay: (intervalInMs: number) => void;\n  options?: { abortSignal?: AbortSignalLike };\n  state: RestorableOperationState<TState>;\n  setErrorAsResult: boolean;\n}): Promise<void> {\n  const {\n    lro,\n    stateProxy,\n    options,\n    processResult,\n    updateState,\n    setDelay,\n    state,\n    setErrorAsResult,\n  } = inputs;\n  return pollOperation({\n    state,\n    stateProxy,\n    setDelay,\n    processResult: processResult\n      ? ({ flatResponse }, inputState) => processResult(flatResponse, inputState)\n      : ({ flatResponse }) => flatResponse as TResult,\n    getError: getErrorFromResponse,\n    updateState,\n    getPollingInterval: parseRetryAfter,\n    getOperationLocation,\n    getOperationStatus,\n    isOperationError,\n    getResourceLocation,\n    options,\n    /**\n     * The expansion here is intentional because `lro` could be an object that\n     * references an inner this, so we need to preserve a reference to it.\n     */\n    poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),\n    setErrorAsResult,\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}