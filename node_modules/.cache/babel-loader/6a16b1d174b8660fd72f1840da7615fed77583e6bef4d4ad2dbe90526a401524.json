{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./serializer.common\";\nif (!self.document || !self.DOMParser || !self.Node || !self.XMLSerializer) {\n  throw new Error(\"This library depends on the following DOM objects: [\\\"document\\\", \\\"DOMParser\\\", \\\"Node\\\", \\\"XMLSerializer\\\"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. \");\n}\nvar cachedDoc;\nfunction getDoc() {\n  if (!cachedDoc) {\n    cachedDoc = document.implementation.createDocument(null, null, null);\n  }\n  return cachedDoc;\n}\nvar cachedParser;\nfunction getParser() {\n  if (!cachedParser) {\n    cachedParser = new DOMParser();\n  }\n  return cachedParser;\n}\nvar cachedSerializer;\nfunction getSerializer() {\n  if (!cachedSerializer) {\n    cachedSerializer = new XMLSerializer();\n  }\n  return cachedSerializer;\n}\n// Policy to make our code Trusted Types compliant.\n//   https://github.com/w3c/webappsec-trusted-types\n// We are calling DOMParser.parseFromString() to parse XML payload from Azure services.\n// The parsed DOM object is not exposed to outside. Scripts are disabled when parsing\n// according to the spec.  There are no HTML/XSS security concerns on the usage of\n// parseFromString() here.\nvar ttPolicy;\nif (typeof self.trustedTypes !== \"undefined\") {\n  ttPolicy = self.trustedTypes.createPolicy(\"@azure/core-http#xml.browser\", {\n    createHTML: function createHTML(s) {\n      return s;\n    }\n  });\n}\nexport function parseXML(str) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a, _b, _c, _d;\n  try {\n    var updatedOptions = {\n      rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : \"\",\n      includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,\n      xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n    };\n    var dom = getParser().parseFromString((_d = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(str)) !== null && _d !== void 0 ? _d : str, \"application/xml\");\n    throwIfError(dom);\n    var obj;\n    if (updatedOptions.includeRoot) {\n      obj = domToObject(dom, updatedOptions);\n    } else {\n      obj = domToObject(dom.childNodes[0], updatedOptions);\n    }\n    return Promise.resolve(obj);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nvar errorNS;\nfunction getErrorNamespace() {\n  var _a, _b;\n  if (errorNS === undefined) {\n    try {\n      var invalidXML = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(\"INVALID\")) !== null && _a !== void 0 ? _a : \"INVALID\";\n      errorNS = (_b = getParser().parseFromString(invalidXML, \"text/xml\").getElementsByTagName(\"parsererror\")[0].namespaceURI) !== null && _b !== void 0 ? _b : \"\";\n    } catch (ignored) {\n      // Most browsers will return a document containing <parsererror>, but IE will throw.\n      errorNS = \"\";\n    }\n  }\n  return errorNS;\n}\nfunction throwIfError(dom) {\n  var parserErrors = dom.getElementsByTagName(\"parsererror\");\n  if (parserErrors.length > 0 && getErrorNamespace()) {\n    for (var i = 0; i < parserErrors.length; i++) {\n      if (parserErrors[i].namespaceURI === errorNS) {\n        throw new Error(parserErrors[i].innerHTML);\n      }\n    }\n  }\n}\nfunction isElement(node) {\n  return !!node.attributes;\n}\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node) {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\nfunction domToObject(node, options) {\n  var result = {};\n  var childNodeCount = node.childNodes.length;\n  var firstChildNode = node.childNodes[0];\n  var onlyChildTextValue = firstChildNode && childNodeCount === 1 && firstChildNode.nodeType === Node.TEXT_NODE && firstChildNode.nodeValue || undefined;\n  var elementWithAttributes = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[XML_ATTRKEY] = {};\n    for (var i = 0; i < elementWithAttributes.attributes.length; i++) {\n      var attr = elementWithAttributes.attributes[i];\n      result[XML_ATTRKEY][attr.nodeName] = attr.nodeValue;\n    }\n    if (onlyChildTextValue) {\n      result[options.xmlCharKey] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n  if (!onlyChildTextValue) {\n    for (var _i = 0; _i < childNodeCount; _i++) {\n      var child = node.childNodes[_i];\n      // Ignore leading/trailing whitespace nodes\n      if (child.nodeType !== Node.TEXT_NODE) {\n        var childObject = domToObject(child, options);\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n  return result;\n}\nexport function stringifyXML(content) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a, _b, _c;\n  var updatedOptions = {\n    rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : \"root\",\n    includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,\n    xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n  };\n  var dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];\n  return '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + getSerializer().serializeToString(dom);\n}\nfunction buildAttributes(attrs) {\n  var result = [];\n  for (var _i2 = 0, _Object$keys = Object.keys(attrs); _i2 < _Object$keys.length; _i2++) {\n    var key = _Object$keys[_i2];\n    var attr = getDoc().createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\nfunction buildNode(obj, elementName, options) {\n  if (obj === undefined || obj === null || typeof obj === \"string\" || typeof obj === \"number\" || typeof obj === \"boolean\") {\n    var elem = getDoc().createElement(elementName);\n    elem.textContent = obj === undefined || obj === null ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    var result = [];\n    var _iterator = _createForOfIteratorHelper(obj),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var arrayElem = _step.value;\n        var _iterator2 = _createForOfIteratorHelper(buildNode(arrayElem, elementName, options)),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var child = _step2.value;\n            result.push(child);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    var _elem = getDoc().createElement(elementName);\n    for (var _i3 = 0, _Object$keys2 = Object.keys(obj); _i3 < _Object$keys2.length; _i3++) {\n      var key = _Object$keys2[_i3];\n      if (key === XML_ATTRKEY) {\n        var _iterator3 = _createForOfIteratorHelper(buildAttributes(obj[key])),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var attr = _step3.value;\n            _elem.attributes.setNamedItem(attr);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      } else if (key === options.xmlCharKey) {\n        _elem.textContent = obj[key].toString();\n      } else {\n        var _iterator4 = _createForOfIteratorHelper(buildNode(obj[key], key, options)),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _child = _step4.value;\n            _elem.appendChild(_child);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    }\n    return [_elem];\n  } else {\n    throw new Error(\"Illegal value passed to buildObject: \".concat(obj));\n  }\n}","map":{"version":3,"names":["XML_ATTRKEY","XML_CHARKEY","self","document","DOMParser","Node","XMLSerializer","Error","cachedDoc","getDoc","implementation","createDocument","cachedParser","getParser","cachedSerializer","getSerializer","ttPolicy","trustedTypes","createPolicy","createHTML","s","parseXML","str","opts","arguments","length","undefined","updatedOptions","rootName","_a","includeRoot","_b","xmlCharKey","_c","dom","parseFromString","_d","throwIfError","obj","domToObject","childNodes","Promise","resolve","err","reject","errorNS","getErrorNamespace","invalidXML","getElementsByTagName","namespaceURI","ignored","parserErrors","i","innerHTML","isElement","node","attributes","asElementWithAttributes","hasAttributes","options","result","childNodeCount","firstChildNode","onlyChildTextValue","nodeType","TEXT_NODE","nodeValue","elementWithAttributes","attr","nodeName","child","childObject","Array","isArray","push","stringifyXML","content","buildNode","serializeToString","buildAttributes","attrs","_i2","_Object$keys","Object","keys","key","createAttribute","value","toString","elementName","elem","createElement","textContent","_iterator","_createForOfIteratorHelper","_step","n","done","arrayElem","_iterator2","_step2","e","f","_i3","_Object$keys2","_iterator3","_step3","setNamedItem","_iterator4","_step4","appendChild","concat"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\core-http\\src\\util\\xml.browser.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { SerializerOptions, XML_ATTRKEY, XML_CHARKEY } from \"./serializer.common\";\n\nif (!self.document || !self.DOMParser || !self.Node || !self.XMLSerializer) {\n  throw new Error(\n    `This library depends on the following DOM objects: [\"document\", \"DOMParser\", \"Node\", \"XMLSerializer\"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. `\n  );\n}\n\nlet cachedDoc: Document | undefined;\nfunction getDoc(): Document {\n  if (!cachedDoc) {\n    cachedDoc = document.implementation.createDocument(null, null, null);\n  }\n  return cachedDoc;\n}\n\nlet cachedParser: DOMParser | undefined;\nfunction getParser(): DOMParser {\n  if (!cachedParser) {\n    cachedParser = new DOMParser();\n  }\n  return cachedParser;\n}\n\nlet cachedSerializer: XMLSerializer | undefined;\nfunction getSerializer(): XMLSerializer {\n  if (!cachedSerializer) {\n    cachedSerializer = new XMLSerializer();\n  }\n  return cachedSerializer;\n}\n\n// Policy to make our code Trusted Types compliant.\n//   https://github.com/w3c/webappsec-trusted-types\n// We are calling DOMParser.parseFromString() to parse XML payload from Azure services.\n// The parsed DOM object is not exposed to outside. Scripts are disabled when parsing\n// according to the spec.  There are no HTML/XSS security concerns on the usage of\n// parseFromString() here.\nlet ttPolicy: Pick<TrustedTypePolicy, \"createHTML\"> | undefined;\nif (typeof self.trustedTypes !== \"undefined\") {\n  ttPolicy = self.trustedTypes.createPolicy(\"@azure/core-http#xml.browser\", {\n    createHTML: (s) => s,\n  });\n}\n\nexport function parseXML(str: string, opts: SerializerOptions = {}): Promise<any> {\n  try {\n    const updatedOptions: Required<SerializerOptions> = {\n      rootName: opts.rootName ?? \"\",\n      includeRoot: opts.includeRoot ?? false,\n      xmlCharKey: opts.xmlCharKey ?? XML_CHARKEY,\n    };\n    const dom = getParser().parseFromString(\n      (ttPolicy?.createHTML(str) ?? str) as string,\n      \"application/xml\"\n    );\n    throwIfError(dom);\n\n    let obj;\n    if (updatedOptions.includeRoot) {\n      obj = domToObject(dom, updatedOptions);\n    } else {\n      obj = domToObject(dom.childNodes[0], updatedOptions);\n    }\n\n    return Promise.resolve(obj);\n  } catch (err: any) {\n    return Promise.reject(err);\n  }\n}\n\nlet errorNS: string | undefined;\n\nfunction getErrorNamespace(): string {\n  if (errorNS === undefined) {\n    try {\n      const invalidXML = (ttPolicy?.createHTML(\"INVALID\") ?? \"INVALID\") as string;\n      errorNS =\n        getParser().parseFromString(invalidXML, \"text/xml\").getElementsByTagName(\"parsererror\")[0]\n          .namespaceURI! ?? \"\";\n    } catch (ignored: any) {\n      // Most browsers will return a document containing <parsererror>, but IE will throw.\n      errorNS = \"\";\n    }\n  }\n  return errorNS;\n}\n\nfunction throwIfError(dom: Document): void {\n  const parserErrors = dom.getElementsByTagName(\"parsererror\");\n  if (parserErrors.length > 0 && getErrorNamespace()) {\n    for (let i = 0; i < parserErrors.length; i++) {\n      if (parserErrors[i].namespaceURI === errorNS) {\n        throw new Error(parserErrors[i].innerHTML);\n      }\n    }\n  }\n}\n\nfunction isElement(node: Node): node is Element {\n  return !!(node as Element).attributes;\n}\n\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node: Node): Element | undefined {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\n\nfunction domToObject(node: Node, options: Required<SerializerOptions>): any {\n  let result: any = {};\n\n  const childNodeCount: number = node.childNodes.length;\n\n  const firstChildNode: Node = node.childNodes[0];\n  const onlyChildTextValue: string | undefined =\n    (firstChildNode &&\n      childNodeCount === 1 &&\n      firstChildNode.nodeType === Node.TEXT_NODE &&\n      firstChildNode.nodeValue) ||\n    undefined;\n\n  const elementWithAttributes: Element | undefined = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[XML_ATTRKEY] = {};\n\n    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {\n      const attr = elementWithAttributes.attributes[i];\n      result[XML_ATTRKEY][attr.nodeName] = attr.nodeValue;\n    }\n\n    if (onlyChildTextValue) {\n      result[options.xmlCharKey] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n\n  if (!onlyChildTextValue) {\n    for (let i = 0; i < childNodeCount; i++) {\n      const child = node.childNodes[i];\n      // Ignore leading/trailing whitespace nodes\n      if (child.nodeType !== Node.TEXT_NODE) {\n        const childObject: any = domToObject(child, options);\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function stringifyXML(content: unknown, opts: SerializerOptions = {}): string {\n  const updatedOptions: Required<SerializerOptions> = {\n    rootName: opts.rootName ?? \"root\",\n    includeRoot: opts.includeRoot ?? false,\n    xmlCharKey: opts.xmlCharKey ?? XML_CHARKEY,\n  };\n  const dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];\n  return (\n    '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' +\n    getSerializer().serializeToString(dom)\n  );\n}\n\nfunction buildAttributes(attrs: { [key: string]: { toString(): string } }): Attr[] {\n  const result = [];\n  for (const key of Object.keys(attrs)) {\n    const attr = getDoc().createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\n\nfunction buildNode(obj: any, elementName: string, options: Required<SerializerOptions>): Node[] {\n  if (\n    obj === undefined ||\n    obj === null ||\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\"\n  ) {\n    const elem = getDoc().createElement(elementName);\n    elem.textContent = obj === undefined || obj === null ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    const result = [];\n    for (const arrayElem of obj) {\n      for (const child of buildNode(arrayElem, elementName, options)) {\n        result.push(child);\n      }\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    const elem = getDoc().createElement(elementName);\n    for (const key of Object.keys(obj)) {\n      if (key === XML_ATTRKEY) {\n        for (const attr of buildAttributes(obj[key])) {\n          elem.attributes.setNamedItem(attr);\n        }\n      } else if (key === options.xmlCharKey) {\n        elem.textContent = obj[key].toString();\n      } else {\n        for (const child of buildNode(obj[key], key, options)) {\n          elem.appendChild(child);\n        }\n      }\n    }\n    return [elem];\n  } else {\n    throw new Error(`Illegal value passed to buildObject: ${obj}`);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}