{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { Constants } from \"../util/constants\";\nimport { DEFAULT_CLIENT_MAX_RETRY_COUNT } from \"../util/throttlingRetryStrategy\";\nimport { delay } from \"@azure/core-util\";\nconst StatusCodes = Constants.HttpConstants.StatusCodes;\n/**\n * Creates a policy that re-sends the request if the response indicates the request failed because of throttling reasons.\n * For example, if the response contains a `Retry-After` header, it will retry sending the request based on the value of that header.\n *\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n * @returns\n */\nexport function throttlingRetryPolicy() {\n  return {\n    create: (nextPolicy, options) => {\n      return new ThrottlingRetryPolicy(nextPolicy, options);\n    }\n  };\n}\nconst StandardAbortMessage = \"The operation was aborted.\";\n/**\n * Creates a policy that re-sends the request if the response indicates the request failed because of throttling reasons.\n * For example, if the response contains a `Retry-After` header, it will retry sending the request based on the value of that header.\n *\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\nexport class ThrottlingRetryPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, options, _handleResponse) {\n    super(nextPolicy, options);\n    this.numberOfRetries = 0;\n    this._handleResponse = _handleResponse || this._defaultResponseHandler;\n  }\n  async sendRequest(httpRequest) {\n    const response = await this._nextPolicy.sendRequest(httpRequest.clone());\n    if (response.status !== StatusCodes.TooManyRequests && response.status !== StatusCodes.ServiceUnavailable) {\n      return response;\n    } else {\n      return this._handleResponse(httpRequest, response);\n    }\n  }\n  async _defaultResponseHandler(httpRequest, httpResponse) {\n    var _a;\n    const retryAfterHeader = httpResponse.headers.get(Constants.HeaderConstants.RETRY_AFTER);\n    if (retryAfterHeader) {\n      const delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);\n      if (delayInMs) {\n        this.numberOfRetries += 1;\n        await delay(delayInMs, {\n          abortSignal: httpRequest.abortSignal,\n          abortErrorMsg: StandardAbortMessage\n        });\n        if ((_a = httpRequest.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n          throw new AbortError(StandardAbortMessage);\n        }\n        if (this.numberOfRetries < DEFAULT_CLIENT_MAX_RETRY_COUNT) {\n          return this.sendRequest(httpRequest);\n        } else {\n          return this._nextPolicy.sendRequest(httpRequest);\n        }\n      }\n    }\n    return httpResponse;\n  }\n  static parseRetryAfterHeader(headerValue) {\n    const retryAfterInSeconds = Number(headerValue);\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  }\n  static parseDateRetryAfterHeader(headerValue) {\n    try {\n      const now = Date.now();\n      const date = Date.parse(headerValue);\n      const diff = date - now;\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error) {\n      return undefined;\n    }\n  }\n}","map":{"version":3,"names":["BaseRequestPolicy","AbortError","Constants","DEFAULT_CLIENT_MAX_RETRY_COUNT","delay","StatusCodes","HttpConstants","throttlingRetryPolicy","create","nextPolicy","options","ThrottlingRetryPolicy","StandardAbortMessage","constructor","_handleResponse","numberOfRetries","_defaultResponseHandler","sendRequest","httpRequest","response","_nextPolicy","clone","status","TooManyRequests","ServiceUnavailable","httpResponse","retryAfterHeader","headers","get","HeaderConstants","RETRY_AFTER","delayInMs","parseRetryAfterHeader","abortSignal","abortErrorMsg","_a","aborted","headerValue","retryAfterInSeconds","Number","isNaN","parseDateRetryAfterHeader","now","Date","date","parse","diff","undefined","error"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\core-http\\src\\policies\\throttlingRetryPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./requestPolicy\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { Constants } from \"../util/constants\";\nimport { DEFAULT_CLIENT_MAX_RETRY_COUNT } from \"../util/throttlingRetryStrategy\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResourceLike } from \"../webResource\";\nimport { delay } from \"@azure/core-util\";\n\ntype ResponseHandler = (\n  httpRequest: WebResourceLike,\n  response: HttpOperationResponse\n) => Promise<HttpOperationResponse>;\nconst StatusCodes = Constants.HttpConstants.StatusCodes;\n\n/**\n * Creates a policy that re-sends the request if the response indicates the request failed because of throttling reasons.\n * For example, if the response contains a `Retry-After` header, it will retry sending the request based on the value of that header.\n *\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n * @returns\n */\nexport function throttlingRetryPolicy(): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ThrottlingRetryPolicy(nextPolicy, options);\n    },\n  };\n}\n\nconst StandardAbortMessage = \"The operation was aborted.\";\n\n/**\n * Creates a policy that re-sends the request if the response indicates the request failed because of throttling reasons.\n * For example, if the response contains a `Retry-After` header, it will retry sending the request based on the value of that header.\n *\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\nexport class ThrottlingRetryPolicy extends BaseRequestPolicy {\n  private _handleResponse: ResponseHandler;\n  private numberOfRetries = 0;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    _handleResponse?: ResponseHandler\n  ) {\n    super(nextPolicy, options);\n    this._handleResponse = _handleResponse || this._defaultResponseHandler;\n  }\n\n  public async sendRequest(httpRequest: WebResourceLike): Promise<HttpOperationResponse> {\n    const response = await this._nextPolicy.sendRequest(httpRequest.clone());\n    if (\n      response.status !== StatusCodes.TooManyRequests &&\n      response.status !== StatusCodes.ServiceUnavailable\n    ) {\n      return response;\n    } else {\n      return this._handleResponse(httpRequest, response);\n    }\n  }\n\n  private async _defaultResponseHandler(\n    httpRequest: WebResourceLike,\n    httpResponse: HttpOperationResponse\n  ): Promise<HttpOperationResponse> {\n    const retryAfterHeader: string | undefined = httpResponse.headers.get(\n      Constants.HeaderConstants.RETRY_AFTER\n    );\n\n    if (retryAfterHeader) {\n      const delayInMs: number | undefined =\n        ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);\n      if (delayInMs) {\n        this.numberOfRetries += 1;\n\n        await delay(delayInMs, {\n          abortSignal: httpRequest.abortSignal,\n          abortErrorMsg: StandardAbortMessage,\n        });\n\n        if (httpRequest.abortSignal?.aborted) {\n          throw new AbortError(StandardAbortMessage);\n        }\n\n        if (this.numberOfRetries < DEFAULT_CLIENT_MAX_RETRY_COUNT) {\n          return this.sendRequest(httpRequest);\n        } else {\n          return this._nextPolicy.sendRequest(httpRequest);\n        }\n      }\n    }\n\n    return httpResponse;\n  }\n\n  public static parseRetryAfterHeader(headerValue: string): number | undefined {\n    const retryAfterInSeconds = Number(headerValue);\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  }\n\n  public static parseDateRetryAfterHeader(headerValue: string): number | undefined {\n    try {\n      const now: number = Date.now();\n      const date: number = Date.parse(headerValue);\n      const diff = date - now;\n\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error: any) {\n      return undefined;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}