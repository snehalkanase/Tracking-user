{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Genxhire/Projects/Website/esurveillance-local-tracker/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as utils from \"./util/utils\";\nimport { MapperType } from \"./serializer\";\nimport { DefaultDeserializationOptions, deserializationPolicy } from \"./policies/deserializationPolicy\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { DefaultRedirectOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport { DefaultRetryOptions, exponentialRetryPolicy } from \"./policies/exponentialRetryPolicy\";\nimport { logPolicy } from \"./policies/logPolicy\";\nimport { getPathStringFromParameter, getPathStringFromParameterPath } from \"./operationParameter\";\nimport { getStreamResponseStatusCodes } from \"./operationSpec\";\nimport { WebResource, isWebResourceLike } from \"./webResource\";\nimport { RequestPolicyOptions } from \"./policies/requestPolicy\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nimport { isNode } from \"@azure/core-util\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { getDefaultUserAgentHeaderName, getDefaultUserAgentValue, userAgentPolicy } from \"./policies/userAgentPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { URLBuilder } from \"./url\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { logger } from \"./log\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { stringifyXML } from \"./util/xml\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\n/**\n * ServiceClient sends service requests and receives responses.\n */\nexport var ServiceClient = /*#__PURE__*/function () {\n  /**\n   * The ServiceClient constructor\n   * @param credentials - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  function ServiceClient(credentials, /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n  options) {\n    var _this = this;\n    _classCallCheck(this, ServiceClient);\n    if (!options) {\n      options = {};\n    }\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n    var requestPolicyFactories;\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      var authPolicyFactory = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\"ServiceClient: creating bearer token authentication policy from provided credentials\");\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        var wrappedPolicyFactory = function wrappedPolicyFactory() {\n          var bearerTokenPolicyFactory = undefined;\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          var serviceClient = _this;\n          var serviceClientOptions = options;\n          return {\n            create: function create(nextPolicy, createOptions) {\n              var credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);\n              if (!credentialScopes) {\n                throw new Error(\"When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy\");\n              }\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, credentialScopes);\n              }\n              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n            }\n          };\n        };\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        var newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n  _createClass(ServiceClient, [{\n    key: \"sendRequest\",\n    value: function sendRequest(options) {\n      if (options === null || options === undefined || typeof options !== \"object\") {\n        throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n      }\n      var httpRequest;\n      try {\n        if (isWebResourceLike(options)) {\n          options.validateRequestProperties();\n          httpRequest = options;\n        } else {\n          httpRequest = new WebResource();\n          httpRequest = httpRequest.prepare(options);\n        }\n      } catch (error) {\n        return Promise.reject(error);\n      }\n      var httpPipeline = this._httpClient;\n      if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n        for (var i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n          httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);\n        }\n      }\n      return httpPipeline.sendRequest(httpRequest);\n    }\n    /**\n     * Send an HTTP request that is populated using the provided OperationSpec.\n     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n     * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n     * @param callback - The callback to call when the response is received.\n     */\n  }, {\n    key: \"sendOperationRequest\",\n    value: function () {\n      var _sendOperationRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(operationArguments, operationSpec, callback) {\n        var _a, serializerOptions, httpRequest, result, baseUri, requestUrl, _iterator, _step, urlParameter, urlParameterValue, _iterator2, _step2, queryParameter, queryParameterValue, index, item, _index, contentType, _iterator3, _step3, headerParameter, headerValue, headerCollectionPrefix, _i, _Object$keys, key, options, customHeaderName, rawResponse, sendRequestError, cb;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (typeof operationArguments.options === \"function\") {\n                callback = operationArguments.options;\n                operationArguments.options = undefined;\n              }\n              serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n              httpRequest = new WebResource();\n              _context.prev = 3;\n              baseUri = operationSpec.baseUrl || this.baseUri;\n              if (baseUri) {\n                _context.next = 7;\n                break;\n              }\n              throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n            case 7:\n              httpRequest.method = operationSpec.httpMethod;\n              httpRequest.operationSpec = operationSpec;\n              requestUrl = URLBuilder.parse(baseUri);\n              if (operationSpec.path) {\n                requestUrl.appendPath(operationSpec.path);\n              }\n              if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n                _iterator = _createForOfIteratorHelper(operationSpec.urlParameters);\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    urlParameter = _step.value;\n                    urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);\n                    urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions);\n                    if (!urlParameter.skipEncoding) {\n                      urlParameterValue = encodeURIComponent(urlParameterValue);\n                    }\n                    requestUrl.replaceAll(\"{\".concat(urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter), \"}\"), urlParameterValue);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n              }\n              if (!(operationSpec.queryParameters && operationSpec.queryParameters.length > 0)) {\n                _context.next = 44;\n                break;\n              }\n              _iterator2 = _createForOfIteratorHelper(operationSpec.queryParameters);\n              _context.prev = 14;\n              _iterator2.s();\n            case 16:\n              if ((_step2 = _iterator2.n()).done) {\n                _context.next = 36;\n                break;\n              }\n              queryParameter = _step2.value;\n              queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);\n              if (!(queryParameterValue !== undefined && queryParameterValue !== null)) {\n                _context.next = 34;\n                break;\n              }\n              queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions);\n              if (!(queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null)) {\n                _context.next = 31;\n                break;\n              }\n              if (!(queryParameter.collectionFormat === QueryCollectionFormat.Multi)) {\n                _context.next = 30;\n                break;\n              }\n              if (!(queryParameterValue.length === 0)) {\n                _context.next = 27;\n                break;\n              }\n              return _context.abrupt(\"continue\", 34);\n            case 27:\n              for (index in queryParameterValue) {\n                item = queryParameterValue[index];\n                queryParameterValue[index] = item === undefined || item === null ? \"\" : item.toString();\n              }\n            case 28:\n              _context.next = 31;\n              break;\n            case 30:\n              if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv || queryParameter.collectionFormat === QueryCollectionFormat.Tsv) {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n            case 31:\n              if (!queryParameter.skipEncoding) {\n                if (Array.isArray(queryParameterValue)) {\n                  for (_index in queryParameterValue) {\n                    if (queryParameterValue[_index] !== undefined && queryParameterValue[_index] !== null) {\n                      queryParameterValue[_index] = encodeURIComponent(queryParameterValue[_index]);\n                    }\n                  }\n                } else {\n                  queryParameterValue = encodeURIComponent(queryParameterValue);\n                }\n              }\n              if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== QueryCollectionFormat.Multi && queryParameter.collectionFormat !== QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n              requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n            case 34:\n              _context.next = 16;\n              break;\n            case 36:\n              _context.next = 41;\n              break;\n            case 38:\n              _context.prev = 38;\n              _context.t0 = _context[\"catch\"](14);\n              _iterator2.e(_context.t0);\n            case 41:\n              _context.prev = 41;\n              _iterator2.f();\n              return _context.finish(41);\n            case 44:\n              httpRequest.url = requestUrl.toString();\n              contentType = operationSpec.contentType || this.requestContentType;\n              if (contentType && operationSpec.requestBody) {\n                httpRequest.headers.set(\"Content-Type\", contentType);\n              }\n              if (operationSpec.headerParameters) {\n                _iterator3 = _createForOfIteratorHelper(operationSpec.headerParameters);\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    headerParameter = _step3.value;\n                    headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);\n                    if (headerValue !== undefined && headerValue !== null) {\n                      headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions);\n                      headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n                      if (headerCollectionPrefix) {\n                        for (_i = 0, _Object$keys = Object.keys(headerValue); _i < _Object$keys.length; _i++) {\n                          key = _Object$keys[_i];\n                          httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n                        }\n                      } else {\n                        httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n              }\n              options = operationArguments.options;\n              if (options) {\n                if (options.customHeaders) {\n                  for (customHeaderName in options.customHeaders) {\n                    httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n                  }\n                }\n                if (options.abortSignal) {\n                  httpRequest.abortSignal = options.abortSignal;\n                }\n                if (options.timeout) {\n                  httpRequest.timeout = options.timeout;\n                }\n                if (options.onUploadProgress) {\n                  httpRequest.onUploadProgress = options.onUploadProgress;\n                }\n                if (options.onDownloadProgress) {\n                  httpRequest.onDownloadProgress = options.onDownloadProgress;\n                }\n                if (options.spanOptions) {\n                  // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.\n                  httpRequest.spanOptions = options.spanOptions;\n                }\n                if (options.tracingContext) {\n                  httpRequest.tracingContext = options.tracingContext;\n                }\n                if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n                  httpRequest.shouldDeserialize = options.shouldDeserialize;\n                }\n              }\n              httpRequest.withCredentials = this._withCredentials;\n              serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n              if (httpRequest.streamResponseStatusCodes === undefined) {\n                httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n              }\n              _context.prev = 53;\n              _context.next = 56;\n              return this.sendRequest(httpRequest);\n            case 56:\n              rawResponse = _context.sent;\n              _context.next = 62;\n              break;\n            case 59:\n              _context.prev = 59;\n              _context.t1 = _context[\"catch\"](53);\n              sendRequestError = _context.t1;\n            case 62:\n              if (sendRequestError) {\n                if (sendRequestError.response) {\n                  sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses[\"default\"]);\n                }\n                result = Promise.reject(sendRequestError);\n              } else {\n                result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));\n              }\n              _context.next = 68;\n              break;\n            case 65:\n              _context.prev = 65;\n              _context.t2 = _context[\"catch\"](3);\n              result = Promise.reject(_context.t2);\n            case 68:\n              cb = callback;\n              if (cb) {\n                result.then(function (res) {\n                  return cb(null, res._response.parsedBody, res._response.request, res._response);\n                }).catch(function (err) {\n                  return cb(err);\n                });\n              }\n              return _context.abrupt(\"return\", result);\n            case 71:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[3, 65], [14, 38, 41, 44], [53, 59]]);\n      }));\n      function sendOperationRequest(_x, _x2, _x3) {\n        return _sendOperationRequest.apply(this, arguments);\n      }\n      return sendOperationRequest;\n    }()\n  }]);\n  return ServiceClient;\n}();\nexport function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {\n  var _a, _b, _c, _d, _e, _f;\n  var serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {};\n  var updatedOptions = {\n    rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : \"\",\n    includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,\n    xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY\n  };\n  var xmlCharKey = serializerOptions.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);\n    var bodyMapper = operationSpec.requestBody.mapper;\n    var required = bodyMapper.required,\n      xmlName = bodyMapper.xmlName,\n      xmlElementName = bodyMapper.xmlElementName,\n      serializedName = bodyMapper.serializedName,\n      xmlNamespace = bodyMapper.xmlNamespace,\n      xmlNamespacePrefix = bodyMapper.xmlNamespacePrefix;\n    var typeName = bodyMapper.type.name;\n    try {\n      if (httpRequest.body !== undefined && httpRequest.body !== null || required) {\n        var requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);\n        var isStream = typeName === MapperType.Stream;\n        if (operationSpec.isXML) {\n          var xmlnsKey = xmlNamespacePrefix ? \"xmlns:\".concat(xmlNamespacePrefix) : \"xmlns\";\n          var value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(utils.prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n              rootName: xmlName || serializedName,\n              xmlCharKey: xmlCharKey\n            });\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey: xmlCharKey\n            });\n          }\n        } else if (typeName === MapperType.String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(\"Error \\\"\".concat(error.message, \"\\\" occurred in serializing the payload - \").concat(JSON.stringify(serializedName, undefined, \"  \"), \".\"));\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    var _iterator4 = _createForOfIteratorHelper(operationSpec.formDataParameters),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var formDataParameter = _step4.value;\n        var formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);\n        if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n          var formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n          httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    var result = {};\n    result[options.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = _defineProperty({}, xmlnsKey, xmlNamespace);\n    return result;\n  }\n  return serializedValue;\n}\nfunction getValueOrFunctionResult(value, defaultValueCreator) {\n  var result;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\nfunction createDefaultRequestPolicyFactories(authPolicyFactory, options) {\n  var factories = [];\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n  var userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);\n  var userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({\n      key: userAgentHeaderName,\n      value: userAgentHeaderValue\n    }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n  factories.push(logPolicy({\n    logger: logger.info\n  }));\n  return factories;\n}\n/**\n * Creates an HTTP pipeline based on the given options.\n * @param pipelineOptions - Defines options that are used to configure policies in the HTTP pipeline for an SDK client.\n * @param authPolicyFactory - An optional authentication policy factory to use for signing requests.\n * @returns A set of options that can be passed to create a new {@link ServiceClient}.\n */\nexport function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {\n  var requestPolicyFactories = [];\n  if (pipelineOptions.sendStreamingJson) {\n    requestPolicyFactories.push(ndJsonPolicy());\n  }\n  var userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    var userAgentInfo = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    var defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n  var keepAliveOptions = Object.assign(Object.assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);\n  var retryOptions = Object.assign(Object.assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);\n  var redirectOptions = Object.assign(Object.assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n  var deserializationOptions = Object.assign(Object.assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);\n  var loggingOptions = Object.assign({}, pipelineOptions.loggingOptions);\n  requestPolicyFactories.push(tracingPolicy({\n    userAgent: userAgentValue\n  }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({\n    value: userAgentValue\n  }), generateClientRequestIdPolicy(), deserializationPolicy(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories: requestPolicyFactories\n  };\n}\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent, propertyPath) {\n  if (parent && propertyPath) {\n    var propertyPathLength = propertyPath.length;\n    for (var i = 0; i < propertyPathLength - 1; ++i) {\n      var propertyName = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\nfunction getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {\n  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);\n}\nexport function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {\n  var _a;\n  var value;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  var serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        var propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n        var useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue = parameterMapper.required || parameterPath[0] === \"options\" && parameterPath.length === 2;\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n      // Serialize just for validation purposes.\n      var parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);\n      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n    for (var propertyName in parameterPath) {\n      var propertyMapper = parameterMapper.type.modelProperties[propertyName];\n      var propertyPath = parameterPath[propertyName];\n      var propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer);\n      // Serialize just for validation purposes.\n      var propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n  var result = {\n    propertyFound: false\n  };\n  var i = 0;\n  for (; i < parameterPath.length; ++i) {\n    var parameterPathPart = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n/**\n * Parses an {@link HttpOperationResponse} into a normalized HTTP response object ({@link RestResponse}).\n * @param _response - Wrapper object for http response.\n * @param responseSpec - Mappers for how to parse the response properties.\n * @returns - A normalized response object.\n */\nexport function flattenResponse(_response, responseSpec) {\n  var parsedHeaders = _response.parsedHeaders;\n  var bodyMapper = responseSpec && responseSpec.bodyMapper;\n  var addOperationResponse = function addOperationResponse(obj) {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n  };\n  if (bodyMapper) {\n    var typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      }));\n    }\n    var modelProperties = typeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n    var isPageableResponse = Object.keys(modelProperties).some(function (k) {\n      return modelProperties[k].serializedName === \"\";\n    });\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      var arrayResponse = _toConsumableArray(_response.parsedBody || []);\n      for (var _i2 = 0, _Object$keys2 = Object.keys(modelProperties); _i2 < _Object$keys2.length; _i2++) {\n        var key = _Object$keys2[_i2];\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n      if (parsedHeaders) {\n        for (var _i3 = 0, _Object$keys3 = Object.keys(parsedHeaders); _i3 < _Object$keys3.length; _i3++) {\n          var _key = _Object$keys3[_i3];\n          arrayResponse[_key] = parsedHeaders[_key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n    }\n  }\n  if (bodyMapper || _response.request.method === \"HEAD\" || utils.isPrimitiveType(_response.parsedBody)) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {\n      body: _response.parsedBody\n    }));\n  }\n  return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n}\nfunction getCredentialScopes(options, baseUri) {\n  if (options === null || options === void 0 ? void 0 : options.credentialScopes) {\n    return options.credentialScopes;\n  }\n  if (baseUri) {\n    return \"\".concat(baseUri, \"/.default\");\n  }\n  return undefined;\n}","map":{"version":3,"names":["utils","MapperType","DefaultDeserializationOptions","deserializationPolicy","DefaultKeepAliveOptions","keepAlivePolicy","DefaultRedirectOptions","redirectPolicy","DefaultRetryOptions","exponentialRetryPolicy","logPolicy","getPathStringFromParameter","getPathStringFromParameterPath","getStreamResponseStatusCodes","WebResource","isWebResourceLike","RequestPolicyOptions","XML_ATTRKEY","XML_CHARKEY","isNode","isTokenCredential","getDefaultUserAgentHeaderName","getDefaultUserAgentValue","userAgentPolicy","QueryCollectionFormat","URLBuilder","bearerTokenAuthenticationPolicy","disableResponseDecompressionPolicy","generateClientRequestIdPolicy","getCachedDefaultHttpClient","logger","ndJsonPolicy","proxyPolicy","rpRegistrationPolicy","signingPolicy","stringifyXML","systemErrorRetryPolicy","throttlingRetryPolicy","tracingPolicy","ServiceClient","credentials","options","_this","_classCallCheck","_withCredentials","withCredentials","_httpClient","httpClient","_requestPolicyOptions","httpPipelineLogger","requestPolicyFactories","Array","isArray","info","authPolicyFactory","undefined","wrappedPolicyFactory","bearerTokenPolicyFactory","serviceClient","serviceClientOptions","create","nextPolicy","createOptions","credentialScopes","getCredentialScopes","baseUri","Error","signRequest","createDefaultRequestPolicyFactories","newRequestPolicyFactories","_requestPolicyFactories","_createClass","key","value","sendRequest","httpRequest","validateRequestProperties","prepare","error","Promise","reject","httpPipeline","length","i","_sendOperationRequest","_asyncToGenerator","_regeneratorRuntime","mark","_callee","operationArguments","operationSpec","callback","_a","serializerOptions","result","requestUrl","_iterator","_step","urlParameter","urlParameterValue","_iterator2","_step2","queryParameter","queryParameterValue","index","item","_index","contentType","_iterator3","_step3","headerParameter","headerValue","headerCollectionPrefix","_i","_Object$keys","customHeaderName","rawResponse","sendRequestError","cb","wrap","_callee$","_context","prev","next","baseUrl","method","httpMethod","parse","path","appendPath","urlParameters","_createForOfIteratorHelper","s","n","done","getOperationArgumentValueFromParameter","serializer","serialize","mapper","skipEncoding","encodeURIComponent","replaceAll","concat","serializedName","err","e","f","queryParameters","collectionFormat","Multi","abrupt","toString","Ssv","Tsv","join","setQueryParameter","t0","finish","url","requestContentType","requestBody","headers","set","headerParameters","Object","keys","customHeaders","abortSignal","timeout","onUploadProgress","onDownloadProgress","spanOptions","tracingContext","shouldDeserialize","serializeRequestBody","streamResponseStatusCodes","sent","t1","response","details","flattenResponse","responses","statusCode","resolve","status","t2","then","res","_response","parsedBody","request","catch","stop","sendOperationRequest","_x","_x2","_x3","apply","arguments","_b","updatedOptions","rootName","_c","includeRoot","_d","xmlCharKey","_e","body","bodyMapper","required","xmlName","xmlElementName","xmlNamespace","xmlNamespacePrefix","typeName","type","name","requestBodyParameterPathString","isStream","Stream","isXML","xmlnsKey","getXmlValueWithNamespace","Sequence","prepareXMLRootList","String","_f","match","mediaType","JSON","stringify","message","formDataParameters","formData","_iterator4","_step4","formDataParameter","formDataParameterValue","formDataParameterPropertyName","serializedValue","includes","_defineProperty","getValueOrFunctionResult","defaultValueCreator","factories","generateClientRequestIdHeader","push","clientRequestIdHeaderName","userAgentHeaderName","userAgentHeaderValue","userAgent","rpRegistrationRetryTimeout","noRetryPolicy","deserializationContentTypes","proxySettings","createPipelineFromOptions","pipelineOptions","sendStreamingJson","userAgentValue","userAgentOptions","userAgentPrefix","userAgentInfo","defaultUserAgentInfo","indexOf","keepAliveOptions","assign","retryOptions","redirectOptions","proxyOptions","deserializationOptions","loggingOptions","expectedContentTypes","maxRetries","retryDelayInMs","maxRetryDelayInMs","handleRedirects","decompressResponse","getPropertyParent","parent","propertyPath","propertyPathLength","propertyName","parameter","getOperationArgumentValueFromParameterPath","parameterPath","parameterMapper","isConstant","defaultValue","propertySearchResult","getPropertyFromParameterPath","propertyFound","useDefaultValue","propertyValue","parameterPathString","propertyMapper","modelProperties","propertyPathString","parameterPathPart","responseSpec","parsedHeaders","addOperationResponse","obj","defineProperty","blobBody","readableStreamBody","isPageableResponse","some","k","arrayResponse","_toConsumableArray","_i2","_Object$keys2","_i3","_Object$keys3","isPrimitiveType"],"sources":["C:\\Users\\Genxhire\\Projects\\Website\\esurveillance-local-tracker\\node_modules\\@azure\\core-http\\src\\serviceClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as utils from \"./util/utils\";\nimport { CompositeMapper, DictionaryMapper, Mapper, MapperType, Serializer } from \"./serializer\";\nimport {\n  DefaultDeserializationOptions,\n  DeserializationContentTypes,\n  deserializationPolicy,\n} from \"./policies/deserializationPolicy\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { DefaultRedirectOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport { DefaultRetryOptions, exponentialRetryPolicy } from \"./policies/exponentialRetryPolicy\";\nimport { HttpOperationResponse, RestResponse } from \"./httpOperationResponse\";\nimport { LogPolicyOptions, logPolicy } from \"./policies/logPolicy\";\nimport {\n  OperationParameter,\n  ParameterPath,\n  getPathStringFromParameter,\n  getPathStringFromParameterPath,\n} from \"./operationParameter\";\nimport { OperationSpec, getStreamResponseStatusCodes } from \"./operationSpec\";\nimport {\n  RequestOptionsBase,\n  RequestPrepareOptions,\n  WebResource,\n  WebResourceLike,\n  isWebResourceLike,\n} from \"./webResource\";\nimport {\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./policies/requestPolicy\";\nimport { SerializerOptions, XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nimport { ServiceCallback } from \"./util/utils\";\nimport { isNode } from \"@azure/core-util\";\nimport { TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport {\n  getDefaultUserAgentHeaderName,\n  getDefaultUserAgentValue,\n  userAgentPolicy,\n} from \"./policies/userAgentPolicy\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpPipelineLogger } from \"./httpPipelineLogger\";\nimport { InternalPipelineOptions } from \"./pipelineOptions\";\nimport { OperationArguments } from \"./operationArguments\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { ServiceClientCredentials } from \"./credentials/serviceClientCredentials\";\nimport { URLBuilder } from \"./url\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { logger } from \"./log\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { stringifyXML } from \"./util/xml\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\n\n/**\n * Options to configure a proxy for outgoing requests (Node.js only).\n */\nexport interface ProxySettings {\n  /**\n   * The proxy's host address.\n   */\n  host: string;\n\n  /**\n   * The proxy host's port.\n   */\n  port: number;\n\n  /**\n   * The user name to authenticate with the proxy, if required.\n   */\n  username?: string;\n\n  /**\n   * The password to authenticate with the proxy, if required.\n   */\n  password?: string;\n}\n\n/**\n * An alias of {@link ProxySettings} for future use.\n */\nexport type ProxyOptions = ProxySettings;\n\n/**\n * Options to be provided while creating the client.\n */\nexport interface ServiceClientOptions {\n  /**\n   * An array of factories which get called to create the RequestPolicy pipeline used to send a HTTP\n   * request on the wire, or a function that takes in the defaultRequestPolicyFactories and returns\n   * the requestPolicyFactories that will be used.\n   */\n  requestPolicyFactories?:\n    | RequestPolicyFactory[]\n    | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);\n  /**\n   * The HttpClient that will be used to send HTTP requests.\n   */\n  httpClient?: HttpClient;\n  /**\n   * The HttpPipelineLogger that can be used to debug RequestPolicies within the HTTP pipeline.\n   */\n  httpPipelineLogger?: HttpPipelineLogger;\n  /**\n   * If set to true, turn off the default retry policy.\n   */\n  noRetryPolicy?: boolean;\n  /**\n   * Gets or sets the retry timeout in seconds for AutomaticRPRegistration. Default value is 30.\n   */\n  rpRegistrationRetryTimeout?: number;\n  /**\n   * Whether or not to generate a client request ID header for each HTTP request.\n   */\n  generateClientRequestIdHeader?: boolean;\n  /**\n   * Whether to include credentials in CORS requests in the browser.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials for more information.\n   */\n  withCredentials?: boolean;\n  /**\n   * If specified, a GenerateRequestIdPolicy will be added to the HTTP pipeline that will add a\n   * header to all outgoing requests with this header name and a random UUID as the request ID.\n   */\n  clientRequestIdHeaderName?: string;\n  /**\n   * The content-types that will be associated with JSON or XML serialization.\n   */\n  deserializationContentTypes?: DeserializationContentTypes;\n  /**\n   * The header name to use for the telemetry header while sending the request. If this is not\n   * specified, then \"User-Agent\" will be used when running on Node.js and \"x-ms-useragent\" will\n   * be used when running in a browser.\n   */\n  userAgentHeaderName?: string | ((defaultUserAgentHeaderName: string) => string);\n  /**\n   * The string to be set to the telemetry header while sending the request, or a function that\n   * takes in the default user-agent string and returns the user-agent string that will be used.\n   */\n  userAgent?: string | ((defaultUserAgent: string) => string);\n  /**\n   * Proxy settings which will be used for every HTTP request (Node.js only).\n   */\n  proxySettings?: ProxySettings;\n  /**\n   * If specified, will be used to build the BearerTokenAuthenticationPolicy.\n   */\n  credentialScopes?: string | string[];\n}\n\n/**\n * ServiceClient sends service requests and receives responses.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  protected baseUri?: string;\n\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  protected requestContentType?: string;\n\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  private readonly _httpClient: HttpClient;\n  private readonly _requestPolicyOptions: RequestPolicyOptions;\n\n  private readonly _requestPolicyFactories: RequestPolicyFactory[];\n  private readonly _withCredentials: boolean;\n\n  /**\n   * The ServiceClient constructor\n   * @param credentials - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(\n    credentials?: TokenCredential | ServiceClientCredentials,\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: ServiceClientOptions\n  ) {\n    if (!options) {\n      options = {};\n    }\n\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n\n    let requestPolicyFactories: RequestPolicyFactory[];\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      let authPolicyFactory: RequestPolicyFactory | undefined = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\n          \"ServiceClient: creating bearer token authentication policy from provided credentials\"\n        );\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        const wrappedPolicyFactory: () => RequestPolicyFactory = () => {\n          let bearerTokenPolicyFactory: RequestPolicyFactory | undefined = undefined;\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const serviceClient = this;\n          const serviceClientOptions = options;\n          return {\n            create(nextPolicy: RequestPolicy, createOptions: RequestPolicyOptions): RequestPolicy {\n              const credentialScopes = getCredentialScopes(\n                serviceClientOptions,\n                serviceClient.baseUri\n              );\n\n              if (!credentialScopes) {\n                throw new Error(\n                  `When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`\n                );\n              }\n\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(\n                  credentials,\n                  credentialScopes\n                );\n              }\n\n              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n            },\n          };\n        };\n\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        const newRequestPolicyFactories: void | RequestPolicyFactory[] =\n          options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n\n  /**\n   * Send the provided httpRequest.\n   */\n  sendRequest(options: RequestPrepareOptions | WebResourceLike): Promise<HttpOperationResponse> {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n\n    let httpRequest: WebResourceLike;\n    try {\n      if (isWebResourceLike(options)) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error: any) {\n      return Promise.reject(error);\n    }\n\n    let httpPipeline: RequestPolicy = this._httpClient;\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(\n          httpPipeline,\n          this._requestPolicyOptions\n        );\n      }\n    }\n    return httpPipeline.sendRequest(httpRequest);\n  }\n\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   * @param callback - The callback to call when the response is received.\n   */\n  async sendOperationRequest(\n    operationArguments: OperationArguments,\n    operationSpec: OperationSpec,\n    callback?: ServiceCallback<any>\n  ): Promise<RestResponse> {\n    if (typeof operationArguments.options === \"function\") {\n      callback = operationArguments.options;\n      operationArguments.options = undefined;\n    }\n\n    const serializerOptions = operationArguments.options?.serializerOptions;\n    const httpRequest: WebResourceLike = new WebResource();\n\n    let result: Promise<RestResponse>;\n    try {\n      const baseUri: string | undefined = operationSpec.baseUrl || this.baseUri;\n      if (!baseUri) {\n        throw new Error(\n          \"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\"\n        );\n      }\n\n      httpRequest.method = operationSpec.httpMethod;\n      httpRequest.operationSpec = operationSpec;\n\n      const requestUrl: URLBuilder = URLBuilder.parse(baseUri);\n      if (operationSpec.path) {\n        requestUrl.appendPath(operationSpec.path);\n      }\n      if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n        for (const urlParameter of operationSpec.urlParameters) {\n          let urlParameterValue: string = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            urlParameter,\n            operationSpec.serializer\n          );\n          urlParameterValue = operationSpec.serializer.serialize(\n            urlParameter.mapper,\n            urlParameterValue,\n            getPathStringFromParameter(urlParameter),\n            serializerOptions\n          );\n          if (!urlParameter.skipEncoding) {\n            urlParameterValue = encodeURIComponent(urlParameterValue);\n          }\n          requestUrl.replaceAll(\n            `{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`,\n            urlParameterValue\n          );\n        }\n      }\n      if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n        for (const queryParameter of operationSpec.queryParameters) {\n          let queryParameterValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            queryParameter,\n            operationSpec.serializer\n          );\n          if (queryParameterValue !== undefined && queryParameterValue !== null) {\n            queryParameterValue = operationSpec.serializer.serialize(\n              queryParameter.mapper,\n              queryParameterValue,\n              getPathStringFromParameter(queryParameter),\n              serializerOptions\n            );\n            if (\n              queryParameter.collectionFormat !== undefined &&\n              queryParameter.collectionFormat !== null\n            ) {\n              if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                if (queryParameterValue.length === 0) {\n                  // The collection is empty, no need to try serializing the current queryParam\n                  continue;\n                } else {\n                  for (const index in queryParameterValue) {\n                    const item = queryParameterValue[index];\n                    queryParameterValue[index] =\n                      item === undefined || item === null ? \"\" : item.toString();\n                  }\n                }\n              } else if (\n                queryParameter.collectionFormat === QueryCollectionFormat.Ssv ||\n                queryParameter.collectionFormat === QueryCollectionFormat.Tsv\n              ) {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n            }\n            if (!queryParameter.skipEncoding) {\n              if (Array.isArray(queryParameterValue)) {\n                for (const index in queryParameterValue) {\n                  if (\n                    queryParameterValue[index] !== undefined &&\n                    queryParameterValue[index] !== null\n                  ) {\n                    queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                  }\n                }\n              } else {\n                queryParameterValue = encodeURIComponent(queryParameterValue);\n              }\n            }\n            if (\n              queryParameter.collectionFormat !== undefined &&\n              queryParameter.collectionFormat !== null &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Multi &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Ssv &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Tsv\n            ) {\n              queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n            }\n            requestUrl.setQueryParameter(\n              queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter),\n              queryParameterValue\n            );\n          }\n        }\n      }\n      httpRequest.url = requestUrl.toString();\n\n      const contentType = operationSpec.contentType || this.requestContentType;\n      if (contentType && operationSpec.requestBody) {\n        httpRequest.headers.set(\"Content-Type\", contentType);\n      }\n\n      if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n          let headerValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            headerParameter,\n            operationSpec.serializer\n          );\n          if (headerValue !== undefined && headerValue !== null) {\n            headerValue = operationSpec.serializer.serialize(\n              headerParameter.mapper,\n              headerValue,\n              getPathStringFromParameter(headerParameter),\n              serializerOptions\n            );\n            const headerCollectionPrefix = (headerParameter.mapper as DictionaryMapper)\n              .headerCollectionPrefix;\n            if (headerCollectionPrefix) {\n              for (const key of Object.keys(headerValue)) {\n                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n              }\n            } else {\n              httpRequest.headers.set(\n                headerParameter.mapper.serializedName ||\n                  getPathStringFromParameter(headerParameter),\n                headerValue\n              );\n            }\n          }\n        }\n      }\n\n      const options: RequestOptionsBase | undefined = operationArguments.options;\n      if (options) {\n        if (options.customHeaders) {\n          for (const customHeaderName in options.customHeaders) {\n            httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n          }\n        }\n\n        if (options.abortSignal) {\n          httpRequest.abortSignal = options.abortSignal;\n        }\n\n        if (options.timeout) {\n          httpRequest.timeout = options.timeout;\n        }\n\n        if (options.onUploadProgress) {\n          httpRequest.onUploadProgress = options.onUploadProgress;\n        }\n\n        if (options.onDownloadProgress) {\n          httpRequest.onDownloadProgress = options.onDownloadProgress;\n        }\n\n        if (options.spanOptions) {\n          // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.\n          (httpRequest as any).spanOptions = options.spanOptions;\n        }\n\n        if (options.tracingContext) {\n          httpRequest.tracingContext = options.tracingContext;\n        }\n\n        if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n          httpRequest.shouldDeserialize = options.shouldDeserialize;\n        }\n      }\n\n      httpRequest.withCredentials = this._withCredentials;\n\n      serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n\n      if (httpRequest.streamResponseStatusCodes === undefined) {\n        httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n      }\n\n      let rawResponse: HttpOperationResponse;\n      let sendRequestError;\n      try {\n        rawResponse = await this.sendRequest(httpRequest);\n      } catch (error: any) {\n        sendRequestError = error;\n      }\n      if (sendRequestError) {\n        if (sendRequestError.response) {\n          sendRequestError.details = flattenResponse(\n            sendRequestError.response,\n            operationSpec.responses[sendRequestError.statusCode] ||\n              operationSpec.responses[\"default\"]\n          );\n        }\n        result = Promise.reject(sendRequestError);\n      } else {\n        result = Promise.resolve(\n          flattenResponse(rawResponse!, operationSpec.responses[rawResponse!.status])\n        );\n      }\n    } catch (error: any) {\n      result = Promise.reject(error);\n    }\n\n    const cb = callback;\n    if (cb) {\n      result\n        .then((res) => cb(null, res._response.parsedBody, res._response.request, res._response))\n        .catch((err) => cb(err));\n    }\n\n    return result;\n  }\n}\n\nexport function serializeRequestBody(\n  serviceClient: ServiceClient,\n  httpRequest: WebResourceLike,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec\n): void {\n  const serializerOptions = operationArguments.options?.serializerOptions ?? {};\n  const updatedOptions: Required<SerializerOptions> = {\n    rootName: serializerOptions.rootName ?? \"\",\n    includeRoot: serializerOptions.includeRoot ?? false,\n    xmlCharKey: serializerOptions.xmlCharKey ?? XML_CHARKEY,\n  };\n\n  const xmlCharKey = serializerOptions.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(\n      serviceClient,\n      operationArguments,\n      operationSpec.requestBody,\n      operationSpec.serializer\n    );\n\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const { required, xmlName, xmlElementName, serializedName, xmlNamespace, xmlNamespacePrefix } =\n      bodyMapper;\n    const typeName = bodyMapper.type.name;\n\n    try {\n      if ((httpRequest.body !== undefined && httpRequest.body !== null) || required) {\n        const requestBodyParameterPathString: string = getPathStringFromParameter(\n          operationSpec.requestBody\n        );\n        httpRequest.body = operationSpec.serializer.serialize(\n          bodyMapper,\n          httpRequest.body,\n          requestBodyParameterPathString,\n          updatedOptions\n        );\n\n        const isStream = typeName === MapperType.Stream;\n\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(\n            xmlNamespace,\n            xmlnsKey,\n            typeName,\n            httpRequest.body,\n            updatedOptions\n          );\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(\n              utils.prepareXMLRootList(\n                value,\n                xmlElementName || xmlName || serializedName!,\n                xmlnsKey,\n                xmlNamespace\n              ),\n              {\n                rootName: xmlName || serializedName,\n                xmlCharKey,\n              }\n            );\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey,\n            });\n          }\n        } else if (\n          typeName === MapperType.String &&\n          (operationSpec.contentType?.match(\"text/plain\") || operationSpec.mediaType === \"text\")\n        ) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error: any) {\n      throw new Error(\n        `Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(\n          serializedName,\n          undefined,\n          \"  \"\n        )}.`\n      );\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue: any = getOperationArgumentValueFromParameter(\n        serviceClient,\n        operationArguments,\n        formDataParameter,\n        operationSpec.serializer\n      );\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName: string =\n          formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(\n          formDataParameter.mapper,\n          formDataParameterValue,\n          getPathStringFromParameter(formDataParameter),\n          updatedOptions\n        );\n      }\n    }\n  }\n}\n\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(\n  xmlNamespace: string | undefined,\n  xmlnsKey: string,\n  typeName: string,\n  serializedValue: any,\n  options: Required<SerializerOptions>\n): any {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result: any = {};\n    result[options.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n    return result;\n  }\n\n  return serializedValue;\n}\n\nfunction getValueOrFunctionResult(\n  value: undefined | string | ((defaultValue: string) => string),\n  defaultValueCreator: () => string\n): string {\n  let result: string;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\n\nfunction createDefaultRequestPolicyFactories(\n  authPolicyFactory: RequestPolicyFactory | undefined,\n  options: ServiceClientOptions\n): RequestPolicyFactory[] {\n  const factories: RequestPolicyFactory[] = [];\n\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n\n  const userAgentHeaderName: string = getValueOrFunctionResult(\n    options.userAgentHeaderName,\n    getDefaultUserAgentHeaderName\n  );\n  const userAgentHeaderValue: string = getValueOrFunctionResult(\n    options.userAgent,\n    getDefaultUserAgentValue\n  );\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n\n  factories.push(logPolicy({ logger: logger.info }));\n\n  return factories;\n}\n\n/**\n * Creates an HTTP pipeline based on the given options.\n * @param pipelineOptions - Defines options that are used to configure policies in the HTTP pipeline for an SDK client.\n * @param authPolicyFactory - An optional authentication policy factory to use for signing requests.\n * @returns A set of options that can be passed to create a new {@link ServiceClient}.\n */\nexport function createPipelineFromOptions(\n  pipelineOptions: InternalPipelineOptions,\n  authPolicyFactory?: RequestPolicyFactory\n): ServiceClientOptions {\n  const requestPolicyFactories: RequestPolicyFactory[] = [];\n\n  if (pipelineOptions.sendStreamingJson) {\n    requestPolicyFactories.push(ndJsonPolicy());\n  }\n\n  let userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    const userAgentInfo: string[] = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    const defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n\n  const keepAliveOptions = {\n    ...DefaultKeepAliveOptions,\n    ...pipelineOptions.keepAliveOptions,\n  };\n\n  const retryOptions = {\n    ...DefaultRetryOptions,\n    ...pipelineOptions.retryOptions,\n  };\n\n  const redirectOptions = {\n    ...DefaultRedirectOptions,\n    ...pipelineOptions.redirectOptions,\n  };\n\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n\n  const deserializationOptions = {\n    ...DefaultDeserializationOptions,\n    ...pipelineOptions.deserializationOptions,\n  };\n\n  const loggingOptions: LogPolicyOptions = {\n    ...pipelineOptions.loggingOptions,\n  };\n\n  requestPolicyFactories.push(\n    tracingPolicy({ userAgent: userAgentValue }),\n    keepAlivePolicy(keepAliveOptions),\n    userAgentPolicy({ value: userAgentValue }),\n    generateClientRequestIdPolicy(),\n    deserializationPolicy(deserializationOptions.expectedContentTypes),\n    throttlingRetryPolicy(),\n    systemErrorRetryPolicy(),\n    exponentialRetryPolicy(\n      retryOptions.maxRetries,\n      retryOptions.retryDelayInMs,\n      retryOptions.maxRetryDelayInMs\n    )\n  );\n\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories,\n  };\n}\n\nexport type PropertyParent = { [propertyName: string]: any };\n\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent: PropertyParent, propertyPath: string[]): PropertyParent {\n  if (parent && propertyPath) {\n    const propertyPathLength: number = propertyPath.length;\n    for (let i = 0; i < propertyPathLength - 1; ++i) {\n      const propertyName: string = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\n\nfunction getOperationArgumentValueFromParameter(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameter: OperationParameter,\n  serializer: Serializer\n): any {\n  return getOperationArgumentValueFromParameterPath(\n    serviceClient,\n    operationArguments,\n    parameter.parameterPath,\n    parameter.mapper,\n    serializer\n  );\n}\n\nexport function getOperationArgumentValueFromParameterPath(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameterPath: ParameterPath,\n  parameterMapper: Mapper,\n  serializer: Serializer\n): any {\n  let value: any;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  const serializerOptions = operationArguments.options?.serializerOptions;\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult: PropertySearchResult = getPropertyFromParameterPath(\n          operationArguments,\n          parameterPath\n        );\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n\n        let useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue =\n            parameterMapper.required ||\n            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n\n      // Serialize just for validation purposes.\n      const parameterPathString: string = getPathStringFromParameterPath(\n        parameterPath,\n        parameterMapper\n      );\n      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (const propertyName in parameterPath) {\n      const propertyMapper: Mapper = (parameterMapper as CompositeMapper).type.modelProperties![\n        propertyName\n      ];\n      const propertyPath: ParameterPath = parameterPath[propertyName];\n      const propertyValue: any = getOperationArgumentValueFromParameterPath(\n        serviceClient,\n        operationArguments,\n        propertyPath,\n        propertyMapper,\n        serializer\n      );\n      // Serialize just for validation purposes.\n      const propertyPathString: string = getPathStringFromParameterPath(\n        propertyPath,\n        propertyMapper\n      );\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\n\ninterface PropertySearchResult {\n  propertyValue?: any;\n  propertyFound: boolean;\n}\n\nfunction getPropertyFromParameterPath(\n  parent: { [parameterName: string]: any },\n  parameterPath: string[]\n): PropertySearchResult {\n  const result: PropertySearchResult = { propertyFound: false };\n  let i = 0;\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart: string = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n\n/**\n * Parses an {@link HttpOperationResponse} into a normalized HTTP response object ({@link RestResponse}).\n * @param _response - Wrapper object for http response.\n * @param responseSpec - Mappers for how to parse the response properties.\n * @returns - A normalized response object.\n */\nexport function flattenResponse(\n  _response: HttpOperationResponse,\n  responseSpec: OperationResponse | undefined\n): RestResponse {\n  const parsedHeaders = _response.parsedHeaders;\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n\n  const addOperationResponse = <T extends Record<string, unknown>>(\n    obj: T\n  ): T & {\n    _response: HttpOperationResponse;\n  } => {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response,\n    }) as T & {\n      _response: HttpOperationResponse;\n    };\n  };\n\n  if (bodyMapper) {\n    const typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody,\n      });\n    }\n\n    const modelProperties =\n      (typeName === \"Composite\" && (bodyMapper as CompositeMapper).type.modelProperties) || {};\n    const isPageableResponse = Object.keys(modelProperties).some(\n      (k) => modelProperties[k].serializedName === \"\"\n    );\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      const arrayResponse = [...(_response.parsedBody || [])] as RestResponse & any[];\n\n      for (const key of Object.keys(modelProperties)) {\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n\n      if (parsedHeaders) {\n        for (const key of Object.keys(parsedHeaders)) {\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        ..._response.parsedBody,\n      });\n    }\n  }\n\n  if (\n    bodyMapper ||\n    _response.request.method === \"HEAD\" ||\n    utils.isPrimitiveType(_response.parsedBody)\n  ) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse({\n      ...parsedHeaders,\n      body: _response.parsedBody,\n    });\n  }\n\n  return addOperationResponse({\n    ...parsedHeaders,\n    ..._response.parsedBody,\n  });\n}\n\nfunction getCredentialScopes(\n  options?: ServiceClientOptions,\n  baseUri?: string\n): string | string[] | undefined {\n  if (options?.credentialScopes) {\n    return options.credentialScopes;\n  }\n\n  if (baseUri) {\n    return `${baseUri}/.default`;\n  }\n  return undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}